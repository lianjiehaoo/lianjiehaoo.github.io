<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[GlobalDialog框架使用教程]]></title>
    <url>%2F2017%2F06%2F10%2FGlobalDialog%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[GlobalDialog是由ITalk应用开源的一款全局对话框库。相比于Android原生对话框的繁琐配置，GlobalDialog的优势在于能够快速实现全局对话框的功能（通知账号下线、通知账号异常等）。进一步了解，请访问笔者的Github。 #集成方法在Module的build.gradle文件中添加如下依赖即可。1compile &apos;com.txm.topcodes.globaldialog:globaldialog:0.1.6&apos; #调用方式常规方式：1234567891011new GlobalDialog.Builder().setContext(context) .setDescription(&quot;hello world&quot;) //弹出框的提示信息。.setStyle(GlobalDialog.Style.SingleAlert) //弹窗的样式。有DoubleAlert、SingleAlert两种，默认为后者。.setForce(ture) //设置弹框销毁的策略。默认为true。.setDialogClickListener(new OnDialogClickListener() &#123; //设置回调，也可以不设置。@Overridepublic void onSure() &#123;super.onSure();&#125;&#125;).build().show(); 精简方式：1234new GlobalDialog.Builder().setContext(context) .setDescription(&quot;hello world&quot;) .build().show(); #FAQ 我发现GlobalDialog还存在BUG？GlobalDialog是一个完全开源的框架，如果您在使用过程中发现问题，欢迎在笔者的GitHub创建一个Issue。 我是Eclipse用户，可以使用GlobalDialog么？不可以。 我在Android studio中链接GlobalDialog库失败了？确保您的工程使用的远程仓库为jcenter。12345allprojects &#123;repositories &#123;jcenter()&#125;&#125;]]></content>
      <categories>
        <category>我的Android框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SurfaceView使用教程]]></title>
    <url>%2F2017%2F04%2F26%2FSurfaceView%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[介绍SurfaceView是视图(View)的继承类，这个视图里内嵌了一个专门用于绘制的Surface。你可以控制这个Surface的格式和尺寸。Surfaceview控制这个Surface的绘制位置。Surface是纵深排序(Z-ordered)的，这表明它总在自己所在窗口的后面。Surfaceview提供了一个可见区域，只有在这个可见区域内Surface部分内容才可见，可见区域外的部分不可见。Surface的排版显示受到视图层级关系的影响，它的兄弟视图结点会在顶端显示。这意味者Surface的内容会被它的兄弟视图遮挡，这一特性可以用来放置遮盖物(overlays)(例如，文本和按钮等控件)。注意，如果Surface上面有透明控件，那么它的每次变化都会引起框架重新计算它和顶层控件之间的透明效果，这会影响性能。Surface的排版显示受到视图层级关系的影响，它的兄弟视图结点会在顶端显示。这意味者 surface 的内容会被它的兄弟视图遮挡，这一特性可以用来放置遮盖物(overlays)(例如，文本和按钮等控件)。如果 surface 上面有透明控件，那么它的每次变化都会引起框架重新计算它和顶层控件之间的透明效果，这会影响性能。你可以通过SurfaceHolder接口访问Surface，getHolder()方法可以得到这个接口。Surfaceview 变得可见时，Surface被创建；Surfaceview隐藏前，Surface被销毁。这样能节省资源。如果你要查看Surface被创建和销毁的时机，可以重载surfaceCreated(SurfaceHolder)和 surfaceDestroyed(SurfaceHolder)。SurfaceView的核心在于提供了两个线程：UI线程和渲染线程。这里应注意： 所有 SurfaceView 和 SurfaceHolder.Callback 的方法都会在UI线程里调用，一般来说就是应用程序主线程。所以渲染线程所要访问的各种变量应该作同步处理。 由于Surface可能被销毁，它只在SurfaceHolder.Callback.surfaceCreated()和 SurfaceHolder.Callback.surfaceDestroyed()之间有效，所以要确保渲染线程访问的是合法有效的Surface。 SurfaceView最终还是要和主线程打交道：SurfaceView带有独立的Surface（独立与Window的Surface），这可以让子线程在独立的Surface上面绘制东西，进行SurfaceView的界面绘制，这个子线程就叫做渲染线程，但是要让独立的Surface上面的东西在View 上面展示出来，需要post一个消息给主线程，目的是把该Surface中canvas 上的东西绘制到View的真正的画布上面（window的Surface的canvas上）。 SurfaceView和View的不同之处 View SurfaceView 适用于主动更新 适用于被动刷新 在主线程中进行画面更新 通常通过一个子线程来进行画面更新 绘图中没有使用双缓冲机制 在底层实现中就实现了双缓冲机制 比较了上面的不同之处，显然可以发现，如果一个View需要频繁的刷新，或者在刷新时数据处理量大（可能引起卡顿），可以考虑使用SurfaceView来替代View。 SurfaceView的双缓冲机制即对于每一个SurfaceView对象而言，有两个独立的graphic buffer。在Android SurfaceView的双缓冲机制中是这样实现的：在Buffer A中绘制内容，然后让屏幕显示Buffer A；在下一个循环中，在Buffer B中绘制内容，然后让屏幕显示Buffer B，如此往复。而由于这个双缓冲机制的存在，可能会引起闪屏现象。在第一个”lockCanvas-drawCanvas-unlockCanvasAndPost “循环中，更新的是buffer A的内容；到下一个”lockCanvas-drawCanvas-unlockCanvasAndPost”循环中，更新的是buffer B的内容。 如果buffer A与buffer B中某个buffer内容为空，当屏幕轮流显示它们时，就会出现画面黑屏闪烁现象。解决方法:当准备更新内容时，先判断内容是否为空，只有非空时才启动”lockCanvas-drawCanvas-unlockCanvasAndPost”这个流程。 SurfaceView使用步骤 获取到 SurfaceView对应的SurfaceHolder，通过addCallback()方法设置SurfaceHolder.Callback用于监听Surface的创建和销毁。 创建渲染线程对象。 在子线程中使用 SurfaceHolder 的 lockCanvas（）获取 Surface 上面指定区域的 Canvas。 在该Canvas上绘制图形，绘制结束后，使用SurfaceHolder的unlockCanvasAndPost（）方法解锁Canvas，并且让UI线程把Surface上面的东西绘制到View的Canvas上面。 使用SurfaceHolder的例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class GameUI extends SurfaceView implements SurfaceHolder.Callback &#123;private SurfaceHolder holder;private RenderThread renderThread;private boolean isDraw = false;public GameUI(Context context) &#123;super(context);holder = getHolder();holder.addCallback(this);renderThread = new RenderThread();&#125;public GameUI(Context context, AttributeSet attrs) &#123;super(context, attrs);&#125;public GameUI(Context context, AttributeSet attrs, int defStyleAttr) &#123;super(context, attrs, defStyleAttr);&#125;@Overridepublic void surfaceCreated(SurfaceHolder holder) &#123;isDraw = true;if (!renderThread.isAlive()) &#123;renderThread.start();&#125;&#125;@Overridepublic void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;&#125;@Overridepublic void surfaceDestroyed(SurfaceHolder holder) &#123;isDraw = false;&#125;private class RenderThread extends Thread &#123;@Overridepublic void run() &#123;super.run();while (isDraw) &#123;drawUI();&#125;&#125;&#125;private void drawUI() &#123;try &#123;Canvas canvas = holder.lockCanvas();drawCanvas(canvas);&#125; catch (Exception e) &#123;e.printStackTrace();&#125; finally &#123;//由于双缓冲机制的存在，判断画布是否为空，从而避免黑屏情况。if(canvas!=null)&#123;holder.unlockCanvasAndPost(canvas);&#125;&#125;&#125;private void drawCanvas(Canvas canvas) &#123;// 在 canvas 上绘制需要的图形&#125;&#125; 参考资料1.SurfaceView2.SurfaceView的基本使用]]></content>
      <categories>
        <category>Android View</category>
      </categories>
      <tags>
        <tag>SurfaceView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView使用教程]]></title>
    <url>%2F2017%2F03%2F10%2FWebView%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[如果你想在将web页面作为APP的一部分，那么我们可以使用WebView。WebView在Android中继承了view类，作为承载网页的控件。但是我们应该知道它并没有继承web浏览器的所有特性，它所实现的也只是展示网页，以及一些基本的交互和监听功能。WebView经常被使用的场景是，当你的APP需要向用户展示一个随时可更新的内容，比如用户条款、使用向导。那么这样的话，我们可以在一个Activity中包含一个WebView控件用来展示服务器维护的内容，这些内容可以在服务器随时更改。WeblView另一个使用场景是，当我们需要在一个页面中请求所有用户的数据，一般的做法是写一个layout，然后利用网络请求所有所需数据，最后将这些数据填充到layout中。但最简洁的方式是，我们其实可以直接加载一个网页，这个网页包含了需要的数据。这个教程将帮助你学会使用WebView，以及关于它高级一点的用法，比如页面跳转、js交互等。 添加WebView到你的应用添加WebView到你的应用最简单的方式是在Layout中添加&lt; WebView &gt;标签，例如下面的例子表示一个全屏的WebView。123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;WebView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:id=&quot;@+id/webview&quot;android:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;fill_parent&quot;/&gt; 加载网页，调用loadUrl()方法即可。12WebView myWebView = (WebView) findViewById(R.id.webview);myWebView.loadUrl(&quot;http://www.example.com&quot;); 请求服务器网页时，别忘了要加网络请求权限。1234&lt;manifest ... &gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;...&lt;/manifest&gt; 以上就是最简单的加载网页方式。 在WebView中使用JavaScript如果你在APP展示的网页中包含JS，那么请确保WebView支持JS的加载。在此之后，你还可以新建接口让WebView与Android代码交互。 授权使用JavaScriptWebView默认不支持JS的加载，开启它需要调用WebSetting的setJavaScriptEnable()方法。WebSetting可以通过WebView的getSettings()方法获得。123WebView myWebView = (WebView) findViewById(R.id.webview);WebSettings webSettings = myWebView.getSettings();webSettings.setJavaScriptEnabled(true); WebSetting提供了许多使用性的功能，比如你想让你幸幸苦苦开发的web page只能在自己的android应用中展示，那么可以在客户端通过setUserAgentString()设置用户代理之后，在服务端遍历userAgentString字段是否是自己的客户端所设定的。 在Android代码中绑定JavaScript代码通过接口的方式，你可以使你的Android代码和JavaScript代码进行交互。例如，你的JavaScript代码可以调用Android代码弹出一个提示框，而不是使用JavaScript的Alert（）方法。让JavaScript和Android代码产生联系的关键是addJavaScriptInterface()方法，此方法包含两个参数，第一个是一个类对象，供JavaScript调用。第二个是接口名称，它用在JavaScript中作为调用Android方法的别名。例如：1234567891011121314public class WebAppInterface &#123;Context mContext;/** Instantiate the interface and set the context */WebAppInterface(Context c) &#123;mContext = c;&#125;/** Show a toast from the web page */@JavascriptInterfacepublic void showToast(String toast) &#123;Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();&#125;&#125; 特别提醒：如果你的Android目标SDK版本在17或以上，你必须在那些将要在JavaScript中调用的方法体前使用@JavascriptInterface标识。否则，这些方法将不会被调用。 在这个实例中，WebAppInterface允许JavaScript运行showToast方法弹出一个Toast。你可以运行这段代码通过WebView的addJavaScriptInterface()方法，并指定接口的名称为“Android”，例如：12WebView webView = (WebView) findViewById(R.id.webview);webView.addJavascriptInterface(new WebAppInterface(this), &quot;Android&quot;); 这段代码为运行在WebView中的JavaScript创建了一个接口“Android”，那么现在你的JavaScript已经有能力访问WebAppInterface中的showToast方法了。下面的HTML和JS代码将调用showToast方法弹出Toast提示。123456&lt;input type=&quot;button&quot; value=&quot;Say hello&quot; onClick=&quot;showAndroidToast(&apos;Hello Android!&apos;)&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt;function showAndroidToast(toast) &#123;Android.showToast(toast);&#125;&lt;/script&gt; 如你所看到的，在JS中使用“Android”这个接口时，并不需要初始化它，在此之前，WebView已经为你准备好了一些，你只需要通过它调用逻辑即可。 注意：1.WebAppInterface的实例将运行在另一个线程，并不在原来新建它的线程。2.由于通过JS可以调用本地的Android代码，那么我们对于这点要非常的谨慎。对于不受信任的web链接，不应该使用addJavascriptInterface()，除非这个链接是自己本人写的或者其它应该充分信任它的理由。同时，对于不信任的网站，我们在处理它的跳转时应该非常小心，不应该在我们的WebView中直接接受链接的跳转。（默认情况，WebView网页中的链接会跳转到手机的Web浏览器，这是保证安全的前提下一种很好的处理方法。但是，在接下来会提到的serWebViewClient()方法中，你可以自定义链接的行为，这就需要小心了。） 页面导航当用户在WebView点击一个链接后，默认的行为是在web浏览器中打开该链接所指向的网页。正如上面所提及的一样，你是可以通过WebView的serWebViewClient方法自定义这个行为的。例如在自己的WebView中展示跳转的内容，而不是跳转到web浏览器。12WebView myWebView = (WebView) findViewById(R.id.webview);myWebView.setWebClient(new WebClient()); 当然你还可以做更多：12345678910111213private class MyWebViewClient extends WebViewClient &#123;@Overridepublic boolean shouldOverrideUrlLoading(WebView view,String url)&#123;if (Uri.parse(url).getHost().equals(&quot;www.example.com&quot;)) &#123;// This is my web site, so do not override; let my WebView load the pagereturn false;&#125;// Otherwise, the link is not for a page on my site, so launch another Activity that handles URLsIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));startActivity(intent);return true;&#125;&#125; 然后创建MyWebViewClient的实例作为setWebClient()的参数。12WebView myWebView = (WebView) findViewById(R.id.webview);myWebView.setWebClient(new MyWebViewClient()); 导航web的浏览记录在WebView中浏览网页时，我们可能会通过web中包含的外链跳转到其它的网页（在同一Webview页面中），那么这些跳转记录是可以来回切换的，这里主要涉及到goBack()和goForward()方法的使用。例如下面的例子，我们通过设备的返回按钮让WebView回退到上一个页面，或者退出当前Activity。1234567891011@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123; // Check if the key event was the Back button and if there&apos;s history if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; myWebView.canGoBack()) &#123; myWebView.goBack()); return true; &#125; // If it wasn&apos;t the Back key or there&apos;s no web page history, bubble up to the default // system behavior (probably exit the activity) return super.onKeyDown(keyCode, event);&#125; 参考资料Building Web Apps in WebView]]></content>
      <categories>
        <category>Android View</category>
      </categories>
      <tags>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之Volatile和Automic]]></title>
    <url>%2F2017%2F02%2F21%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BVolatile%E5%92%8CAutomic%2F</url>
    <content type="text"><![CDATA[volatile的特性当我们声明共享变量为volatile后，对这个变量的读/写将会很特别。理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步(实际上不是完全一样的，后面会提到)。下面我们通过具体的示例来说明，请看下面的示例代码：12345678910111213141516class VolatileFeaturesExample &#123;//使用volatile声明64位的long型变量volatile long vl = 0L;public void set(long l) &#123;vl = l; //单个volatile变量的写&#125;public void getAndIncrement () &#123;vl++; //复合（多个）volatile变量的读/写&#125;public long get() &#123;return vl; //单个volatile变量的读&#125;&#125; 假设有多个线程分别调用上面程序的三个方法，这个程序在语义上和下面程序等价：123456789101112131415161718class VolatileFeaturesExample &#123;long vl = 0L; // 64位的long型普通变量//对单个的普通 变量的写用同一个锁同步public synchronized void set(long l) &#123; vl = l;&#125;public void getAndIncrement () &#123; //普通方法调用long temp = get(); //调用已同步的读方法temp += 1L; //普通写操作set(temp); //调用已同步的写方法&#125;public synchronized long get() &#123; //对单个的普通变量的读用同一个锁同步return vl;&#125;&#125; 如上面示例程序所示，对一个volatile变量的单个读/写操作，与对一个普通变量的读/写操作使用同一个锁来同步，它们之间的执行效果相同。锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。简而言之，volatile变量自身具有下列特性：1.可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。2.原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。 volatile 与 synchronized 的比较volatile主要用在多个线程感知实例变量被更改的场合，从而使得各个线程获得最新的值。比较：①volatile轻量级，只能修饰变量。synchronized重量级，还可修饰方法。②volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞。synchronized不仅保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。 由锁释放和获取的内存语义引申volatile当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须要“从主内存中去读取共享变量”。实际上，锁释放-获取的内存语义与volatile写-读的内存语义有着一一对应的关系，锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。下面对锁释放和锁获取的内存语义做个总结（volatile的读、写类似）： 线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。 线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。 AtomicInteger介绍原子操作在多线程场景是很有必要的，它可以避免数据的二义性产生。下面的程序中我们新建了两个线程，每个线程对同一个数增加了4次，每次加1，最后的结果正确应该是8。12345678910111213141516171819202122232425262728293031323334353637383940public class JavaAtomic &#123;public static void main(String[] args) throws InterruptedException &#123;ProcessingThread pt = new ProcessingThread();Thread t1 = new Thread(pt, &quot;t1&quot;);t1.start();Thread t2 = new Thread(pt, &quot;t2&quot;);t2.start();t1.join();t2.join();System.out.println(&quot;Processing count=&quot; + pt.getCount());&#125;&#125;class ProcessingThread implements Runnable &#123;private int count;@Overridepublic void run() &#123;for (int i = 1; i &lt; 5; i++) &#123;processSomething(i);count++;&#125;&#125;public int getCount() &#123;return this.count;&#125;private void processSomething(int i) &#123;// processing some jobtry &#123;Thread.sleep(i * 1000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125; 运行上面的程序后，你会发现最后的运行结果每次都不一样，可能是5，6，7或者8。原因就是count++不具备原子性，当一个线程读取了count的值并进行完加1操作时，另外一个线程还是引用的原来旧的count值，这样就导致了最后加1后的结果不符合预期的现象。为了解决这个问题，我们除了可以使用Synchronized、Lock，还可以使用 Java 5 java.util.concurrent.atomic提供的AutomicInteger实现原子操作。并且在程序逻辑允许的情况下，我们应该优先使用atomic，它在执行速度、可读性、实用性方面均优于前两者。1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.concurrent.atomic.AtomicInteger;public class JavaAtomic &#123;public static void main(String[] args) throws InterruptedException &#123;ProcessingThread pt = new ProcessingThread();Thread t1 = new Thread(pt, &quot;t1&quot;);t1.start();Thread t2 = new Thread(pt, &quot;t2&quot;);t2.start();t1.join();t2.join();System.out.println(&quot;Processing count=&quot; + pt.getCount());&#125;&#125;class ProcessingThread implements Runnable &#123;private AtomicInteger count = new AtomicInteger();@Overridepublic void run() &#123;for (int i = 1; i &lt; 5; i++) &#123;processSomething(i);count.incrementAndGet();&#125;&#125;public int getCount() &#123;return this.count.get();&#125;private void processSomething(int i) &#123;// processing some jobtry &#123;Thread.sleep(i * 1000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125; 参考资料1.并发编程网2.AtomicInteger in Java]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之Lock]]></title>
    <url>%2F2017%2F01%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BLock%2F</url>
    <content type="text"><![CDATA[相对于Synchronized,我们还可以使用更加人性化的Lock关键字作为线程同步的实现方案。本篇文章将详细介绍Lock的相关用法以及使用它的优势。 使用Lock同步代码块Java提供另外的机制用来同步代码块。它比synchronized关键字更加强大、灵活。它是基于Lock接口和实现它的类（如ReentrantLock）。这种机制有如下优势： 它允许以一种更灵活的方式来构建synchronized块。使用synchronized关键字，你必须以结构化方式得到释放synchronized代码块的控制权。Lock接口允许你获得更复杂的结构来实现你的临界区。 Lock接口比synchronized关键字提供更多额外的功能，新功能之一是它提供的tryLock()方法。这种方法试图获取锁的控制权并且如果它不能获取该锁是由于其他线程在使用这个锁，它将返回false。使用synchronized关键字，当线程A试图执行synchronized代码块，如果线程B正在执行它，那么线程A将阻塞直到线程B执行完synchronized代码块。使用Lock，你可以执行tryLock()方法，这个方法返回一个Boolean值表示是否有其他线程正在运行这个锁所保护的代码。 当有多个读者和一个写者时，Lock接口允许读写操作分离。 Lock接口比synchronized关键字提供更好的性能。 在下面的案例中，你将学习如何通过锁来同步代码块和通过Lock接口及其实现者ReentrantLock类来创建临界区，实现一个程序来模拟打印队列。1.创建PrintQueue类，来实现打印队列。1public class PrintQueue &#123; 2.声明一个Lock对象，并且使用ReentrantLock类的一个新对象来初始化它。1private final Lock queueLock=new ReentrantLock(); 3.实现printJob()方法，它将接收Object对象作为参数，并且不会返回任何值。1public void printJob(Object document)&#123; 4.在printJob()方法内部，通过调用lock()方法来获取Lock对象的控制权。1queueLock.lock(); 5.然后，包含以下代码来模拟文档的打印:1234567try &#123;System.out.printf(&quot;%s:print start!!!\n&quot;, Thread.currentThread().getName());Thread.sleep(1000);System.out.printf(&quot;%s:print end!!!\n&quot;, Thread.currentThread().getName());&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125; 6.最后，通过调用unlock()方法来释放Lock对象的控制。123finally &#123;queueLock.unlock();&#125; 7.创建一个Job类，并指定它实现Runnable接口。1public class Job implements Runnable &#123; 8.声明一个PrintQueue类的对象，并通过实现类（Job类）的构造器来初始化这个对象。1234private PrintQueue printQueue;public Job(PrintQueue printQueue)&#123;this.printQueue=printQueue;&#125; 9.实现run()方法，它使用PrintQueue对象来发送一个打印任务。1234@Overridepublic void run() &#123;printQueue.printJob(new Object());&#125; 10.通过创建类名为Main，且包括main（）方法来实现这个示例的主类。12public class Main &#123;public static void main(String[] args) &#123; 11.创建一个共享的PrintQueue对象。1PrintQueue printQueue=new PrintQueue(); 12.创建5个Job对象，并且使用5个线程来运行它们。1234Thread thread[]=new Thread[5];for (int i=0; i&lt;5; i++)&#123;thread[i]=new Thread(new Job(printQueue));&#125; 13.启动这5个线程。123for (int i=0; i&lt;5; i++)&#123;thread[i].start();&#125; 从以下截图，你可以看到执行这个示例的输出：在 printJob()中，queueLock是这个示例的关键所在。当我们通过锁来实现一个临界区并且保证只有一个执行线程能运行一个代码块，我们必须创建一个ReentrantLock对象。在临界区的起始部分，我们必须通过使用lock()方法来获得锁的控制权。当一个线程A调用这个方法时，如果没有其他线程持有这个锁的控制权，那么这个方法就会给线程A分配这个锁的控制权并允许线程A执行这个临界区。否则，如果其他线程B正在执行由这个锁控制的临界区，lock()方法将会使线程A睡眠直到线程B完成这个临界区的执行。在临界区的尾部，我们必须使用unlock()方法来释放锁的控制权，允许其他线程运行这个临界区。如果你在临界区的尾部没有调用unlock()方法，那么其他正在等待该代码块的线程将会永远等待，造成死锁情况。如果你在临界区使用try-catch代码块，别忘了在finally部分的内部包含unlock()方法的代码。 tryLock()Lock接口（和ReentrantLock类，以及后面要讲的ReadWriteLock接口和ReentrantReadWriteLock类）包含其他方法来获取锁的控制权，那就是tryLock()方法。这个方法与lock()方法的最大区别是，如果一个线程调用这个方法不能获取Lock接口的控制权时，将会立即返回并且不会使这个线程进入睡眠。这个方法返回一个boolean值，true表示这个线程获取了锁的控制权，false则表示没有。 小知识:预先考虑到tryLock()方法的结果，并采取相应的措施，这是程序员的责任。如果这个方法返回false值，预计你的程序不会执行这个临界区。如果是这样，你应该针对此错误结果做相应的处理。 ReentrantLock类也允许递归调用（锁的可重入性），当一个线程有锁的控制权并且使用递归调用，它延续了锁的控制权，所以调用lock()方法将会立即返回并且继续递归调用的执行。 避免死锁你必须要非常小心使用锁来避免死锁，这种情况发生在，当两个或两个以上的线程被阻塞等待将永远不会解开的锁。比如，线程A锁定Lock(X)而线程B锁定 Lock(Y)。如果现在，线程A试图锁住Lock(Y)而线程B同时也试图锁住Lock(X)，这两个线程将无限期地被阻塞，因为它们等待的锁将不会被解开。请注意，这个问题的发生是因为这两个线程尝试以相反的顺序获取锁。 使用读/写锁同步数据访问锁所提供的最重要的改进之一就是ReadWriteLock接口和唯一一个实现它的ReentrantReadWriteLock类。这个类提供两把锁，一把用于读操作和一把用于写操作。同时可以有多个线程执行读操作，但只有一个线程可以执行写操作。当一个线程正在执行一个写操作，不可能有任何线程执行读操作。在下面的例子中，你将会学习如何使用ReadWriteLock接口实现一个程序，使用它来控制访问一个存储两个产品价格的对象。1.创建PricesInfo类，用它来存储两个产品价格的信息。1public class PricesInfo &#123; 2.声明两个double类型的属性，分别命名为price1和price2。12private double price1;private double price2; 3.声明一个名为lock的ReadWriteLock对象。1private ReadWriteLock lock; 4.实现类的构造器，初始化这三个属性。其中，对于lock属性，我们创建一个新的ReentrantReadWriteLock对象。12345public PricesInfo()&#123;price1=1.0;price2=2.0;lock=new ReentrantReadWriteLock();&#125; 5.实现getPrice1()方法，用它来返回price1属性的值。它使用读锁来控制这个属性值的访问。123456public double getPrice1() &#123;lock.readLock().lock();double value=price1;lock.readLock().unlock();return value;&#125; 6.实现getPrice2()方法，用它来返回price2属性的值。它使用读锁来控制这个属性值的访问。123456public double getPrice2() &#123;lock.readLock().lock();double value=price2;lock.readLock().unlock();return value;&#125; 7.实现setPrices()方法，用来建立这两个属性的值。它使用写锁来控制对它们的访问。123456public void setPrices(double price1, double price2) &#123;lock.writeLock().lock();this.price1=price1;this.price2=price2;lock.writeLock().unlock();&#125; 8.创建Reader类，并指定它实现Runnable接口。这个类实现了PricesInfo类属性值的读者。1public class Reader implements Runnable &#123; 9.声明一个PricesInfo对象，并且实现Reader类的构造器来初始化这个对象。1234private PricesInfo pricesInfo;public Reader (PricesInfo pricesInfo)&#123;this.pricesInfo=pricesInfo;&#125; 10.实现Reader类的run()方法，它读取10次两个价格的值。123456789@Overridepublic void run() &#123;for (int i=0; i&lt;10; i++)&#123;System.out.printf(&quot;%s: Price 1: %f\n&quot;, Thread.currentThread().getName(),pricesInfo.getPrice1());System.out.printf(&quot;%s: Price 2: %f\n&quot;, Thread.currentThread().getName(),pricesInfo.getPrice2());&#125;&#125; 11.创建Writer类，并指定它实现Runnable接口。这个类实现了PricesInfo类属性值的修改者。1public class Writer implements Runnable &#123; 12.声明一个PricesInfo对象，并且实现Writer类的构造器来初始化这个对象。1234private PricesInfo pricesInfo;public Writer(PricesInfo pricesInfo)&#123;this.pricesInfo=pricesInfo;&#125; 13.实现run()方法，它修改了三次两个价格的值，并且在每次修改之后睡眠2秒。1234567891011121314@Overridepublic void run() &#123;for (int i=0; i&lt;3; i++) &#123;System.out.printf(&quot;Writer: Attempt to modify theprices.\n&quot;);pricesInfo.setPrices(Math.random()*10, Math.random()*8);System.out.printf(&quot;Writer: Prices have been modified.\n&quot;);try &#123;Thread.sleep(2);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125; 14.通过创建类名为Main，且包括main（）方法来实现这个示例的主类。12public class Main &#123;public static void main(String[] args) &#123; 15.创建一个PricesInfo对象。1PricesInfo pricesInfo=new PricesInfo(); 16.创建5个Reader对象，并且用5个线程来执行它们。123456Reader readers[]=new Reader[5];Thread threadsReader[]=new Thread[5];for (int i=0; i&lt;5; i++)&#123;readers[i]=new Reader(pricesInfo);threadsReader[i]=new Thread(readers[i]);&#125; 17.创建一个Writer对象，并且用线程来执行它。12Writer writer=new Writer(pricesInfo);Thread threadWriter=new Thread(writer); 18.启动这些线程。1234for (int i=0; i&lt;5; i++)&#123;threadsReader[i].start();&#125;threadWriter.start(); 在以下截图中，你可以看到执行这个例子的一个部分输出: 修改Lock的公平性在ReentrantLock类和ReentrantReadWriteLock类的构造器中，允许一个名为fair的boolean类型参数，它允许你来控制这些类的行为。默认值为 false，这将启用非公平模式。在这个模式中，当有多个线程正在等待一把锁（ReentrantLock或者 ReentrantReadWriteLock），这个锁必须选择它们中间的一个来获得进入临界区，选择任意一个是没有任何标准的。true值将开启公平模式。在这个模式中，当有多个线程正在等待一把锁（ReentrantLock或者ReentrantReadWriteLock），这个锁必须选择它们中间的一个来获得进入临界区，它将选择等待时间最长的线程。由于tryLock()方法并不会使线程进入睡眠，即使Lock接口正在被使用，这个公平属性并不会影响它的功能。更多关于公平模式的介绍，请点击查阅。 参考资料并发编程网]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之Synchronized]]></title>
    <url>%2F2016%2F12%2F18%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Synchronized%2F</url>
    <content type="text"><![CDATA[介绍在并发编程中发生的最常见的一种情况是超过一个执行线程使用共享资源。在并发应用程序中，多个线程读或写相同的数据或访问同一文件或数据库连接这是正常的。这些共享资源会引发错误或数据不一致的情况，我们必须通过同步机制来避免这些错误。解决这些问题从临界区的概念开始。临界区是访问一个共享资源在同一时间不能被超过一个线程执行的代码块。Java(和几乎所有的编程语言)提供同步机制，帮助程序员实现临界区。当一个线程想要访问一个临界区,它使用其中的一个同步机制来找出是否有任何其他线程执行临界区。如果没有，这个线程就进入临界区。否则，这个线程通过同步机制暂停直到另一个线程执行完临界区。当多个线程正在等待一个线程完成执行的一个临界区，JVM选择其中一个线程执行，其余的线程会等待直到轮到它们。这个系列的文章将逐一介绍Java提供的几个同步机制：Synchronized、Lock、Automic和Volatile。Synchronized可以标记以下四种类型的代码区域： Instance methods（普通方法） Static methods（静态方法） Code blocks inside instance methods（普通方法内的代码快） Code blocks inside static methods（静态方法内的代码快) 普通同步方法下面是一个普通的同步方法。123public synchronized void add(int value)&#123;this.count += value;&#125; 如果此时A线程和B线程同时对同一个对象的add方法访问，那么只能有一个线程（假设是A线程）能够进入方法体内获得锁资源，此时B线程只能等待A线程执行完方法体后（释放锁资源）才能执行add方法体中的代码。总结一下就是，在同一时刻只能有一个线程能对同一个对象的synchronized方法进行访问。如果一个线程A正在执行一个synchronized方法，而线程B想要执行同个实例对象的非静态synchronized方法，它将阻塞，直到线程A执行完。但是如果线程B访问相同类的不同实例对象，它们都不会被阻塞。 再深入一点：CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。 静态同步方法123public static synchronized void add(int value)&#123;count += value;&#125; 与普通同步方法不同，静态同步方法修饰的对象是整个class对象。只有一个执行线程能访问被synchronized关键字声明的静态方法，但另一个线程可以访问该类的一个对象中的其他非静态的方法。你必须非常小心这一点，因为两个线程可以访问两个不同的同步方法，如果其中一个是静态的而另一个不是。如果这两种方法改变相同的数据,你将会有数据不一致的错误。 普通方法中的同步块123456public void log2(String msg1, String msg2)&#123;synchronized(this)&#123;log.writeln(msg1);log.writeln(msg2);&#125;&#125; 这样调用和普通同步方法实现的效果其实是一样的。注意到“this”字段是一个Monitor对象，它和普通同步方法中锁定的对象是一个概念。 小知识：引用维基百科的说法，monitor是一种线程安全的class,object或者module，即monitor允许多个线程同时访问其内的方法或者属性而不会出现二义性。 静态方法中的同步块123456public static void log2(String msg1, String msg2)&#123;synchronized(MyClass.class)&#123;log.writeln(msg1);log.writeln(msg2);&#125;&#125; 锁的分类以上内容就是对Synchronized关键字使用和触发场景的介绍，下面再从宏观上介绍一下关于锁的分类：（*）偏向锁、轻量锁、重量锁。偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。如果在运行过程中，遇到了其他线程抢占锁，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁。偏向锁只能在单线程下起作用,主要解决无竞争下的锁性能问题。 我们看下无竞争下锁存在什么问题:按照之前的HotSpot设计，每次加锁/解锁都会涉及到一些CAS操作（比如对等待队列的CAS操作），CAS操作会延迟本地调用，因此偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。锁演变的流程是这样的：偏向锁-&gt;轻量级锁-&gt;重量级锁。 参考资料1.并发编程网2.Java Synchronized Blocks]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java正则表达式详解]]></title>
    <url>%2F2016%2F11%2F10%2FJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[为什么要使用正则表达式？节省代码，爱护队友。 在正式介绍之前，先贴一段使用了正则表达式的代码吧。12345String phoneNum = &quot;16510758936&quot;;String patternString = &quot;\\d&#123;11&#125;&quot;;Pattern pattern = Pattern.compile(patternString);Matcher matcher = pattern.matcher(phoneNum);System.out.println(&quot;matches = &quot;+matcher.matches()); 仅这段代码就可以简单判断字符串（代码中的“phoneNum”字符串）是否为手机号格式。是不是很高效呢？事实上正则表达式还可以做很多很酷的事情，所以我们很有必要认真的学一下它。本文将从API、语法两个维度介绍该主题。 API使用类 java.util.regex.Pattern 简称 Pattern, 是Java正则表达式API中的主要入口，无论何时,需要使用正则表达式,从Pattern 类开始 Pattern.matches()这是检测正则表达式的模式是否匹配一段文本的最直接方法，eg：123456String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the pattern.&quot;;String pattern = &quot;.*is.*&quot;;boolean matches = Pattern.matches(pattern, text);System.out.println(&quot;matches = &quot; + matches); “.”表示任意字符，“*”表示0或者多个，“.*”组合表示0或者多个任意字符。显然， “.*is.*“代表一个字符串中包含“is”字段，上面代码返回结果是true。Pattern.matches() 方法适用于检查 一个模式在一个文本中出现一次的情况，或适用于Pattern类的默认设置。如果需要匹配多次出现,甚至输出不同的匹配文本，或者只是需要非默认设置。需要通过Pattern.compile() 方法得到一个Pattern 实例。 Pattern.compile()如果需要匹配一个正则表达式在文本中多次出现，需要通过Pattern.compile() 方法创建一个Pattern对象。示例如下。12345String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the http:// pattern.&quot;;String patternString = &quot;.*http://.*&quot;;Pattern pattern = Pattern.compile(patternString); 可以在Compile 方法中，指定一个特殊标志：Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);Pattern 类包含多个标志(int 类型),这些标志可以控制Pattern 匹配模式的方式。上面代码中的标志使模式匹配是忽略大小写 pattern.matcher()一旦获得了Pattern对象，接着可以获得Matcher对象。Matcher 示例用于匹配文本中的模式.示例如下Matcher matcher = pattern.matcher(text);Matcher类有一个matches()方法，可以检查文本是否匹配模式。以下是关于Matcher的一个完整例子12345678String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the http:// pattern.&quot;;String patternString = &quot;.*http://.*&quot;;Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);Matcher matcher = pattern.matcher(text);boolean matches = matcher.matches();System.out.println(&quot;matches = &quot; + matches); pattern.split()Pattern 类的 split()方法，可以用正则表达式作为分隔符，把文本分割为String类型的数组。示例：12345678String text = &quot;A sep Text sep With sep Many sep Separators&quot;;String patternString = &quot;sep&quot;;Pattern pattern = Pattern.compile(patternString);String[] split = pattern.split(text);System.out.println(&quot;split.length = &quot; + split.length);for(String element : split)&#123;System.out.println(&quot;element = &quot; + element);&#125; 上例中把text 文本分割为一个包含5个字符串的数组。 pattern.pattern()Pattern 类的 pattern 返回用于创建Pattern 对象的正则表达式。 Matcher (java.util.regex.Matcher)java.util.regex.Matcher 类用于匹配一段文本中多次出现一个正则表达式，Matcher 也适用于多文本中匹配同一个正则表达式。 创建Matcher通过Pattern 的matcher() 方法创建一个Matcher。123456String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the http:// pattern.&quot;;String patternString = &quot;.*http://.*&quot;;Pattern pattern = Pattern.compile(patternString);Matcher matcher = pattern.matcher(text); matches()Matcher 类的 matches() 方法用于在文本中匹配正则表达式1boolean matches = matcher.matches(); 如果文本匹配正则表达式，matches() 方法返回true。否则返回false。matches() 方法不能用于查找正则表达式多次出现。如果需要，要使用find(), start() 和 end() 方法。 lookingAt()lookingAt() 与matches() 方法类似，最大的不同是，lookingAt()方法对文本的开头匹配正则表达式；而matches() 对整个文本匹配正则表达式。换句话说，如果正则表达式匹配文本开头而不匹配整个文本,lookingAt() 返回true,而matches() 返回false。 示例：12345678String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the http:// pattern.&quot;;String patternString = &quot;This is the&quot;;Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);Matcher matcher = pattern.matcher(text);System.out.println(&quot;lookingAt = &quot; + matcher.lookingAt());System.out.println(&quot;matches = &quot; + matcher.matches()); 上面的例子分别对文本开头和整个文本匹配正则表达式 “this is the”, 匹配文本开头的方法(lookingAt()) 返回true。对整个文本匹配正则表达式的方法 (matches()) 返回false，因为整个文本包含多余的字符,而正则表达式要求文本精确匹配”this is the”,前后又不能有额外字符。 find() + start() + end()find() 方法用于在文本中查找出现的正则表达式，文本是创建Matcher时，通过 Pattern.matcher(text) 方法传入的。如果在文本中多次匹配，find() 方法返回第一个，之后每次调用 find() 都会返回下一个。start() 和 end() 返回每次匹配的字串在整个文本中的开始和结束位置。实际上, end() 返回的是字符串末尾的后一位，这样，可以在把 start() 和 end() 的返回值直接用在String.substring() 里。1234567891011String text =&quot;This is the text which is to be searched &quot; +&quot;for occurrences of the word &apos;is&apos;.&quot;;String patternString = &quot;is&quot;;Pattern pattern = Pattern.compile(patternString);Matcher matcher = pattern.matcher(text);int count = 0;while(matcher.find()) &#123;count++;System.out.println(&quot;found: &quot; + count + &quot; : &quot; + matcher.start() + &quot; - &quot; + matcher.end());&#125; 这个例子在文本中找到模式 “is” 4次，输出如下:1234found: 1 : 2 - 4found: 2 : 5 - 7found: 3 : 23 - 25found: 4 : 70 - 72 reset()reset() 方法会重置Matcher 内部的 匹配状态。当find() 方法开始匹配时,Matcher 内部会记录截至当前查找的距离。调用 reset() 会重新从文本开头查找。也可以调用 reset(CharSequence) 方法. 这个方法重置Matcher,同时把一个新的字符串作为参数传入，用于代替创建 Matcher 的原始字符串。 补充：如果在程序中多次使用同一个正则表达式，一定要用Pattern.compile()编译，代替直接使用Pattern.matches()。如果一次次对同一个正则表达式使用Pattern.matches()，例如在循环中，没有编译的正则表达式消耗比较大。因为matches()方法每次都会预编译使用的表达式。另外，记住你可以通过调用reset()方法对不同的输入字符串重复使用Matcher对象。 group()假设想在一个文本中查找URL链接，并且想把找到的链接提取出来。当然可以通过 start()和 end()方法完成。但是用group()方法更容易些。分组在正则表达式中用括号表示，例如:(John)此正则表达式匹配John, 括号不属于要匹配的文本。括号定义了一个分组。当正则表达式匹配到文本后，可以访问分组内的部分。使用group(int groupNo) 方法访问一个分组。一个正则表达式可以有多个分组。每个分组由一对括号标记。想要访问正则表达式中某分组匹配的文本，可以把分组编号传入 group(int groupNo)方法。group(0) 表示整个正则表达式，要获得一个有括号标记的分组，分组编号应该从1开始计算。12345678String text = &quot;John writes about this, and John writes about that,&quot; +&quot; and John writes about everything. &quot; ;String patternString1 = &quot;(John)&quot;;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);while(matcher.find()) &#123;System.out.println(&quot;found: &quot; + matcher.group(1));&#125; 1234以上代码在文本中搜索单词John.从每个匹配文本中，提取分组1，就是由括号标记的部分。输出：found: Johnfound: Johnfound: John 多分组上面提到，一个正则表达式可以有多个分组，例如：(John) (.+?)这个表达式匹配文本”John” 后跟一个空格,然后跟1个或多个字符，最后跟一个空格。你可能看不到最后的空格。这个表达式包括一些字符有特别意义。字符 点 . 表示任意字符。 字符 + 表示出现一个或多个，和. 在一起表示 任何字符,出现一次或多次。字符? 表示 匹配尽可能短的文本。完整代码如下：String text =“John writes about this, and John Doe writes about that,” +“ and John Wayne writes about everything.”;String patternString1 = “(John) (.+?) “;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);while(matcher.find()) {System.out.println(“found: “ + matcher.group(1) +“ “ + matcher.group(2));}1234注意代码中引用分组的方式。代码输出如下:found: John writesfound: John Doefound: John Wayne 嵌套分组在正则表达式中分组可以嵌套分组，例如:((John) (.+?))这是之前的例子，现在放在一个大分组里.(表达式末尾有一个空格)。当遇到嵌套分组时, 分组编号是由左括号的顺序确定的。上例中，分组1 是那个大分组。分组2 是包括John的分组，分组3 是包括 .+? 的分组。当需要通过groups(int groupNo) 引用分组时，了解这些非常重要。以下代码演示如何使用嵌套分组12345678910String text =&quot;John writes about this, and John Doe writes about that,&quot; +&quot; and John Wayne writes about everything.&quot;;String patternString1 = &quot;((John) (.+?)) &quot;;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);while(matcher.find()) &#123;System.out.println(&quot;found: &quot;);&#125; 1234输出如下found:found:found: replaceAll() + replaceFirst()replaceAll() 和 replaceFirst() 方法可以用于替换Matcher搜索字符串中的一部分。replaceAll() 方法替换全部匹配的正则表达式，replaceFirst() 只替换第一个匹配的。在处理之前，Matcher 会先重置。所以这里的匹配表达式从文本开头开始计算。示例如下1234567891011String text =&quot;John writes about this, and John Doe writes about that,&quot; +&quot; and John Wayne writes about everything.&quot;;String patternString1 = &quot;((John) (.+?)) &quot;;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);String replaceAll = matcher.replaceAll(&quot;Joe Blocks &quot;);System.out.println(&quot;replaceAll = &quot; + replaceAll);String replaceFirst = matcher.replaceFirst(&quot;Joe Blocks &quot;);System.out.println(&quot;replaceFirst = &quot; + replaceFirst); 输出如下1234replaceAll = Joe Blocks about this, and Joe Blocks writes about that,and Joe Blocks writes about everything.replaceFirst = Joe Blocks about this, and John Doe writes about that,and John Wayne writes about everything. appendReplacement() + appendTail()appendReplacement() 和 appendTail() 方法用于替换输入文本中的字符串短语，同时把替换后的字符串附加到一个 StringBuffer 中。当find() 方法找到一个匹配项时，可以调用 appendReplacement() 方法，这会导致输入字符串被增加到StringBuffer 中，而且匹配文本被替换。 从上一个匹配文本结尾处开始，直到本次匹配文本会被拷贝。appendReplacement() 会记录拷贝StringBuffer 中的内容，可以持续调用find(),直到没有匹配项。直到最后一个匹配项目，输入文本中剩余一部分没有拷贝到 StringBuffer. 这部分文本是从最后一个匹配项结尾，到文本末尾部分。通过调用 appendTail() 方法，可以把这部分内容拷贝到 StringBuffer 中.1234567891011121314String text =&quot;John writes about this, and John Doe writes about that,&quot; +&quot; and John Wayne writes about everything.&quot;;String patternString1 = &quot;((John) (.+?)) &quot;;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);StringBuffer stringBuffer = new StringBuffer();while(matcher.find())&#123;matcher.appendReplacement(stringBuffer, &quot;Joe Blocks &quot;);System.out.println(stringBuffer.toString());&#125;matcher.appendTail(stringBuffer);System.out.println(stringBuffer.toString()); 注意我们在while循环中调用appendReplacement() 方法。在循环完毕后调用appendTail()。代码输出如下:12345Joe BlocksJoe Blocks about this, and Joe BlocksJoe Blocks about this, and Joe Blocks writes about that, and Joe BlocksJoe Blocks about this, and Joe Blocks writes about that, and Joe Blockswrites about everything. Java 正则表达式语法为了更有效的使用正则表达式，需要了解正则表达式语法。正则表达式语法很复杂，可以写出非常高级的表达式。只有通过大量的练习才能掌握这些语法规则。 基本语法在介绍高级功能前，我们先快速浏览下正则表达式的基本语法。 字符是正则表达式中最经常使用的的一个表达式，作用是简单的匹配一个确定的字符。例如：John这个简单的表达式将会在一个输入文本中匹配John文本。可以在表达式中使用任意英文字符。也可以使用字符对于的8进制，16进制或unicode编码表示。例如：101\x41\u0041以上3个表达式 都表示大写字符A。第一个是8进制编码(101),第2个是16进制编码(41),第3个是unicode编码(0041). 字符分类字符分类是一种结构，可以针对多个字符匹配而不只是一个字符。换句话说，一个字符分类匹配输入文本中的一个字符，对应字符分类中多个允许字符。例如，你想匹配字符 a,b 或c，表达式如下：[abc]用一对方括号[] 表示字符分类。方括号本身并不是要匹配的一部分。可以用字符分类完成很多事。例如想要匹配单词John，首字母可以为大写和小写J.[Jj]ohn字符分类[Jj] 匹配J或j，剩余的 ohn 会准确匹配字符ohn. 预定义字符分类正则表达式中有一些预定义的字符分类可以使用。例如, \d 表示任意数字, \s 表示任意空白字符,\w 表示任意单词字符。预定义字符分类不需要括在方括号里，当然也可以组合使用\d[\d\s]第1个匹配任意数字，第2个匹配任意数字或空白符。完整的预定义字符分类列表，在本文最后列出。 边界匹配正则表达式支持匹配边界，例如单词边界，文本的开头或末尾。例如，\w 匹配一个单词，^匹配行首,$ 匹配行尾。^This is a single line$上面的表达式匹配一行文本，只有文本 This is a single line。注意其中的行首和行尾标志，表示不能有任何文本在文本的前面后后面，只能是行首和行尾。完整的匹配边界列表，在本文最后列出。 量词匹配量词可以匹配一个表达式多次出现。例如下列表达式匹配字母A 出现0次或多次。A*量词 * 表示0次或多次。+ 表示1次或多次。? 表示0次或1次。还有些其他量词，参见本文后面的列表。量词匹配分为：饥饿模式,贪婪模式,独占模式。饥饿模式 匹配尽可能少的文本。贪婪模式匹配尽可能多的文本。独占模式匹配尽可能多的文本，甚至导致剩余表达式匹配失败。以下演示饥饿模式,贪婪模式,独占模式区别。假设以下文本：John went for a walk, and John fell down, and John hurt his knee.饥饿模式下 表达式：John.*?这个表达式匹配John 后跟0个或多个字符。 . 表示任意字符。* 表示0或多次。? 跟在 * 后面，表示 * 采用饥饿模式。饥饿模式下，量词只会匹配尽可能少的字符，即0个字符。上例中的表达式将会匹配单词John,在输入文本中出现3次。如果改为贪婪模式，表达式如下：John.*贪婪模式下，量词会匹配尽可能多的字符。现在表达式会匹配第一个出现的John，以及在贪婪模式下 匹配剩余的所有字符。这样，只有一个匹配项。最后，我们改为独占模式：John.*+hurt*后跟+ 表示独占模式量词。这个表达式在输入文本中没有匹配项，尽管文本中包括 John 和 hurt. 为什么会这样? 因为 .*+ 是独占模式。与贪婪模式下，尽可能多的匹配文本，以使整个表达式匹配不同。独占模式会尽可能的多的匹配，但不考虑表达式剩余部分是否能匹配上。.*+ 将会匹配第一个John之后的所有字符，这会导致表达式中剩余的 hurt 没有匹配项。如果改为贪婪模式，会有一个匹配项。表达式如下：John.*hurt 逻辑操作符正则表达式支持少量的逻辑运算(与，或，非)。与操作是默认的，表达式 John ,意味着J 与 o与h与n。或操作需要显示指定，用 | 表示。例如表达式 John|hurt 意味着John 或 hurt 。 ?!特殊操作 ?!帮我们解决了字符串“不包含”匹配的问题，例如表达式 ^(?!.went).$ 意味着匹配的字符串中不能包含“went”字符串。 字符 Type Description . 除换行以外的任意字符 \\ 反斜杠, 单独的反斜杠做为转义字符,与其他特殊字符一起使用。如果想匹配反斜杠本身,需要转义。两个反斜杠实际匹配一个反斜杠。 nn 字符的8进制表示.n 在0至7之间取值 mnn 字符的8进制表示. m 在0至3之间取值, n 在0至7之间取值 \xhh 字符的16进制表示. \uhhhh 字符的16进制表示 0xhhhh. 对应unicode 编码字符 \t 缩进符. \n 换行符 (unicode: ‘\u000A’) \r 回车符 (unicode: ‘\u000D’) \f 制表符 (unicode: ‘\u000C’) \a 警报（铃声）字符 (unicode: ‘\u0007’) \e 转义符 (unicode: ‘\u001B’) \cx 控制符 x 字符分类 Type Description [abc] 匹配 a, 或 b 或 c [^abc] 匹配不是a,b,c 的字符，是否定匹配 [a-zA-Z] 匹配a 到 z ，A到Z 直接的字符，是范围匹配 [a-d[m-p]] 匹配a到d之间字符或 m到p之间字符，是并集匹配 [a-z&amp;&amp;[def]] 匹配 d, e, 或 f. 是交集匹配 (这里是在范围 a-z和字符def之间取交集). [a-z&amp;&amp;[^bc]] 匹配a-z 之间所有字符，排除bc的字符。是减法匹配 [a-z&amp;&amp;[^m-p]] 匹配a-z 之间所有字符,排除m-p之间的字符是减法匹配 内置字符分类 Type Description . 匹配任意一个字符,根据创建Pattern是传入的标志,可能匹配行结尾符 \d 匹配任意数字 [0-9] \D 匹配任意非数字 [^0-9] \s 匹配任意空白符 (空格, 缩进, 换行,回车) \S 匹配任意非空白符 \w 匹配任意单词 \W 匹配任意非单词 边界匹配 Type Description ^ 匹配行首 $ 匹配行尾 \b 匹配单词边界 \B 匹配非单词边界 \A 匹配文本开头 \G 匹配前一匹配项结尾【不知其用法和用意。】 \Z 输入的结束，但是对于最终终止符，如果有的话 \z 输入的结束 量词 贪婪模式 饥饿模式 独占模式 X? X?? X?+ 匹配0或1次 X* X*? X*+ 匹配0或多次 X+ X+? X++ 匹配1或多次 X{n} X{n}? X{n}+ 匹配n次 X{n,} X{n,}? X{n,}+ 匹配最少n次 X{n, m} X{n, m}? X{n, m}+ 匹配最少n次，最多m次 参考资料1.Java正则表达式2.Java 正则表达式 StackOverflowError 问题及其优化]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AutoCache高性能缓存框架使用教程]]></title>
    <url>%2F2016%2F10%2F23%2FAutoCache%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[读者可能会问在下： 为什么要使用AutoCache？简洁、高性能。 现在市面上有那么多缓存的框架，像piccso等都很优秀，那笔者是不是在重复造车？AutoCache是为那些追求轻量级缓存的APP而生的。目的是让开发者既能快速完成APP缓存功能的开发，又能保证上线后性能的稳定。 AutoCache 能够让你高效地编写app缓存代码 ，保证你的数据流被安全、准确地存储到SDcard私有目录。参考下列核心调用代码来开始你的 AutoCache 之旅：1234567891011121314151617181920212223AutoCache.MediaCache.getInstance(context).asyncCache(&quot;url&quot;, new CallBack() &#123;@Overridepublic void onStart() &#123;//Run in UI thread.&#125;@Overridepublic void save2DataBase(String cachePath) &#123;//Run in io thread,//You can sava the cachPath to database or sharepreference.&#125;@Overridepublic void onSuccess(byte[] bytes) &#123;//Run in UI thread.&#125;@Overridepublic void onErro(Throwable e) &#123;//Run in UI thread.&#125;&#125;, FILE_TYPE, &quot;filename&quot;); #集成方法在Module的build.gradle文件中添加如下依赖即可。1compile &apos;com.txm.topcodes.autocache:autocache:0.1.2&apos; #调用方式为方便开发者，AutoCache提供统一调用入口，调用方式十分简洁。下面先给大家看一张思维导图，该图罗列了框架的主体功能及其构成。 从结构图不难看出，AutoCache类就是调用框架的入口类。当我们需要从本地获取流文件时，调用方式是这样的1AutoCache.Media.get…(); 缓存网络文件时，调用方式是这样的1AutoCache.MediaCache.getInstance(context).asyncCache(); 缓存内存文件时，调用方式是这样的1AutoCache.MediaCache.getInstance(context).cache(); 当需要指定文件文件类型时，使用方式是这样的1AutoCache.DIRECTORY_PICTURES 「如需获取详细信息，请在 GitHub 的 auto-cache页面查看源代码.」 #文件类型AutoCache支持缓存以下泛媒体类型：Podcasts,Pictures,Movies,Music,Documents,Download。其中Download比较特殊，用它可以指定未知的文件类型。 #使用场景当我们的APP从网络获取文件流时，往往会有这样的需求「也可能是其中之一」： 网络请求时，要可以自动将文件保存到APP本地。 网络请求时，将网络图片的本地路径存储到SQLite或其它数据持久化中，以方便逻辑处理。 网络请求时，直接使用从网络获取到文件流。 网络请求时，方便添加进度条功能。 网络请求时，全局捕获异常。 本次请求之后，根据文件名、文件类型从本地获取文件流。 对于需求1。AutoCache完全是在后台IO线程中完成的，不需要调用者主动去操作。 IO线程：I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io线程比Thread线程更有效率。 对于需求2。save2DataBase(String cachePath)回调方法自动就被指定在IO线程中运行。「所以，save2DataBase既是一个非阻塞的方法，又具备IO线程的高效性。」 对于需求3。onSuccess(byte[] bytes)回调方法被指定自动运行在UI线程中。 对于需求4。AutoCache提供了onstart()回调方法作为调用开始的标志，onSuccess(byte[] bytes)或onErro(Throwable e)作为调用结束点。 对于需求5。全局捕获异常指的是：onErro(Throwable e)不仅可以捕获网络异常、本地缓存媒体时发生的异常，而且还可以捕获发生在onStart、save2DataBase、onSuccess中的异常。 对于需求6。AutoCache.Media类提供了4种同步方式来获取本地的媒体流。 #最佳实践 ####防止OOMAutoCache.Media类中提供了getSoftBmp(~)，getWeakBmp(~)，getBmp(~)，getFile(~)四种方式来获取流。如果是图片文件，笔者建议使用前两种方式，具体可参考善于利用软引用和弱引用。 ####定制回调方法AutoCache框架提供了CallBackAdapter接口用于替换CallBack接口。可以通过它实现自由定制自己需要的回调方法。「这样是为了代码看上去简洁。」1234567891011AutoCache.MediaCache.getInstance(context).asyncCache(&quot;url&quot;, new CallBackAdapter() &#123;@Overridepublic void save2DataBase(String cachePath) &#123;&#125;@Overridepublic void onSuccess(byte[] bytes) &#123;&#125;//you can add other callback function here.&#125;,FILE_TYPE,&quot;filename&quot;); #FAQ 我发现AutoCache还存在BUG？AutoCache是一个完全开源的框架，如果您在使用过程中发现问题，请在GitHub创建一个问题。 我是Eclipse用户，可以使用AutoCache么？不可以。 AutoCache用到了哪些第三方框架？是的。AutoCache是在RXjava+Okhttp基础之上封装的一个轻量级缓存框架。 AutoCache提供缓存文件路径到SQLite数据库的方法了吗？没有。AutoCache缓存的重心是将流文件缓存到本地目录。如果需要将文件路径缓存到SQLite或其他持久化数据层中，开发者需要自行在save2DataBase(cachePath)回调方法中实现逻辑。 我在android studio中链接AutoCache库失败了？确保您的工程使用的远程仓库为jcenter。12345allprojects &#123;repositories &#123;jcenter()&#125;&#125; ————–我是一条萌萌哒的分割线，表示教程结束—————-]]></content>
      <categories>
        <category>我的Android框架</category>
      </categories>
      <tags>
        <tag>Cache</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio NDK开发全攻略]]></title>
    <url>%2F2016%2F08%2F14%2FNDK%E5%BC%80%E5%8F%91%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[读完本章，你可以： 在Android Studio上轻松搭建NDK开发环境。 掌握最快捷的JNI开发方式。 掌握使用.so文件开发Android程序的技巧。 一、 NDK环境搭建 开发工具准备要进行Android NDK开发，首先要下载Android NDK开发工具。可以在AndroidStudio上面下载，也可以自己下载好了，然后将NDK的路径设置为自己下载的Android NDK开发工具的路径。 Gradle的相关配置1) 我们来配置Project的build.gradle。1234/*gradle插件不支持NDK，我们需要使用gradle-experimental插件。 */dependencies &#123;classpath &apos;com.android.tools.build:gradle-experimental:0.7.0&apos;&#125; 2) 我们来配置Module的build.gradle。12345678910111213141516171819202122232425262728293031323334apply plugin: &apos;com.android.model.application&apos;model &#123;android &#123;compileSdkVersion = 23buildToolsVersion = &quot;23.0.2&quot;defaultConfig &#123;applicationId &quot;com.lavor.ndklearning&quot;minSdkVersion.apiLevel 15targetSdkVersion.apiLevel 23versionCode 4versionName &quot;1.0.1&quot;&#125;&#125;android.ndk &#123;moduleName &quot;lavor&quot;ldLibs.addAll([&apos;log&apos;])cppFlags.add(&quot;-std=c++11&quot;)cppFlags.add(&quot;-fexceptions&quot;)platformVersion 15stl &apos;gnustl_shared&apos;&#125;android.buildTypes &#123;release &#123;minifyEnabled = falseproguardFiles.add(file(&quot;proguard-rules.txt&quot;))&#125;&#125;&#125;dependencies &#123;compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])compile &apos;com.android.support:appcompat-v7:23.1.1&apos;compile &apos;com.android.support:recyclerview-v7:23.1.1&apos;compile &apos;com.android.support:design:23.1.1&apos;&#125; 小提示 首先，在apply的时候我们引入的插件名称由’com.android.application’变成了’com.android.model.application’。 其次，在原来android的外层加入了一个model层次。 再次，原来在android的里面的块，除了defaultConfig外，全部移除android块放入model块中与android并列，并且前面的名字加上android.。 然后，compileSdkVersion 23与 buildToolsVersion “23.0.2”改成 compileSdkVersion = 23和 buildToolsVersion = “23.0.2”，中间加上了=。 其次，添加上android.ndk块，块中的moduleName表示C/C++代码打包成so文件的名字。 再次，android.buildTypes块中的proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’改成proguardFiles.add(file(“proguard-rules.txt”))。 最后，注意dependencies块依然在最外层，它不在model块中。 二、 使用NDK开发第一个JNI程序 在Android程序中新建一个包含native（本地）方法的NDKTest类。12345678package com.lavor.ndklearning;public class NDKTest &#123;static &#123;//加载.so库文件System.loadLibrary(&quot;lavor&quot;);&#125;public native String getString();&#125; 小知识 程序中static{}称为静态代码块，它在类初始化的时候执行。不懂请猛击&gt;&gt; 将鼠标移动到方法名getString上，然后按下Alt+Enter快捷键，弹出一些解决的方法建议，点击第一个Create Function… 此时会自动建立一个与java目录同级的jni目录，在jni目录自动建立一个c文件，在c文件中实现了刚才的native方法。 然后，稍稍修改一下.c文件中实现的native方法。12345JNIEXPORT jstring JNICALLJava_com_lavor_ndklearning_NDKTest_getString(JNIEnv *env, jobject instance) &#123;// TODOreturn (*env)-&gt;NewStringUTF(env, &quot;AndroidStudio NDK开发最佳入门实践&quot;);&#125; 补充说明 仔细观察可以看到c文件的方法名是遵循“Java_包名类名本地方法名”来组织的（了解到这些后，我们就可以脱离编译器的帮助，直接去写.c文件啦）。 最后在Android程序中调用JNI接口。1234567891011public class MainActivity extends Activity &#123;private android.widget.TextView text;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);this.text = (TextView) findViewById(R.id.text);NDKTest NDK=new NDKTest();text.setText(NDK.getString());&#125;&#125; 运行程序后界面如下： 深度总结 讲道理，我们在正式开发时，不会像这样子去开发。因为这样的话就会把我们的c代码也暴露了出来。这明显与JNI的安全保密机制相违背，所以，正式开发的时候，我们会使用.so文件进行全保密式的开发。 三、 使用.so文件开发Android程序不知道大家有没有记得上一章说过，使用JNI有个好处就是安全性高，JNI部分的代码很难被反编译。这其实是要归功于.so文件。下图为.so文件的生成位置。具体的使用步骤是怎样的呢？ 新建一个Android工程，命名为：AndroidApplication。（工程名、包名、组织名任意） 导入.so文件至app/libs中。 为了能够调用libs文件夹下的.so资源，需在app的build.gradle的android节点下设置。 12345sourceSets&#123;main&#123;jniLibs.srcDirs = [&apos;libs&apos;]&#125;&#125; 新建相关类结构。 12345678package com.lavor.ndklearning;public class NDKTest &#123;static &#123;//加载.so库文件System.loadLibrary(&quot;lavor&quot;);&#125;public native String getString();&#125; 补充说明 Android端声明native code的代码需要严格按照JNI接口来组织。（也就是说，包名、类名都要和.so文件中JNI名称一致）不懂就点击这里吧&gt;&gt; 函数调用。12345678public class DemoActivity extends AppCompatActivity &#123;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_demo);Log.d(&quot;NDK&quot;,new NDKTest().getString());&#125;&#125; 运行结果如下： 注意啦！此文并非原创，算是对一波优秀文章的总结吧。笔者希望通过这种方式激励自己学习，也期待可以帮到正在学习NDK的你。欢迎指出本文的BUG，共勉！！！！！ 参考资料 AndroidStudio NDK开发最佳入门实践 如何在Android中使用编译好的.so库]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七夕前，我认识了NDK]]></title>
    <url>%2F2016%2F08%2F06%2F%E4%B8%83%E5%A4%95%E5%89%8D%EF%BC%8C%E6%88%91%E8%AE%A4%E8%AF%86%E4%BA%86NDK%2F</url>
    <content type="text"><![CDATA[看前必读 读完本章，你可以掌握NDK、JNI的概念及其开发流程。 阅读时，不必纠结于读不懂的代码结构，后面的教程 都会讲到的。 一、为何要学习NDK？ 代码的保护。Android APK的Java层代码很容易被反编译，但C/C++库反编译难度较大。 可以方便地使用现存的开源库。大部分现存的开源库都是用C/C++代码编写的。 提高程序的执行效率。将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。 便于移植。用C/C++写的库可以方便在其他的嵌入式平台上再次使用。 二、先知道什么是JNIJNI（Java Native Interface）是Java语言提供的Java和C/C++互相沟通的机制，可以实现： java调用本地的C/C++代码 本地的C/C++代码也可以调用java代码 三、开发JNI程序的简化流程 编写Java Code，如下例子： 12345678910111213/*** 加载lavor本地共享库到内存中*/static &#123;System.loadLibrary(&quot;lavor&quot;);&#125;/*** 定义本地方法对应的Java方法** @return*/public native String getString(); 编写C/C++，如下例子： 123456#include &lt;jni.h&gt;JNIEXPORT jstring JNICALLJava_com_lavor_ndklearning_MainActivity_getString(JNIEnv *env, jobject instance) &#123;return (*env)-&gt;NewStringUTF(env, &quot;这是我的c程序代码&quot;);&#125; 编译 C/C++ Code，成功并得到本地共享库。 小知识 本地共享库是Linux下的叫法，文件扩展名是.so，windows下叫动态链接库，文件扩展名是.dll。 C /C++的跨平台性是以牺牲编译时间以及编译难度为代价的。（这里的编译难度是指为适应不同平台而做的编译过程的调整） Java的一次编译到处运行，是以牺牲运行效率为代价的。 编译并打包Java。把本地共享库（.so文件）放置到Java项目的指定目录，一般是libs文件夹。然后编译Java代码即可打包运行。 小知识 Android项目中，.so文件存放地址为libs/armeabi。(armeabi是对应的平台，下一章将会详细介绍) 四、NDK概述NDK(Native Development Kit)是Google为Android进行本地开发而放出的一个本地开发工具， 包括Android的Native API、公共库以及编译工具。其实说白就是Google为方便Android程序猿开发JNI程序，而提供的便捷工具。 补充两点 NDK处在JNI开发流程中的编译环节（第三、四步）。针对不同的平台，NDK可以全自动编译出对应可运行的本地共享库，并可将对应的.so文件和应用程序一起打包成apk发布。（这时，跨平台编译C/C++的难度指数降为0。不明白请猛击） NDK需要Android 1.5版本以上的支持。 五、开发NDK程序的流程这个开发流程大致与JNI的开发流程差不多： SDK开发。编写Java代码，调用各种Android的API实现功能，编写含有native关键字的代码开始JNI。 JNI开发。按照 JNI编码规范，编写与Java交互的本地代码（一般就是数据类型的转换，把 C/C++的数据类转换成Java能识别的，或反过来）。 C/C++开发。编码实现业务逻辑，或调用NDK提供的本地API或库，完成Android平台上特定功能的开发、封装。 NDK编译，编写.mk文件，编译调试，最后修改.mk文件，针对特定的平台（ARM/x86）做编译结果的优化。 最后就是SDK编译、打包，上真机调试了… 注意啦！此文并非原创，算是对一波优秀文章的总结吧。笔者希望通过这种方式激励自己学习，也期待可以帮到正在学习NDK的你。欢迎指出本文的BUG，共勉！！！！！ 参考资料Android之NDK开发]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
