<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F01%2F16%2FJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[为什么要使用正则表达式？节省代码，爱护队友。 在正式介绍之前，先贴一段使用了正则表达式的代码吧。12345String phoneNum = &quot;16510758936&quot;;String patternString = &quot;\\d&#123;11&#125;&quot;;Pattern pattern = Pattern.compile(patternString);Matcher matcher = pattern.matcher(phoneNum);System.out.println(&quot;matches = &quot;+matcher.matches()); 仅这段代码就可以简单判断字符串（代码中的“phoneNum”字符串）是否为手机号格式。是不是很高效呢？事实上正则表达式还可以做很多很酷的事情，所以我们很有必要认真的学一下它。本文将从API、语法两个维度介绍该主题。 #API使用类 java.util.regex.Pattern 简称 Pattern, 是Java正则表达式API中的主要入口，无论何时,需要使用正则表达式,从Pattern 类开始 ###Pattern.matches()这是检测正则表达式的模式是否匹配一段文本的最直接方法，eg：123456String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the pattern.&quot;;String pattern = &quot;.*is.*&quot;;boolean matches = Pattern.matches(pattern, text);System.out.println(&quot;matches = &quot; + matches); “.”表示任意字符，“*”表示0或者多个，“.*”组合表示0或者多个任意字符。显然， “.*is.*“代表一个字符串中包含“is”字段，上面代码返回结果是true。Pattern.matches() 方法适用于检查 一个模式在一个文本中出现一次的情况，或适用于Pattern类的默认设置。如果需要匹配多次出现,甚至输出不同的匹配文本，或者只是需要非默认设置。需要通过Pattern.compile() 方法得到一个Pattern 实例。 ###Pattern.compile()如果需要匹配一个正则表达式在文本中多次出现，需要通过Pattern.compile() 方法创建一个Pattern对象。示例如下。12345String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the http:// pattern.&quot;;String patternString = &quot;.*http://.*&quot;;Pattern pattern = Pattern.compile(patternString); 可以在Compile 方法中，指定一个特殊标志：Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);Pattern 类包含多个标志(int 类型),这些标志可以控制Pattern 匹配模式的方式。上面代码中的标志使模式匹配是忽略大小写 ###pattern.matcher()一旦获得了Pattern对象，接着可以获得Matcher对象。Matcher 示例用于匹配文本中的模式.示例如下Matcher matcher = pattern.matcher(text);Matcher类有一个matches()方法，可以检查文本是否匹配模式。以下是关于Matcher的一个完整例子12345678String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the http:// pattern.&quot;;String patternString = &quot;.*http://.*&quot;;Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);Matcher matcher = pattern.matcher(text);boolean matches = matcher.matches();System.out.println(&quot;matches = &quot; + matches); ###pattern.split()Pattern 类的 split()方法，可以用正则表达式作为分隔符，把文本分割为String类型的数组。示例：12345678String text = &quot;A sep Text sep With sep Many sep Separators&quot;;String patternString = &quot;sep&quot;;Pattern pattern = Pattern.compile(patternString);String[] split = pattern.split(text);System.out.println(&quot;split.length = &quot; + split.length);for(String element : split)&#123;System.out.println(&quot;element = &quot; + element);&#125; 上例中把text 文本分割为一个包含5个字符串的数组。 ###pattern.pattern()Pattern 类的 pattern 返回用于创建Pattern 对象的正则表达式。 ###Matcher (java.util.regex.Matcher)java.util.regex.Matcher 类用于匹配一段文本中多次出现一个正则表达式，Matcher 也适用于多文本中匹配同一个正则表达式。创建Matcher通过Pattern 的matcher() 方法创建一个Matcher。123456String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the http:// pattern.&quot;;String patternString = &quot;.*http://.*&quot;;Pattern pattern = Pattern.compile(patternString);Matcher matcher = pattern.matcher(text); matches()Matcher 类的 matches() 方法用于在文本中匹配正则表达式1boolean matches = matcher.matches(); 如果文本匹配正则表达式，matches() 方法返回true。否则返回false。matches() 方法不能用于查找正则表达式多次出现。如果需要，要使用find(), start() 和 end() 方法。lookingAt()lookingAt() 与matches() 方法类似，最大的不同是，lookingAt()方法对文本的开头匹配正则表达式；而matches() 对整个文本匹配正则表达式。换句话说，如果正则表达式匹配文本开头而不匹配整个文本,lookingAt() 返回true,而matches() 返回false。 示例：12345678String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the http:// pattern.&quot;;String patternString = &quot;This is the&quot;;Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);Matcher matcher = pattern.matcher(text);System.out.println(&quot;lookingAt = &quot; + matcher.lookingAt());System.out.println(&quot;matches = &quot; + matcher.matches()); 上面的例子分别对文本开头和整个文本匹配正则表达式 “this is the”, 匹配文本开头的方法(lookingAt()) 返回true。对整个文本匹配正则表达式的方法 (matches()) 返回false，因为整个文本包含多余的字符,而正则表达式要求文本精确匹配”this is the”,前后又不能有额外字符。find() + start() + end()find() 方法用于在文本中查找出现的正则表达式，文本是创建Matcher时，通过 Pattern.matcher(text) 方法传入的。如果在文本中多次匹配，find() 方法返回第一个，之后每次调用 find() 都会返回下一个。start() 和 end() 返回每次匹配的字串在整个文本中的开始和结束位置。实际上, end() 返回的是字符串末尾的后一位，这样，可以在把 start() 和 end() 的返回值直接用在String.substring() 里。1234567891011String text =&quot;This is the text which is to be searched &quot; +&quot;for occurrences of the word &apos;is&apos;.&quot;;String patternString = &quot;is&quot;;Pattern pattern = Pattern.compile(patternString);Matcher matcher = pattern.matcher(text);int count = 0;while(matcher.find()) &#123;count++;System.out.println(&quot;found: &quot; + count + &quot; : &quot; + matcher.start() + &quot; - &quot; + matcher.end());&#125; 这个例子在文本中找到模式 “is” 4次，输出如下:1234found: 1 : 2 - 4found: 2 : 5 - 7found: 3 : 23 - 25found: 4 : 70 - 72 reset()reset() 方法会重置Matcher 内部的 匹配状态。当find() 方法开始匹配时,Matcher 内部会记录截至当前查找的距离。调用 reset() 会重新从文本开头查找。也可以调用 reset(CharSequence) 方法. 这个方法重置Matcher,同时把一个新的字符串作为参数传入，用于代替创建 Matcher 的原始字符串。 补充：如果在程序中多次使用同一个正则表达式，一定要用Pattern.compile()编译，代替直接使用Pattern.matches()。如果一次次对同一个正则表达式使用Pattern.matches()，例如在循环中，没有编译的正则表达式消耗比较大。因为matches()方法每次都会预编译使用的表达式。另外，记住你可以通过调用reset()方法对不同的输入字符串重复使用Matcher对象。 group()假设想在一个文本中查找URL链接，并且想把找到的链接提取出来。当然可以通过 start()和 end()方法完成。但是用group()方法更容易些。分组在正则表达式中用括号表示，例如:(John)此正则表达式匹配John, 括号不属于要匹配的文本。括号定义了一个分组。当正则表达式匹配到文本后，可以访问分组内的部分。使用group(int groupNo) 方法访问一个分组。一个正则表达式可以有多个分组。每个分组由一对括号标记。想要访问正则表达式中某分组匹配的文本，可以把分组编号传入 group(int groupNo)方法。group(0) 表示整个正则表达式，要获得一个有括号标记的分组，分组编号应该从1开始计算。12345678String text = &quot;John writes about this, and John writes about that,&quot; +&quot; and John writes about everything. &quot; ;String patternString1 = &quot;(John)&quot;;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);while(matcher.find()) &#123;System.out.println(&quot;found: &quot; + matcher.group(1));&#125; 1234以上代码在文本中搜索单词John.从每个匹配文本中，提取分组1，就是由括号标记的部分。输出：found: Johnfound: Johnfound: John 多分组上面提到，一个正则表达式可以有多个分组，例如：(John) (.+?)这个表达式匹配文本”John” 后跟一个空格,然后跟1个或多个字符，最后跟一个空格。你可能看不到最后的空格。这个表达式包括一些字符有特别意义。字符 点 . 表示任意字符。 字符 + 表示出现一个或多个，和. 在一起表示 任何字符,出现一次或多次。字符? 表示 匹配尽可能短的文本。完整代码如下：String text =“John writes about this, and John Doe writes about that,” +“ and John Wayne writes about everything.”;String patternString1 = “(John) (.+?) “;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);while(matcher.find()) {System.out.println(“found: “ + matcher.group(1) +“ “ + matcher.group(2));}1234注意代码中引用分组的方式。代码输出如下:found: John writesfound: John Doefound: John Wayne 嵌套分组在正则表达式中分组可以嵌套分组，例如:((John) (.+?))这是之前的例子，现在放在一个大分组里.(表达式末尾有一个空格)。当遇到嵌套分组时, 分组编号是由左括号的顺序确定的。上例中，分组1 是那个大分组。分组2 是包括John的分组，分组3 是包括 .+? 的分组。当需要通过groups(int groupNo) 引用分组时，了解这些非常重要。以下代码演示如何使用嵌套分组12345678910String text =&quot;John writes about this, and John Doe writes about that,&quot; +&quot; and John Wayne writes about everything.&quot;;String patternString1 = &quot;((John) (.+?)) &quot;;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);while(matcher.find()) &#123;System.out.println(&quot;found: &quot;);&#125; 1234输出如下found:found:found: replaceAll() + replaceFirst()replaceAll() 和 replaceFirst() 方法可以用于替换Matcher搜索字符串中的一部分。replaceAll() 方法替换全部匹配的正则表达式，replaceFirst() 只替换第一个匹配的。在处理之前，Matcher 会先重置。所以这里的匹配表达式从文本开头开始计算。示例如下1234567891011String text =&quot;John writes about this, and John Doe writes about that,&quot; +&quot; and John Wayne writes about everything.&quot;;String patternString1 = &quot;((John) (.+?)) &quot;;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);String replaceAll = matcher.replaceAll(&quot;Joe Blocks &quot;);System.out.println(&quot;replaceAll = &quot; + replaceAll);String replaceFirst = matcher.replaceFirst(&quot;Joe Blocks &quot;);System.out.println(&quot;replaceFirst = &quot; + replaceFirst); 输出如下1234replaceAll = Joe Blocks about this, and Joe Blocks writes about that,and Joe Blocks writes about everything.replaceFirst = Joe Blocks about this, and John Doe writes about that,and John Wayne writes about everything. appendReplacement() + appendTail()appendReplacement() 和 appendTail() 方法用于替换输入文本中的字符串短语，同时把替换后的字符串附加到一个 StringBuffer 中。当find() 方法找到一个匹配项时，可以调用 appendReplacement() 方法，这会导致输入字符串被增加到StringBuffer 中，而且匹配文本被替换。 从上一个匹配文本结尾处开始，直到本次匹配文本会被拷贝。appendReplacement() 会记录拷贝StringBuffer 中的内容，可以持续调用find(),直到没有匹配项。直到最后一个匹配项目，输入文本中剩余一部分没有拷贝到 StringBuffer. 这部分文本是从最后一个匹配项结尾，到文本末尾部分。通过调用 appendTail() 方法，可以把这部分内容拷贝到 StringBuffer 中.1234567891011121314String text =&quot;John writes about this, and John Doe writes about that,&quot; +&quot; and John Wayne writes about everything.&quot;;String patternString1 = &quot;((John) (.+?)) &quot;;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);StringBuffer stringBuffer = new StringBuffer();while(matcher.find())&#123;matcher.appendReplacement(stringBuffer, &quot;Joe Blocks &quot;);System.out.println(stringBuffer.toString());&#125;matcher.appendTail(stringBuffer);System.out.println(stringBuffer.toString()); 注意我们在while循环中调用appendReplacement() 方法。在循环完毕后调用appendTail()。代码输出如下:12345Joe BlocksJoe Blocks about this, and Joe BlocksJoe Blocks about this, and Joe Blocks writes about that, and Joe BlocksJoe Blocks about this, and Joe Blocks writes about that, and Joe Blockswrites about everything. #Java 正则表达式语法为了更有效的使用正则表达式，需要了解正则表达式语法。正则表达式语法很复杂，可以写出非常高级的表达式。只有通过大量的练习才能掌握这些语法规则。 ###基本语法在介绍高级功能前，我们先快速浏览下正则表达式的基本语法。字符是正则表达式中最经常使用的的一个表达式，作用是简单的匹配一个确定的字符。例如：John这个简单的表达式将会在一个输入文本中匹配John文本。可以在表达式中使用任意英文字符。也可以使用字符对于的8进制，16进制或unicode编码表示。例如：101\x41\u0041以上3个表达式 都表示大写字符A。第一个是8进制编码(101),第2个是16进制编码(41),第3个是unicode编码(0041).字符分类字符分类是一种结构，可以针对多个字符匹配而不只是一个字符。换句话说，一个字符分类匹配输入文本中的一个字符，对应字符分类中多个允许字符。例如，你想匹配字符 a,b 或c，表达式如下：[abc]用一对方括号[] 表示字符分类。方括号本身并不是要匹配的一部分。可以用字符分类完成很多事。例如想要匹配单词John，首字母可以为大写和小写J.[Jj]ohn字符分类[Jj] 匹配J或j，剩余的 ohn 会准确匹配字符ohn.预定义字符分类正则表达式中有一些预定义的字符分类可以使用。例如, \d 表示任意数字, \s 表示任意空白字符,\w 表示任意单词字符。预定义字符分类不需要括在方括号里，当然也可以组合使用\d[\d\s]第1个匹配任意数字，第2个匹配任意数字或空白符。完整的预定义字符分类列表，在本文最后列出。边界匹配正则表达式支持匹配边界，例如单词边界，文本的开头或末尾。例如，\w 匹配一个单词，^匹配行首,$ 匹配行尾。^This is a single line$上面的表达式匹配一行文本，只有文本 This is a single line。注意其中的行首和行尾标志，表示不能有任何文本在文本的前面后后面，只能是行首和行尾。完整的匹配边界列表，在本文最后列出。量词匹配量词可以匹配一个表达式多次出现。例如下列表达式匹配字母A 出现0次或多次。A*量词 * 表示0次或多次。+ 表示1次或多次。? 表示0次或1次。还有些其他量词，参见本文后面的列表。量词匹配分为：饥饿模式,贪婪模式,独占模式。饥饿模式 匹配尽可能少的文本。贪婪模式匹配尽可能多的文本。独占模式匹配尽可能多的文本，甚至导致剩余表达式匹配失败。以下演示饥饿模式,贪婪模式,独占模式区别。假设以下文本：John went for a walk, and John fell down, and John hurt his knee.饥饿模式下 表达式：John.*?这个表达式匹配John 后跟0个或多个字符。 . 表示任意字符。* 表示0或多次。? 跟在 * 后面，表示 * 采用饥饿模式。饥饿模式下，量词只会匹配尽可能少的字符，即0个字符。上例中的表达式将会匹配单词John,在输入文本中出现3次。如果改为贪婪模式，表达式如下：John.*贪婪模式下，量词会匹配尽可能多的字符。现在表达式会匹配第一个出现的John，以及在贪婪模式下 匹配剩余的所有字符。这样，只有一个匹配项。最后，我们改为独占模式：John.*+hurt*后跟+ 表示独占模式量词。这个表达式在输入文本中没有匹配项，尽管文本中包括 John 和 hurt. 为什么会这样? 因为 .*+ 是独占模式。与贪婪模式下，尽可能多的匹配文本，以使整个表达式匹配不同。独占模式会尽可能的多的匹配，但不考虑表达式剩余部分是否能匹配上。.*+ 将会匹配第一个John之后的所有字符，这会导致表达式中剩余的 hurt 没有匹配项。如果改为贪婪模式，会有一个匹配项。表达式如下：John.*hurt逻辑操作符正则表达式支持少量的逻辑运算(与，或，非)。与操作是默认的，表达式 John ,意味着J 与 o与h与n。或操作需要显示指定，用 | 表示。例如表达式 John|hurt 意味着John 或 hurt 。 ###字符| Type| Description ||————- |————-|| . | 除换行以外的任意字符 || \\ | 反斜杠, 单独的反斜杠做为转义字符,与其他特殊字符一起使用。如果想匹配反斜杠本身,需要转义。两个反斜杠实际匹配一个反斜杠。| nn | 字符的8进制表示.n 在0至7之间取值 || mnn | 字符的8进制表示. m 在0至3之间取值, n 在0至7之间取值|| \xhh | 字符的16进制表示.|| \uhhhh | 字符的16进制表示 0xhhhh. 对应unicode 编码字符|| \t | 缩进符.|| \n | 换行符 (unicode: ‘\u000A’)|| \r | 回车符 (unicode: ‘\u000D’)|| \f | 制表符 (unicode: ‘\u000C’)|| \a | 警报（铃声）字符 (unicode: ‘\u0007’)|| \e | 转义符 (unicode: ‘\u001B’)|| \cx | 控制符 x| ###字符分类 Type Description [abc] 匹配 a, 或 b 或 c [^abc] 匹配不是a,b,c 的字符，是否定匹配 [a-zA-Z] 匹配a 到 z ，A到Z 直接的字符，是范围匹配 [a-d[m-p]] 匹配a到d之间字符或 m到p之间字符，是并集匹配 [a-z&amp;&amp;[def]] 匹配 d, e, 或 f. 是交集匹配 (这里是在范围 a-z和字符def之间取交集). [a-z&amp;&amp;[^bc]] 匹配a-z 之间所有字符，排除bc的字符。是减法匹配 [a-z&amp;&amp;[^m-p]] 匹配a-z 之间所有字符,排除m-p之间的字符是减法匹配 ###内置字符分类 Type Description . 匹配任意一个字符,根据创建Pattern是传入的标志,可能匹配行结尾符 \d 匹配任意数字 [0-9] \D 匹配任意非数字 [^0-9] \s 匹配任意空白符 (空格, 缩进, 换行,回车) \S 匹配任意非空白符 \w 匹配任意单词 \W 匹配任意非单词 ###边界匹配 Type Description ^ 匹配行首 $ 匹配行尾 \b 匹配单词边界 \B 匹配非单词边界 \A 匹配文本开头 \G 匹配前一匹配项结尾【不知其用法和用意。】 \Z 输入的结束，但是对于最终终止符，如果有的话 \z 输入的结束 ###量词 贪婪模式 饥饿模式 独占模式 X? X?? X?+ 匹配0或1次 X* X*? X*+ 匹配0或多次 X+ X+? X++ 匹配1或多次 X{n} X{n}? X{n}+ 匹配n次 X{n,} X{n,}? X{n,}+ 匹配最少n次 X{n, m} X{n, m}? X{n, m}+ 匹配最少n次，最多m次]]></content>
  </entry>
  <entry>
    <title><![CDATA[GlobalDialog框架使用教程]]></title>
    <url>%2F2017%2F06%2F10%2FGlobalDialog%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[GlobalDialog是由ITalk应用开源的一款全局对话框库。相比于Android原生对话框的繁琐配置，GlobalDialog的优势在于能够快速实现全局对话框的功能（通知账号下线、通知账号异常等）。进一步了解，请访问笔者的Github。 #集成方法在Module的build.gradle文件中添加如下依赖即可。1compile &apos;com.txm.topcodes.globaldialog:globaldialog:0.1.6&apos; #调用方式常规方式：1234567891011new GlobalDialog.Builder().setContext(context) .setDescription(&quot;hello world&quot;) //弹出框的提示信息。.setStyle(GlobalDialog.Style.SingleAlert) //弹窗的样式。有DoubleAlert、SingleAlert两种，默认为后者。.setForce(ture) //设置弹框销毁的策略。默认为true。.setDialogClickListener(new OnDialogClickListener() &#123; //设置回调，也可以不设置。@Overridepublic void onSure() &#123;super.onSure();&#125;&#125;).build().show(); 精简方式：1234new GlobalDialog.Builder().setContext(context) .setDescription(&quot;hello world&quot;) .build().show(); #FAQ 我发现GlobalDialog还存在BUG？GlobalDialog是一个完全开源的框架，如果您在使用过程中发现问题，欢迎在笔者的GitHub创建一个Issue。 我是Eclipse用户，可以使用GlobalDialog么？不可以。 我在Android studio中链接GlobalDialog库失败了？确保您的工程使用的远程仓库为jcenter。12345allprojects &#123;repositories &#123;jcenter()&#125;&#125;]]></content>
      <categories>
        <category>我的Android框架</category>
      </categories>
      <tags>
        <tag>View</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AutoCache高性能缓存框架使用教程]]></title>
    <url>%2F2016%2F10%2F23%2FAutoCache%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[读者可能会问在下： 为什么要使用AutoCache？简洁、高性能。 现在市面上有那么多缓存的框架，像piccso等都很优秀，那笔者是不是在重复造车？AutoCache是为那些追求轻量级缓存的APP而生的。目的是让开发者既能快速完成APP缓存功能的开发，又能保证上线后性能的稳定。 AutoCache 能够让你高效地编写app缓存代码 ，保证你的数据流被安全、准确地存储到SDcard私有目录。参考下列核心调用代码来开始你的 AutoCache 之旅：1234567891011121314151617181920212223AutoCache.MediaCache.getInstance(context).asyncCache(&quot;url&quot;, new CallBack() &#123;@Overridepublic void onStart() &#123;//Run in UI thread.&#125;@Overridepublic void save2DataBase(String cachePath) &#123;//Run in io thread,//You can sava the cachPath to database or sharepreference.&#125;@Overridepublic void onSuccess(byte[] bytes) &#123;//Run in UI thread.&#125;@Overridepublic void onErro(Throwable e) &#123;//Run in UI thread.&#125;&#125;, FILE_TYPE, &quot;filename&quot;); #集成方法在Module的build.gradle文件中添加如下依赖即可。1compile &apos;com.txm.topcodes.autocache:autocache:0.1.2&apos; #调用方式为方便开发者，AutoCache提供统一调用入口，调用方式十分简洁。下面先给大家看一张思维导图，该图罗列了框架的主体功能及其构成。 从结构图不难看出，AutoCache类就是调用框架的入口类。当我们需要从本地获取流文件时，调用方式是这样的1AutoCache.Media.get…(); 缓存网络文件时，调用方式是这样的1AutoCache.MediaCache.getInstance(context).asyncCache(); 缓存内存文件时，调用方式是这样的1AutoCache.MediaCache.getInstance(context).cache(); 当需要指定文件文件类型时，使用方式是这样的1AutoCache.DIRECTORY_PICTURES 「如需获取详细信息，请在 GitHub 的 auto-cache页面查看源代码.」 #文件类型AutoCache支持缓存以下泛媒体类型：Podcasts,Pictures,Movies,Music,Documents,Download。其中Download比较特殊，用它可以指定未知的文件类型。 #使用场景当我们的APP从网络获取文件流时，往往会有这样的需求「也可能是其中之一」： 网络请求时，要可以自动将文件保存到APP本地。 网络请求时，将网络图片的本地路径存储到SQLite或其它数据持久化中，以方便逻辑处理。 网络请求时，直接使用从网络获取到文件流。 网络请求时，方便添加进度条功能。 网络请求时，全局捕获异常。 本次请求之后，根据文件名、文件类型从本地获取文件流。 对于需求1。AutoCache完全是在后台IO线程中完成的，不需要调用者主动去操作。 IO线程：I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io线程比Thread线程更有效率。 对于需求2。save2DataBase(String cachePath)回调方法自动就被指定在IO线程中运行。「所以，save2DataBase既是一个非阻塞的方法，又具备IO线程的高效性。」 对于需求3。onSuccess(byte[] bytes)回调方法被指定自动运行在UI线程中。 对于需求4。AutoCache提供了onstart()回调方法作为调用开始的标志，onSuccess(byte[] bytes)或onErro(Throwable e)作为调用结束点。 对于需求5。全局捕获异常指的是：onErro(Throwable e)不仅可以捕获网络异常、本地缓存媒体时发生的异常，而且还可以捕获发生在onStart、save2DataBase、onSuccess中的异常。 对于需求6。AutoCache.Media类提供了4种同步方式来获取本地的媒体流。 #最佳实践 ####防止OOMAutoCache.Media类中提供了getSoftBmp(~)，getWeakBmp(~)，getBmp(~)，getFile(~)四种方式来获取流。如果是图片文件，笔者建议使用前两种方式，具体可参考善于利用软引用和弱引用。 ####定制回调方法AutoCache框架提供了CallBackAdapter接口用于替换CallBack接口。可以通过它实现自由定制自己需要的回调方法。「这样是为了代码看上去简洁。」1234567891011AutoCache.MediaCache.getInstance(context).asyncCache(&quot;url&quot;, new CallBackAdapter() &#123;@Overridepublic void save2DataBase(String cachePath) &#123;&#125;@Overridepublic void onSuccess(byte[] bytes) &#123;&#125;//you can add other callback function here.&#125;,FILE_TYPE,&quot;filename&quot;); #FAQ 我发现AutoCache还存在BUG？AutoCache是一个完全开源的框架，如果您在使用过程中发现问题，请在GitHub创建一个问题。 我是Eclipse用户，可以使用AutoCache么？不可以。 AutoCache用到了哪些第三方框架？是的。AutoCache是在RXjava+Okhttp基础之上封装的一个轻量级缓存框架。 AutoCache提供缓存文件路径到SQLite数据库的方法了吗？没有。AutoCache缓存的重心是将流文件缓存到本地目录。如果需要将文件路径缓存到SQLite或其他持久化数据层中，开发者需要自行在save2DataBase(cachePath)回调方法中实现逻辑。 我在android studio中链接AutoCache库失败了？确保您的工程使用的远程仓库为jcenter。12345allprojects &#123;repositories &#123;jcenter()&#125;&#125; ————–我是一条萌萌哒的分割线，表示教程结束—————-]]></content>
      <categories>
        <category>我的Android框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio NDK开发全攻略]]></title>
    <url>%2F2016%2F08%2F14%2FNDK%E5%BC%80%E5%8F%91%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[读完本章，你可以： 在Android Studio上轻松搭建NDK开发环境。 掌握最快捷的JNI开发方式。 掌握使用.so文件开发Android程序的技巧。 一、 NDK环境搭建 开发工具准备要进行Android NDK开发，首先要下载Android NDK开发工具。可以在AndroidStudio上面下载，也可以自己下载好了，然后将NDK的路径设置为自己下载的Android NDK开发工具的路径。 Gradle的相关配置1) 我们来配置Project的build.gradle。1234/*gradle插件不支持NDK，我们需要使用gradle-experimental插件。 */dependencies &#123;classpath &apos;com.android.tools.build:gradle-experimental:0.7.0&apos;&#125; 2) 我们来配置Module的build.gradle。12345678910111213141516171819202122232425262728293031323334apply plugin: &apos;com.android.model.application&apos;model &#123;android &#123;compileSdkVersion = 23buildToolsVersion = &quot;23.0.2&quot;defaultConfig &#123;applicationId &quot;com.lavor.ndklearning&quot;minSdkVersion.apiLevel 15targetSdkVersion.apiLevel 23versionCode 4versionName &quot;1.0.1&quot;&#125;&#125;android.ndk &#123;moduleName &quot;lavor&quot;ldLibs.addAll([&apos;log&apos;])cppFlags.add(&quot;-std=c++11&quot;)cppFlags.add(&quot;-fexceptions&quot;)platformVersion 15stl &apos;gnustl_shared&apos;&#125;android.buildTypes &#123;release &#123;minifyEnabled = falseproguardFiles.add(file(&quot;proguard-rules.txt&quot;))&#125;&#125;&#125;dependencies &#123;compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])compile &apos;com.android.support:appcompat-v7:23.1.1&apos;compile &apos;com.android.support:recyclerview-v7:23.1.1&apos;compile &apos;com.android.support:design:23.1.1&apos;&#125; 小提示 首先，在apply的时候我们引入的插件名称由’com.android.application’变成了’com.android.model.application’。 其次，在原来android的外层加入了一个model层次。 再次，原来在android的里面的块，除了defaultConfig外，全部移除android块放入model块中与android并列，并且前面的名字加上android.。 然后，compileSdkVersion 23与 buildToolsVersion “23.0.2”改成 compileSdkVersion = 23和 buildToolsVersion = “23.0.2”，中间加上了=。 其次，添加上android.ndk块，块中的moduleName表示C/C++代码打包成so文件的名字。 再次，android.buildTypes块中的proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’改成proguardFiles.add(file(“proguard-rules.txt”))。 最后，注意dependencies块依然在最外层，它不在model块中。 二、 使用NDK开发第一个JNI程序 在Android程序中新建一个包含native（本地）方法的NDKTest类。12345678package com.lavor.ndklearning;public class NDKTest &#123;static &#123;//加载.so库文件System.loadLibrary(&quot;lavor&quot;);&#125;public native String getString();&#125; 小知识 程序中static{}称为静态代码块，它在类初始化的时候执行。不懂请猛击&gt;&gt; 将鼠标移动到方法名getString上，然后按下Alt+Enter快捷键，弹出一些解决的方法建议，点击第一个Create Function… 此时会自动建立一个与java目录同级的jni目录，在jni目录自动建立一个c文件，在c文件中实现了刚才的native方法。 然后，稍稍修改一下.c文件中实现的native方法。12345JNIEXPORT jstring JNICALLJava_com_lavor_ndklearning_NDKTest_getString(JNIEnv *env, jobject instance) &#123;// TODOreturn (*env)-&gt;NewStringUTF(env, &quot;AndroidStudio NDK开发最佳入门实践&quot;);&#125; 补充说明 仔细观察可以看到c文件的方法名是遵循“Java_包名类名本地方法名”来组织的（了解到这些后，我们就可以脱离编译器的帮助，直接去写.c文件啦）。 最后在Android程序中调用JNI接口。1234567891011public class MainActivity extends Activity &#123;private android.widget.TextView text;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);this.text = (TextView) findViewById(R.id.text);NDKTest NDK=new NDKTest();text.setText(NDK.getString());&#125;&#125; 运行程序后界面如下： 深度总结 讲道理，我们在正式开发时，不会像这样子去开发。因为这样的话就会把我们的c代码也暴露了出来。这明显与JNI的安全保密机制相违背，所以，正式开发的时候，我们会使用.so文件进行全保密式的开发。 三、 使用.so文件开发Android程序不知道大家有没有记得上一章说过，使用JNI有个好处就是安全性高，JNI部分的代码很难被反编译。这其实是要归功于.so文件。下图为.so文件的生成位置。具体的使用步骤是怎样的呢？ 新建一个Android工程，命名为：AndroidApplication。（工程名、包名、组织名任意） 导入.so文件至app/libs中。 为了能够调用libs文件夹下的.so资源，需在app的build.gradle的android节点下设置。 12345sourceSets&#123;main&#123;jniLibs.srcDirs = [&apos;libs&apos;]&#125;&#125; 新建相关类结构。 12345678package com.lavor.ndklearning;public class NDKTest &#123;static &#123;//加载.so库文件System.loadLibrary(&quot;lavor&quot;);&#125;public native String getString();&#125; 补充说明 Android端声明native code的代码需要严格按照JNI接口来组织。（也就是说，包名、类名都要和.so文件中JNI名称一致）不懂就点击这里吧&gt;&gt; 函数调用。12345678public class DemoActivity extends AppCompatActivity &#123;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_demo);Log.d(&quot;NDK&quot;,new NDKTest().getString());&#125;&#125; 运行结果如下： 注意啦！此文并非原创，算是对一波优秀文章的总结吧。笔者希望通过这种方式激励自己学习，也期待可以帮到正在学习NDK的你。欢迎指出本文的BUG，共勉！！！！！ 参考资料 AndroidStudio NDK开发最佳入门实践 如何在Android中使用编译好的.so库]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七夕前，我认识了NDK]]></title>
    <url>%2F2016%2F08%2F06%2F%E4%B8%83%E5%A4%95%E5%89%8D%EF%BC%8C%E6%88%91%E8%AE%A4%E8%AF%86%E4%BA%86NDK%2F</url>
    <content type="text"><![CDATA[看前必读 读完本章，你可以掌握NDK、JNI的概念及其开发流程。 阅读时，不必纠结于读不懂的代码结构，后面的教程 都会讲到的。 一、为何要学习NDK？ 代码的保护。Android APK的Java层代码很容易被反编译，但C/C++库反编译难度较大。 可以方便地使用现存的开源库。大部分现存的开源库都是用C/C++代码编写的。 提高程序的执行效率。将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。 便于移植。用C/C++写的库可以方便在其他的嵌入式平台上再次使用。 二、先知道什么是JNIJNI（Java Native Interface）是Java语言提供的Java和C/C++互相沟通的机制，可以实现： java调用本地的C/C++代码 本地的C/C++代码也可以调用java代码 三、开发JNI程序的简化流程 编写Java Code，如下例子： 12345678910111213/*** 加载lavor本地共享库到内存中*/static &#123;System.loadLibrary(&quot;lavor&quot;);&#125;/*** 定义本地方法对应的Java方法** @return*/public native String getString(); 编写C/C++，如下例子： 123456#include &lt;jni.h&gt;JNIEXPORT jstring JNICALLJava_com_lavor_ndklearning_MainActivity_getString(JNIEnv *env, jobject instance) &#123;return (*env)-&gt;NewStringUTF(env, &quot;这是我的c程序代码&quot;);&#125; 编译 C/C++ Code，成功并得到本地共享库。 小知识 本地共享库是Linux下的叫法，文件扩展名是.so，windows下叫动态链接库，文件扩展名是.dll。 C /C++的跨平台性是以牺牲编译时间以及编译难度为代价的。（这里的编译难度是指为适应不同平台而做的编译过程的调整） Java的一次编译到处运行，是以牺牲运行效率为代价的。 编译并打包Java。把本地共享库（.so文件）放置到Java项目的指定目录，一般是libs文件夹。然后编译Java代码即可打包运行。 小知识 Android项目中，.so文件存放地址为libs/armeabi。(armeabi是对应的平台，下一章将会详细介绍) 四、NDK概述NDK(Native Development Kit)是Google为Android进行本地开发而放出的一个本地开发工具， 包括Android的Native API、公共库以及编译工具。其实说白就是Google为方便Android程序猿开发JNI程序，而提供的便捷工具。 补充两点 NDK处在JNI开发流程中的编译环节（第三、四步）。针对不同的平台，NDK可以全自动编译出对应可运行的本地共享库，并可将对应的.so文件和应用程序一起打包成apk发布。（这时，跨平台编译C/C++的难度指数降为0。不明白请猛击） NDK需要Android 1.5版本以上的支持。 五、开发NDK程序的流程这个开发流程大致与JNI的开发流程差不多： SDK开发。编写Java代码，调用各种Android的API实现功能，编写含有native关键字的代码开始JNI。 JNI开发。按照 JNI编码规范，编写与Java交互的本地代码（一般就是数据类型的转换，把 C/C++的数据类转换成Java能识别的，或反过来）。 C/C++开发。编码实现业务逻辑，或调用NDK提供的本地API或库，完成Android平台上特定功能的开发、封装。 NDK编译，编写.mk文件，编译调试，最后修改.mk文件，针对特定的平台（ARM/x86）做编译结果的优化。 最后就是SDK编译、打包，上真机调试了… 注意啦！此文并非原创，算是对一波优秀文章的总结吧。笔者希望通过这种方式激励自己学习，也期待可以帮到正在学习NDK的你。欢迎指出本文的BUG，共勉！！！！！ 参考资料Android之NDK开发]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
