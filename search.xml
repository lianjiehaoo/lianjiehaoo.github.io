<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android动画（七）：过渡动画]]></title>
    <url>%2F2019%2F07%2F29%2F%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[笔者已将本节的代码上传至Github，大家可以结合着学习。Android 4.4.2 (API level 19) 引入了Transition 框架，支持场景过渡效果，到了Android 5.0（API level 21）开始支持Activity过渡动画。相对于View Animation或Property Animator，Transition动画更具特殊性，Transition可以看作对Property Animator的高度封装。为了对Transition有一个大概的了解，我们对Scene Transition(场景过渡动画)、Activity过渡动画、Shared Element Transition(共享元素过渡动画)这三个方面来做一个简单的了解。 Scene Transition(场景过渡动画)场景过渡动画是指以动画的形式实现View两个场景的切换(从一个场景切换到另一个场景)。而且在切换过程中通过Transition来设置不同的过渡动画效果。场景过渡动画中有三个特别关键概念：Scene（场景），Transition（过渡动画），TransitionManager（管理）。 Scene：Scene代表一个场景。Scene保存了一个视图层级结构，包括它所有的views以及views的状态，通常由getSceneForLayout (ViewGroup sceneRoot,int layoutId,Context context)获取Scene实例。Transition框架可以实现在starting scene和ending scene之间执行动画。而且大多数情况下，我们不需要创建starting scene，因为starting scene通常由当前UI状态决定，我们只需要创建ending scene。 Transition：Transiton则是用来设置过渡动画效果用的。而且系统给提供了一些非常使用的Transtion动画效果，如下表所示:|系统Transition|解释|| ———- |———- ||ChangeBounds |检测View的位置边界创建移动和大小变化动画(关注布局边界的变化，不关注scale引起的布局边界变化)||ChangeTransform|检测View的scale和rotation创建缩放和旋转动画(关注scale和ratation的变化)||ChangeClipBounds|检测View的剪切区域的位置边界，和ChangeBounds类似。不过ChangeBounds针对的是view而ChangeClipBounds针对的是view的剪切区域rect的变化，（关注setClipBounds(Rect rect)中rect的变化）||ChangeImageTransform|检测ImageView的ScaleType，并创建相应动画(关注的是ImageView的scaleType)||Fade|根据View的visibility状态的的不同创建淡入淡动画,调整的是透明度(关注的是View的visibility的状态)||Slide|根据View的visibility状态的的不同创建滑动动画(关注的是View的visibility的状态)||Explode|根据View的visibility状态的的不同创建分解动画(关注的是View的visibility的状态)||AutoTransition|默认动画，ChangeBounds、Fade动画的集合| PathMotionTransition 的辅助工具，以 path 的方式指定过渡效果，两个具体实现类 ArcMotion 和 PatternPathMotion，效果类似于之前讲过的路径动画。参考链接&gt;&gt; TransitionManagerTransitionManager 用于将 Scene 和 Transition 联系起来，它提供了一系列的方法，如：go(Scene scene, Transition transition)，到指定的场景所使用的过渡动画是什么，beginDelayedTransition(ViewGroup sceneRoot, Transition transition)，在当前场景到下一帧的过渡效果是什么。 我们在使用场景过渡动画时，有两种实现方式。1、TransitionManager.go方式。123456...//定义开始场景、结束场景。mSceneStart = Scene.getSceneForLayout(sceneRootView, R.layout.scene_start, context);mSceneEnd = Scene.getSceneForLayout(sceneRootView, R.layout.scene_end, context);//开始场景过渡动画。其中&quot;transition&quot;参数可以通过代码生成，如：new AutoTransition()。也可以是引用xml文件，如：TransitionInflater.from(this).inflateTransition(R.transition.xxx)。TransitionManager.go(mSceneEnd,transition); 2、beginDelayedTransition方式。1234...TransitionManager.beginDelayedTransition(sceneRootView,transition);//下面改变sceneRootView中子view的属性，如：位置，缩放比例等。... beginDelayedTransition的方式是不是会让你联想到之前讲过的LayoutTransition动画呢？我反正是想到了。它们之间的区别可以这么理解：LayoutTransition针对的是各个控件在限定场景到达时的动画表现。而beginDelayedTransition针对的是不同的场景之间的切换动画。前者关注的是控件（微观），后者关注的是场景（宏观）。除了使用系统自带的Transtion使用动画以外，我们还可以自定义Transition动画，具体可参考官方的这篇文章。或者直接看官方给的DEMO。 最后，使用场景过渡动画需要注意以下几点：1、Android 版本在 4.0(API Level 14) 到 4.4.2(API Level 19) 使用 Android Support Library，但是Activity过渡动画和共享元素过渡动画至少要Android 5.0版本才支持。2、对于 SurfaceView 可能不起效果，因为 SurfaceView 的实例是在非 UI 线程更新的，因此会造成和其他视图动画不同步。3、某些特定的转换类型在应用到 TextureView 时可能不会产生所需的动画效果。4、继承自 AdapterView 的视图如：ListView，与该框架不兼容。RecycleView兼容该框架，不过由于RecycleView复用机制的存在，这里就会存在两个动画：一个进入、一个退出，所以如果不满足需求，还是老实用ItemAnimator吧（PS：后面再写篇文章介绍RecycleView）。5、不要对包含文本的视图的大小进行动画（可是我没找具体的不兼容情况）。6、默认情况下，sceneRoot下所有的view都会执行Transition动画，我们可以通过Transition.addTarget 和 removeTarget 方法选择性添加或移除执行动画的 View 。需要注意的是，Transition的removeTarget方法必须在已经使用了addTarget的前提下才有效果。在未使用addTarget的情况下，如果要排除某个view执行动画效果，可以使用Transition的excludeTarget替代removeTarget方法。 Activity过渡动画、Shared Element Transition(共享元素过渡动画)这个部分就直接参考这篇文章吧～笔者补充一点，对于文章中提到的ViewOverlay，建议看下这篇文章加深理解噢。 参考资料1、Animate layout changes using a transition2、Android Transition（Android过渡动画）3、Android Transition（一）]]></content>
      <tags>
        <tag>Scene Transition</tag>
        <tag>Content Transition</tag>
        <tag>Shared Element Transition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android动画（六）：布局动画]]></title>
    <url>%2F2019%2F07%2F21%2F%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8006%EF%BC%9A%E5%B8%83%E5%B1%80%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[笔者已将本节的代码上传至Github，大家可以结合着学习。在Android的动画体系中，有补间动画，帧动画和属性动画，但是这些动画都是针对单个对象的，如果想对ViewGroup作动画，就要用到布局动画了。布局动画一共有两种：LayoutAnimation和LayoutTransition，本文将逐一介绍他们的用法和区别。 LayoutAnimationLayoutAnimation布局动画属于补间动画的一种，利用它可以快速实现对ViewGroup中子view的动画。不过，它的缺陷是只能够在ViewGroup初始化时对其子view产生动画效果，之后再增加子view时没有效果。LayoutAnimation动画可以直接在xml中定义：1、首先定义单个View的补间动画12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;500&quot;&gt; &lt;translate android:fromXDelta=&quot;-50%p&quot; android:toXDelta=&quot;0&quot;/&gt; &lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot;/&gt;&lt;/set&gt; 2、定义layoutAnimation12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layoutAnimation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:animation=&quot;@anim/slide_in_from_left&quot; android:animationOrder=&quot;random&quot; android:delay=&quot;1&quot;/&gt;&lt;!--delay : ViewGroup 中单个Item动画的开始延时，取值是android:animation 所指定动画时长的倍数，可以是float，也可以是百分数，默认0.5比如slide_in_from_left中定义的动画时长是500ms，这里delay=1，那么在上一个动画执行之后延时500ms执行下一个tem的动画animationOrder : 动画开始顺序，normal(正序)、reverse(倒序)、random(随机)animation : 指定动画资源animation，注意不能使用animator--&gt; 可以通过下面两种方式加载1、直接在ViewGroup的 layout xml 文件中设置：1android:layoutAnimation=&quot;@anim/list_item_slide_layout_animation&quot; 2、使用代码设置：123456Animation animation = AnimationUtils.loadAnimation(mActivity，R.anim.slide_in_from_left);LayoutAnimationController animationController = new LayoutAnimationController(animation， 1f);animationController.setOrder(LayoutAnimationController.ORDER_NORMAL);mList.setLayoutAnimation(animationController);mList.startLayoutAnimation(); 同时，系统也提供了gridLayoutAnimation用于给Gridview设置布局动画。需要注意的是布局动画，在创建ViewGroup的时候生效，后续添加的子View是没有动画效果的。 LayoutTransitionLayoutTransition 是API Level 11 才出现的。LayoutTransition的动画效果，只有当ViewGroup中有View添加、删除、隐藏、显示的时候才会体现出来，初始化时没有效果。LayoutTransition类中主要有五种容器转换动画类型，具体如下： LayoutTransition.APPEARING：当View出现或者添加的时候View出现的动画。LayoutTransition.CHANGE_APPEARING：当添加View导致布局容器改变的时候整个布局容器的动画。LayoutTransition.DISAPPEARING：当View消失或者隐藏的时候View消失的动画。LayoutTransition.CHANGE_DISAPPEARING：当删除或者隐藏View导致布局容器改变的时候整个布局容器的动画。LayoutTransition.CHANGE：当不是由于View出现或消失造成对其他View位置造成改变的时候整个布局容器的动画。 LayoutTransition也有两种方式添加。1、在xml中直接添加。12// 只能使用系统默认的LayoutTransition动画android:animateLayoutChanges=&quot;true&quot; 2、在代码中使用。使用系统默认的LayoutTransition动画12LayoutTransition mTransitioner = new LayoutTransition();mViewGroup.setLayoutTransition(mTransitioner); 使用自定义的LayoutTransition动画12345LayoutTransition layoutTransition = new LayoutTransition();viewGroup.setLayoutTransition(layoutTransition);...layoutTransition.setAnimator(transitionType， AnimatorInflater.loadAnimator(this， R.animator.xxx));&lt;!--transitionType代表五种容器转换动画类型； R.animator.xxx代表属性动画资源。--&gt; 同时，可以给LayoutTransition设置监听器1mTransitioner.addTransitionListener(new LayoutTransition.TransitionListener()&#123;//...&#125; 总结 布局动画类 类型 优缺点 发布版本 LayoutAnimation 补间动画 优点：快速实现对ViewGroup中子View的动画。对于RecyclerView这些list类型的viewGroup同样适用。缺点：只能够在ViewGroup初始化时对其子View产生动画效果。 API Level 1 LayoutTransition 属性动画 优点：ViewGroup中只要有子View添加、删除、隐藏、显示，都能对子View的产生动画。。缺点：1、对于RecyclerView不适用，我在实验滑动的时候是直接报错了，所以我建议如果是RecyclerView的话，还是用它自带的ItemAnimator。2、对于ListView适用，参考这个链接，不过效果有点乱，同时还使得问题复杂化了，我在stackoverflow上看到了这个问题的回答。3、初始化ViewGroup时没有效果。 API Level 11 参考资料1.Android 动画(一)LayoutAnimation与LayoutTransition2.Android animation 30天上手 — Day13 LayoutTransition]]></content>
      <categories>
        <category>Android动画基础</category>
      </categories>
      <tags>
        <tag>LayoutAnimation</tag>
        <tag>LayoutTransition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android动画（五）：Path类型插值器、路径动画、Fling动画、Spring动画]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8005%EF%BC%9APath%E7%B1%BB%E5%9E%8B%E6%8F%92%E5%80%BC%E5%99%A8%E3%80%81%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB%E3%80%81Fling%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[笔者已将本节的代码上传至Github，大家可以结合着学习。本节内容是Android移动动画的进阶内容。其中，“Path类型插值器”、“路径动画”算是补充了视图动画、属性动画中所提及的插值器、估值器内容，“Path类型插值器”、“路径动画”能够实现的效果，用插值器和估值器也可以实现，但前者更加高效。本章的内容主要参考了官方的下面三篇文章：1、Move a View with Animation2、Move views using a fling animation3、Animate movement using spring physics参考的中文文章在文末有给出。 Path类型的插值器Path类型的插值器是一种新的插值器，Android从5.0开始支持。可以用代码、XML两种方式实现，这里我们只讨论代码实现的方式：12345678if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;Path path = new Path();path.lineTo(0.25f, 0.25f);path.moveTo(0.25f, 0.5f);path.lineTo(1f, 1f);PathInterpolator pathInterpolator = new PathInterpolator(path);…………&#125; 从以上代码可以看出，Path被限制在一个1*1的正方形中，x、y坐标的取值范围都为[0,1]，并且Path必须从(0,0)坐标开始，(1,1)坐标结束。x坐标代表时间进度：0-100%，y坐标代表当前时间点对应的动画完成度：0-100%。一旦pathInterpolator创建完成，就可以通过Animator.setInterpolator()方法使用它了。123ObjectAnimator animation = ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 100f);animation.setInterpolator(pathInterpolator);animation.start(); 路径动画ObjectAnimator从 Android 5.0 开始提供了一类新的构造方法用于实现沿自定义路径移动的动画。1234567891011121314151617if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;Path path = new Path();path.moveTo(view.getX(), view.getY());path.cubicTo(view.getX(), view.getY(),view.getX() + 300, view.getY() + 200,view.getX() - 400, view.getY() + 500);//下面两种方法不允许//path.addCircle(view.getX(), view.getY(),100,Path.Direction.CCW);//path.arcTo(view.getX()+100, view.getY()+100, view.getX() + 500, view.getY() + 500, 270f, -180f, true);ObjectAnimator objectAnimator =ObjectAnimator.ofFloat(ivBalPathAnimator, View.X, View.Y, path);objectAnimator.setDuration(1200);objectAnimator.setRepeatCount(ValueAnimator.INFINITE);objectAnimator.setRepeatMode(ValueAnimator.REVERSE);objectAnimator.setInterpolator(new LinearInterpolator());objectAnimator.start();&#125; Fling动画Fling动画使用物理学中摩擦力的概念，使得view的速度逐渐被降低，从而实现了现实中的阻力运动。Android 4.4版本开始支持该动画。 1、添加支持库 123dependencies &#123;implementation &apos;com.android.support:support-dynamic-animation:28.0.0&apos;&#125; 2、创建fling动画 FlingAnimation类可以帮助你创建fling动画，只要在创建FlingAnimation实例时传入操作的view对象以及操作对象的属性即可。1FlingAnimation fling = new FlingAnimation(view, DynamicAnimation.SCROLL_X); 3、设置初始速度 为了让物体移动（并非只有移动），我们必须给物体一个初速度。默认的初速度是0，所以我们必须定义一个大于0的初速度以保证物体能够移动。设置初速度的方法是setStartVelocity()。您可以使用固定值作为起始速度，也可以将其基于触摸手势的速度通过GestureDetetor.OnGestureListener 获取。如果您选择提供固定值，您应该以每秒dp的值定义值，然后将其转换为每秒像素数。以每秒dp定义值的方式允许速度独立于设备的密度和形状因子。有关将起始速度转换为每秒像素数的更多信息，将在下一篇文章 《Spring Animation》中的“ 每秒转换为每秒像素数”部分讲解 。 4、设置动画的取值范围 你可以通过setMinValue()和setMaxValue()设置属性值的变化范围，这个对于有明确变化范围的属性显得十分重要，例如透明度（0-1）。注意，当fling时的属性值到达设定的最大值或者最小值时，动画会立刻结束。 5、设置阻力因子 你可以通过setFriction()改变动画的阻力因子，他定义了速度下降的速度。阻力因子的默认值是1。下面的例子定义了一个横向滑动的fling动画，滑动边界被设置为0和maxScroll，摩擦力设置为1.1。123456FlingAnimation fling = new FlingAnimation(view, DynamicAnimation.SCROLL_X);fling.setStartVelocity(-velocityX).setMinValue(0).setMaxValue(maxScroll).setFriction(1.1f).start(); 注意，上面的方法仅仅适用于单个属性的fling变化。如果有多个属性同时需要fling变化呢？有的文章倒是建议用FloatPropertyCompat实现。可是FloatPropertyCompat有它的局限性，正如这篇文章的第五部分所说：要在确保所有属性的值不是完全相互独立的情况下，该方法才适用。否则，我们只能针对每个属性都建立一个FlingAnimation。 6、设置最小可见变化 当您在为不以像素为单位定义的自定义属性设置动画时，应设置用户可见的动画值的最小更改，它作为定义动画结束的最小值。当操作DynamicAnimation.ViewProperty动画时不需要调用此方法，因为此时的最小可见变化可以自动获取。例如：1、默认最小可见的变化值是1个像素，如：TRANSLATION_X，TRANSLATION_Y， TRANSLATION_Z，SCROLL_X，和 SCROLL_Y。2、对于使用旋转动画，如ROTATION， ROTATION_X，和ROTATION_Y，最小可见变化是MIN_VISIBLE_CHANGE_ALPHA，或1/10像素。3、对于使用不透明度的动画，最小可见变化为 MIN_VISIBLE_CHANGE_ALPHA或者1/256。要设置动画的最小可见变化，请调用setMinimumVisibleChange()方法，并传递最小可见常量或您需要为自定义属性计算的值。有关计算此值的更多信息，请参阅本文末的“计算最小可见变化值”部分。1anim.setMinimumVisibleChange(DynamicAnimation.MIN_VISIBLE_CHANGE_SCALE); 注意：只有在为不以像素定义的自定义属性制作动画时，才需要设置最小可见变化值。 计算最小可见变化值 ：最小可见变化值=自定义属性值的范围/以像素为单位的动画执行范围。例如，要进行动画制作的自定义非像素为单位的属性变化范围是从0到100，同时如果此过程对应于200像素的动画更改。根据公式，最小可见变化值是100/200等于0.5像素。 Spring动画这一部分的内容在官网讲得也是很明白了。需要注意的是，官网结尾最后的“Cancel animation”部分提到的‘cancel()’和‘skipToEnd()’使用注意事项： cancel()：立即停止动画skipToEnd()：恢复到最终位置并停止动画。需要注意的是，在无阻尼的情况下，不能调用该方法（即：DampingRatio==0时）。为了安全，可以先调用canSkipToEnd()进行判断，有阻尼的情况下返回true，否则返回false。一般来说，skipToEnd()会有跳跃的效果。 参考资料1、中文翻译：使用fling动画移动视图2、SpringAnimation详解－Android]]></content>
      <categories>
        <category>Android动画基础</category>
      </categories>
      <tags>
        <tag>PathInterpolator</tag>
        <tag>路径动画</tag>
        <tag>FlingAnimation</tag>
        <tag>SpringAnimation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android动画（四）：淡入淡出、翻牌、揭露动画]]></title>
    <url>%2F2019%2F02%2F22%2F%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8004%EF%BC%9A%E6%B7%A1%E5%85%A5%E3%80%81%E7%BF%BB%E7%89%8C%E3%80%81%E6%8F%AD%E9%9C%B2%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[笔者已将本节的代码上传至Github，大家可以结合着学习。以下内容是对官方文档的翻译。当你在使用APP时，如果立即从旧的内容切换到新内容，则很容易让用户感到不适，所以我们需要转场动画来平滑地过渡这种新旧内容的切换过程。有三种常用的动画适合该场景，他们分别是淡入淡出动画、翻牌动画、揭露动画。 淡入淡出动画淡入淡出动画顾名思义是在一个View或者ViewGroup消失时，另外一个View同步显示的动画。本节采用ViewPropertyAnimator实现淡入淡出动画，从Android 3.1 （API level 12）开始支持 ViewPropertyAnimator。这是一个使用淡入淡出动画的例子。 创建views首先，你需要创建两个你需要使用淡入淡出动画的View。下面创建了一个进度指示view和一个可滑动的文本view：12345678910111213141516171819202122232425&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView style=&quot;?android:textAppearanceMedium&quot; android:lineSpacingMultiplier=&quot;1.2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/lorem_ipsum&quot; android:padding=&quot;16dp&quot; /&gt; &lt;/ScrollView&gt; &lt;ProgressBar android:id=&quot;@+id/loading_spinner&quot; style=&quot;?android:progressBarStyleLarge&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; /&gt;&lt;/FrameLayout&gt; 创建淡入淡出动画分为3个步骤：1、创建成员变量以便接下来对其添加动画。2、对于将要淡入的view，提前将visibility属性设置为GONE。这不仅能够避免该view在动画开始之前占用layout空间，同时也避免了不必要的layout计算。3、预先保存config_shortAnimTime属性值。这个属性值表示标准的短暂动画时长，这个时长是很理想的数值对于频繁使用的动画来说。除此之外，还有config_longAnimTime和config_mediumAnimTime可供选择。 下面的代码使用了之前创建的layout作为活动的content view：12345678910111213141516171819202122232425public class CrossfadeActivity extends Activity &#123; private View contentView; private View loadingView; private int shortAnimationDuration; ... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_crossfade); contentView = findViewById(R.id.content); loadingView = findViewById(R.id.loading_spinner); // Initially hide the content view. contentView.setVisibility(View.GONE); // Retrieve and cache the system&apos;s default &quot;short&quot; animation time. shortAnimationDuration = getResources().getInteger( android.R.integer.config_shortAnimTime); &#125; ...&#125; 添加淡入淡出动画最后，我们要实现淡入淡出动画还需要如下3个步骤：1、对于将要淡入的view，设置它的alpha属性为0并且设置visiblity为VISIBLE。（如果你回顾一下，该view之前的visibility为GONE.）这一步让该view处于可见但完全透明的状态。2、对将要淡入的view，让它的透明度从0变化到1。对于将要淡出的view，让它的透明度从1到0。3、在Animator.AnimatorListener的onAnimationEnd()方法中设置淡出view 的 visibility 属性为GONE。注意，虽然该view已经完全透明，但是设置属性visibility为GONE不仅可以阻止该view占用layout空间，同时还避免了不必要的layout计算。下面是这几步的例子：123456789101112131415161718192021222324252627282930313233343536public class CrossfadeActivity extends Activity &#123; private View contentView; private View loadingView; private int shortAnimationDuration; ... private void crossfade() &#123; // Set the content view to 0% opacity but visible, so that it is visible // (but fully transparent) during the animation. contentView.setAlpha(0f); contentView.setVisibility(View.VISIBLE); // Animate the content view to 100% opacity, and clear any animation // listener set on the view. contentView.animate() .alpha(1f) .setDuration(shortAnimationDuration) .setListener(null); // Animate the loading view to 0% opacity. After the animation ends, // set its visibility to GONE as an optimization step (it won&apos;t // participate in layout passes, etc.) loadingView.animate() .alpha(0f) .setDuration(shortAnimationDuration) .setListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; loadingView.setVisibility(View.GONE); &#125; &#125;); &#125;&#125; 翻牌动画该动画适用于在两个view之间实现类似翻牌的动效。本节的翻牌动画借助了FragmentTransaction类的setCustomAnimations方法，该类从Android3.0（API等级11）开始可以调用。当然，你也可以借助其他的方式实现咯。下面是翻牌的样子： 创建Animator object为了创建翻牌动画，你一共需要四个animators。两个分别控制前面的内容（卡片正面）从左边翻出和从左边翻入。同时需要两个animators分别控制后面的内容（卡片反面）从右边翻入和右边翻出。card_flip_left_in.xml123456789101112131415161718192021222324&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- Before rotating, immediately set the alpha to 0. --&gt; &lt;objectAnimator android:valueFrom=&quot;1.0&quot; android:valueTo=&quot;0.0&quot; android:propertyName=&quot;alpha&quot; android:duration=&quot;0&quot; /&gt; &lt;!-- Rotate. --&gt; &lt;objectAnimator android:valueFrom=&quot;-180&quot; android:valueTo=&quot;0&quot; android:propertyName=&quot;rotationY&quot; android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot; android:duration=&quot;@integer/card_flip_time_full&quot; /&gt; &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 1. --&gt; &lt;objectAnimator android:valueFrom=&quot;0.0&quot; android:valueTo=&quot;1.0&quot; android:propertyName=&quot;alpha&quot; android:startOffset=&quot;@integer/card_flip_time_half&quot; android:duration=&quot;1&quot; /&gt;&lt;/set&gt; card_flip_left_out.xml1234567891011121314151617&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- Rotate. --&gt; &lt;objectAnimator android:valueFrom=&quot;0&quot; android:valueTo=&quot;180&quot; android:propertyName=&quot;rotationY&quot; android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot; android:duration=&quot;@integer/card_flip_time_full&quot; /&gt; &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 0. --&gt; &lt;objectAnimator android:valueFrom=&quot;1.0&quot; android:valueTo=&quot;0.0&quot; android:propertyName=&quot;alpha&quot; android:startOffset=&quot;@integer/card_flip_time_half&quot; android:duration=&quot;1&quot; /&gt;&lt;/set&gt; card_flip_right_in.xml123456789101112131415161718192021222324&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- Before rotating, immediately set the alpha to 0. --&gt; &lt;objectAnimator android:valueFrom=&quot;1.0&quot; android:valueTo=&quot;0.0&quot; android:propertyName=&quot;alpha&quot; android:duration=&quot;0&quot; /&gt; &lt;!-- Rotate. --&gt; &lt;objectAnimator android:valueFrom=&quot;180&quot; android:valueTo=&quot;0&quot; android:propertyName=&quot;rotationY&quot; android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot; android:duration=&quot;@integer/card_flip_time_full&quot; /&gt; &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 1. --&gt; &lt;objectAnimator android:valueFrom=&quot;0.0&quot; android:valueTo=&quot;1.0&quot; android:propertyName=&quot;alpha&quot; android:startOffset=&quot;@integer/card_flip_time_half&quot; android:duration=&quot;1&quot; /&gt;&lt;/set&gt; card_flip_right_out.xml1234567891011121314151617&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- Rotate. --&gt; &lt;objectAnimator android:valueFrom=&quot;0&quot; android:valueTo=&quot;-180&quot; android:propertyName=&quot;rotationY&quot; android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot; android:duration=&quot;@integer/card_flip_time_full&quot; /&gt; &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 0. --&gt; &lt;objectAnimator android:valueFrom=&quot;1.0&quot; android:valueTo=&quot;0.0&quot; android:propertyName=&quot;alpha&quot; android:startOffset=&quot;@integer/card_flip_time_half&quot; android:duration=&quot;1&quot; /&gt;&lt;/set&gt; 创建view卡片的正反面是两个独立的layout，方便之后将这两个独立的layout分别绑定到两个frament上。下面是这两个独立的layout之一：1234567891011121314151617181920212223242526&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;#a6c&quot; android:padding=&quot;16dp&quot; android:gravity=&quot;bottom&quot;&gt; &lt;TextView android:id=&quot;@android:id/text1&quot; style=&quot;?android:textAppearanceLarge&quot; android:textStyle=&quot;bold&quot; android:textColor=&quot;#fff&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/card_back_title&quot; /&gt; &lt;TextView style=&quot;?android:textAppearanceSmall&quot; android:textAllCaps=&quot;true&quot; android:textColor=&quot;#80ffffff&quot; android:textStyle=&quot;bold&quot; android:lineSpacingMultiplier=&quot;1.2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/card_back_description&quot; /&gt;&lt;/LinearLayout&gt; 下面是另一个：123456&lt;ImageView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:src=&quot;@drawable/image1&quot; android:scaleType=&quot;centerCrop&quot; android:contentDescription=&quot;@string/description_image_1&quot; /&gt; 创建fragments创建两个fragment作为卡片的正反面，将之前的两个layout分别绑定到这两个frament上。然后将这两个fragment作为FragmentActivity的展示内容，该Activity就是你要展示翻牌动画的页面。下面是两个fragment的定义：123456789101112131415161718192021222324public class CardFlipActivity extends FragmentActivity &#123; ... /** * A fragment representing the front of the card. */ public class CardFrontFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_card_front, container, false); &#125; &#125; /** * A fragment representing the back of the card. */ public class CardBackFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_card_back, container, false); &#125; &#125;&#125; 实现动画现在，你需要在activity中展示这两个fragment的内容。为了实现此需求，你应该为你的activity创建一个layout。下面的例子在此layout中创建了一个FrameLayout作为frament的容器：1234&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 在activity中，将以上的layout设置为content view。然后在activity的oncreate阶段显示卡片的正面内容。下面的例子展示了这一过程：12345678910111213141516public class CardFlipActivity extends FragmentActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_activity_card_flip); if (savedInstanceState == null) &#123; getSupportFragmentManager() .beginTransaction() .add(R.id.container, new CardFrontFragment()) .commit(); &#125; &#125; ...&#125; 现在你已经展示了卡片的正面，接下来要做的就是如何使用翻牌动画翻开卡片的背面，大致需要如下2个步骤：1、在卡片背面内容覆盖卡片正面内容时，将你之前设置好的自定义动画赋值给frament的transitions。2、为fragment增加back stack。这样是为了让用户按返回键时可以回退到上一个frament页面。1234567891011121314151617181920212223242526272829303132333435363738394041424344public class CardFlipActivity extends FragmentActivity &#123; ... private void flipCard() &#123; if (showingBack) &#123; getSupportFragmentManager().popBackStack(); return; &#125; // Flip to the back. showingBack = true; // Create and commit a new fragment transaction that adds the fragment for // the back of the card, uses custom animations, and is part of the fragment // manager&apos;s back stack. getSupportFragmentManager() .beginTransaction() // Replace the default fragment animations with animator resources // representing rotations when switching to the back of the card, as // well as animator resources representing rotations when flipping // back to the front (e.g. when the system Back button is pressed). .setCustomAnimations( R.animator.card_flip_right_in, R.animator.card_flip_right_out, R.animator.card_flip_left_in, R.animator.card_flip_left_out) // Replace any fragments currently in the container view with a // fragment representing the next page (indicated by the // just-incremented currentPage variable). .replace(R.id.container, new CardBackFragment()) // Add this transaction to the back stack, allowing users to press // Back to get to the front of the card. .addToBackStack(null) // Commit the transaction. .commit(); &#125;&#125; 揭露动画揭露动画给用户提供了一种视觉上的延续，当需要显示或者隐藏view时。ViewAnimationUtils.createCircularReveal()方法可以帮助你实现此动画，此方式在Android 5.0（API level 21）以上提供。下面的代码展示了如何使用揭露动画展示初始状态为invisible的view：12345678910111213141516171819202122// previously invisible viewView myView = findViewById(R.id.my_view);// Check if the runtime version is at least Lollipopif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; // get the center for the clipping circle int cx = myView.getWidth() / 2; int cy = myView.getHeight() / 2; // get the final radius for the clipping circle float finalRadius = (float) Math.hypot(cx, cy); // create the animator for this view (the start radius is zero) Animator anim = ViewAnimationUtils.createCircularReveal(myView, cx, cy, 0f, finalRadius); // make the view visible and start the animation myView.setVisibility(View.VISIBLE); anim.start();&#125; else &#123; // set the view to visible without a circular reveal animation below Lollipop myView.setVisibility(View.VISIBLE);&#125; ViewAnimationUtils.createCircularReveal()动画一共有5个参数。第一个参数表示目标view。接下来的两个参数代表了揭露动画开始的圆心坐标。一般地，这通常是目标view的中心点坐标，但是你也可以将它定义为你的手指触摸点的坐标，从而使得揭露动画从你的手指触摸点开始揭露。第四个参数表示动画开始的圆形区域半径。在上面的例子中，初始的圆形半径为0，从而目标view初始状态是隐藏的。最后一个参数代表揭露区域（圆形区域）的最大半径。值得注意的是，最后一个参数必须保证能够完全覆盖你的目标view。下面是使用揭露动画隐藏视图的代码：123456789101112131415161718192021222324252627282930// previously visible viewfinal View myView = findViewById(R.id.my_view);// Check if the runtime version is at least Lollipopif (Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP) &#123; // get the center for the clipping circle int cx = myView.getWidth() / 2; int cy = myView.getHeight() / 2; // get the initial radius for the clipping circle float initialRadius = (float) Math.hypot(cx, cy); // create the animation (the final radius is zero) Animator anim = ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, 0f); // make the view invisible when the animation is done anim.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); myView.setVisibility(View.INVISIBLE); &#125; &#125;); // start the animation anim.start();&#125; else &#123; // set the view to visible without a circular reveal animation below Lollipop myView.setVisibility(View.VISIBLE);&#125; 实例中，揭露动画的初始半径足够覆盖整个目标视图，所以初始时的视图是完全可见的。最终的半径设置为0，则表示动画结束后会隐藏目标视图。注意，当动画结束后要将目标视图的visiblility属性设置为INVISIBLE以提高性能。]]></content>
      <categories>
        <category>Android动画基础</category>
      </categories>
      <tags>
        <tag>淡入淡出动画</tag>
        <tag>翻牌动画</tag>
        <tag>揭露动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android动画（三）：矢量图动画]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8003%EF%BC%9A%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[笔者已将本节的代码上传至Github，大家可以结合着学习。本篇参考了CSDN作者：Mr13_周 的以下三篇文章。1、SVG 的 PathData 在 Android 中的使用2、Android：获取并制作矢量图动画3、Android 矢量图动画（完结篇）在通读完这3篇文章后，笔者在代码实操过程中觉得如下几个问题需要记录一下。 知识一：strokeLineJoin的miter模式 。strokeLineJoin是path标签下的属性，负责线条的拐角形状，包括如下3个属性值：1、miter : 默认值，也就是系统默认使用的。2、round : 圆角式连接。3、bevel：斜角式连接。当线条拐角为 MITER时，拐角处的外缘需要使用延长线来补偿：而这种补偿方案会有一个问题：如果拐角的角度太小，就有可能由于出现连接点过长的情况。比如这样：所以为了避免意料之外的过长的尖角出现， MITER 型连接点有一个额外的规则：当尖角过长时，自动改用 BEVEL 的方式来渲染连接点。例如上图的这个尖角，在默认情况下是不会出现的，而是会由于延长线过长而被转为 BEVEL 型连接点：至于多尖的角才属于过于尖，尖到需要转为使用 BEVEL 来绘制，则是由path标签的属性strokeMiterLimit来设置的。strokeMiterLimit 参数是对于转角长度的限制，具体来讲，是指尖角的外缘端点和内部拐角的距离与线条宽度的比。也就是下面这两个长度的比：这个 strokeMiterLimit 的默认值是 4，对应的是一个大约 29° 的锐角：默认情况下，大于这个角的尖角会被保留，而小于这个夹角的strokeLineJoin就会被自动转换为bevel模式。参考地址&gt;&gt; 知识二：SVG、VectorDrawable、AnimatedVectorDrawable之间的联系。SVG是一种格式，代表矢量图形，类似的有JPG、PNG格式。SVG不能在Android中直接使用。VectorDrawable是Android 5.0系统中引入了来支持矢量图(SVG)的，同时还引入了 AnimatedVectorDrawable 来支持矢量图动画。市场上有很多SVG转VectorDrawable的工具，笔者推荐这个网站，不过需要科学上网哦。参考地址&gt;&gt; 知识三：VectorDrawable的各个标签的属性介绍。如果你喜欢原滋原味的，请查看官方文档。如果喜欢翻译好了的，请移步这篇文章的最后部分。 知识四：对trimPathStart、trimPathEnd、trimPathOffset属性的理解。具体介绍请移步到简书的这篇文章。这里还有一点需要补充，当他们的值n大于1时，实际的值是n-1，比如trimPathStart的值是1.1，那么系统会自动按0.1处理。注意，n不能小于0，否者会将当前path全部修剪。其它的情况，可以下载笔者的代码自己操作一下。 知识五：怎么处理兼容性？Android从5.0版本（API 21）才开始支持矢量图，引入了VectorDrawable（矢量图） 和 AnimatedVectorDrawable（矢量图动画）。对于低版本，官方虽然也给出了兼容方法，但是依然还有很多坑要踩，比如这篇文章所说的。所以笔者建议如果没有强制要求的话，还是把你的app的最低版本支持提高到API 21吧。 知识六：width、height、viewportWidth、viewportHeight属性说明。1、android:width \ android:height:定义矢量图的宽高。2、android:viewportHeight \ android:viewportWidth:定义图像被划分的比例大小。比如width=200dp、viewportWidth=500，即把200dp大小的图像划分成500份，后面Path标签中的坐标，就全部使用的是这里划分后的坐标系统。]]></content>
      <categories>
        <category>Android动画基础</category>
      </categories>
      <tags>
        <tag>AnimationDrawable</tag>
        <tag>AnimatedVectorDrawable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android动画（二）：视图动画、属性动画]]></title>
    <url>%2F2019%2F01%2F25%2F%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8002%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E3%80%81%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[笔者已将本节的代码上传至Github，大家可以结合着学习。本篇以掘金网的Android 动画：这是一份详细 &amp; 清晰的动画学习指南这篇文章为基础，笔者在通读了这篇文章并进行了必要的代码实操后觉得有三个知识点需要补充，所以本篇的任务就是记录下这三个知识点。 知识一：LayoutAnimation的局限性LayoutAnimation只在创建ViewGroup的时候生效，后续添加的子View是没有动画效果的。这和LayoutTransition有很大的区别，在后续介绍布局动画时再展开介绍。 知识二：动画监听方法归类1、转场动画相关Animation.setAnimationListener(Animation.AnimationListener listener);2、属性动画相关Animator.addListener(AnimatorListenerAdapter adapter);Animator.addListener(Animator.AnimatorListener listener);Animator.addPauseListener(Animator.AnimatorPauseListener listener);Animator.addUpdateListener(ValueAnimator.AnimatorUpdateListener listener);3、ViewPropertyAnimator动画相关ViewPropertyAnimator.setListener(AnimatorListenerAdapter adapter);ViewPropertyAnimator.setListener(Animator.AnimatorListener listener);ViewPropertyAnimator.setUpdateListener(AnimatorUpdateListener listener);ViewPropertyAnimator.withEndAction(Runnable runnable);ViewPropertyAnimator.withStartAction(Runnable runnable); 注意 withStartAction() / withEndAction() 是一次性的，在动画执行结束后就自动弃掉了，就算之后再重用 ViewPropertyAnimator 来做别的动画，用它们设置的回调也不会再被调用。而 set/addListener() 所设置的 AnimatorListener 是持续有效的，当动画重复执行时，回调总会被调用。 知识三：AnimationDrawable的使用时机AnimationDrawable的start方法不能在你的Activity的onCreate()中使用，否者会没有效果，因为这个时候AnimationDrawable还没有绑定到窗口。如果你想在进入页面后立即开始动画，可以在你的Activity的onStart()方法中调用。当然，你也可以在交互监听中调用start方法，比如在某个View的onClick()方法中调用。 没错，本篇完结了。]]></content>
      <categories>
        <category>Android动画基础</category>
      </categories>
      <tags>
        <tag>Animation</tag>
        <tag>LayoutAnimation</tag>
        <tag>Animator</tag>
        <tag>ValueAnimator</tag>
        <tag>ObjectAnimator</tag>
        <tag>ViewPropertyAnimator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android动画（一）：坐标、区域、视图层级]]></title>
    <url>%2F2019%2F01%2F15%2F%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8001%EF%BC%9A%E5%9D%90%E6%A0%87%E3%80%81%E5%8C%BA%E5%9F%9F%E3%80%81%E8%A7%86%E5%9B%BE%E5%B1%82%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[笔者已将本节的代码上传至Github，大家可以结合着学习。 坐标event.getX()：表示的是触摸的点距离自身左边界的距离。event.getY()：表示的是触摸的点距离自身上边界的距离。event.getRawX：表示的是触摸点距离屏幕左边界的距离。event.getRawY：表示的是触摸点距离屏幕上边界的距离，包括状态栏。View.getX：表示View左上角相对于父容器的x坐标。View.getY：表示View左上角相对于父容器的y坐标。View.getTranslationX()：计算的是该View在X轴的偏移量。初始值为0，向左偏移值为负，向右偏移值为正。View.getTranslationY()：计算的是该View在Y轴的偏移量。初始值为0，向上偏移为负，向下偏移为正。View.getLocationInWindow(pos)：计算的是view在其父窗口中的坐标位置。View.getLocationOnScreen(pos)：计算的是view在其整个屏幕上的坐标位置。 知识补充1、Android中每个 View 都有一个自己的坐标系，彼此之间是不影响的。这个坐标系的原点是 View 左上角的那个点；水平方向是 x 轴，右正左负；竖直方向是 y 轴，下正上负。查看来源2、如果重写Activity的onTouchEvent(MotionEvent event)方法，这个时候event.getX() 与event.getRawX()获取的值是一样的，event.getY() 与 event.getRawY()获取的值是一样，但是直接触摸状态栏、底部导航栏时的坐标位置不能获得。查看来源3、view.translationX表示view在原来基础上移动多少，view.X表示最终要移动到X轴的哪个位置，view.getX()的值为view.getLeft()与view.getTranslationX()之和。查看来源4、当view是在dialog 或 popupWindow 上显示时，getLocationInWindow获得的值是相对于dialog或者popuwindow左上角的坐标。查看来源1 | 查看来源2 区域我为便于表述，统一把视图大小、视图范围、Android 5.0主题风格的知识都划归到这一部分，大家不必纠结，重点关注每个知识点的概念以及区别。View.getWidth()：表示的是当前控件的宽度，即getRight()-getLeft()。View.getHeight()：表示的是当前控件的高度，即getBottom()-getTop()。View.getTop()：子View的顶部到父View顶部的距离。View.getRight()：子View的右边界到父View的左边界的距离。View.getBottom()：子View的底部到父View的顶部的距离。View.getLeft()：子View的左边界到父View的左边界的距离。View.getGlobalVisibleRect(rect)：得到整体相对于屏幕（包括状态栏）的区域范围rect，这个rect表示当前view的范围。View.getLocalVisibleRect(rect)：得到自己显示的区域，这个区域的坐标是相对自身的，仅仅用来表示自身所占的范围。左上角坐标一直为（0，0），右下角通过计算可得。View.getWindowVisibleDisplayFrame(rect)：获取到程序显示的区域，包括标题栏（ActionBar），不包括状态栏、导航栏、键盘区域(如弹起)。 知识补充1、Android手机获取屏幕分辨率高度因虚拟导航栏带来的问题。2、如何在onCreate方法中获取状态栏，底部导航栏高度？（注意：即使状态栏、底部导航栏被隐藏，他们的高度依然可以按链接中的方法得到。）3、获取View高度的三种方法。 Android 5.0之后的主题风格：1、如果app的标题栏仍是使用 actionbar，则直接在风格 (styles) 或是主题 (themes) 里进行设定 colorPrimary 参数即可；若是采用 toolbar 的话，则要在界面 (layout) 里面设定 toolbar 控件的 background 属性。2、如果在style中设置了statusBarColor，则会覆盖colorPrimaryDark的影响，即：状态栏的颜色将是statusBarColor。 视图层级 getParent：获取上一级容器。getRootView： 获取顶级视图DecorView。getWindow().getDecorView()：获取顶级视图DecorView。findViewById(android.R.id.content)：获取Xml根布局的父容器。可想而知，不包括状态栏、标题栏（ActionBar）、导航栏。对于视图层级，如果要深入了解的话，请参考这篇文章&gt;&gt;。 参考资料1.Android 屏幕坐标系2.得到view坐标的各种方法]]></content>
      <categories>
        <category>Android动画基础</category>
      </categories>
      <tags>
        <tag>坐标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DecimalFormat使用详解]]></title>
    <url>%2F2018%2F08%2F11%2FDecimalFormat%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[产品狗的需求：要求客户端拿到服务器返回的数据后，以最多保留2位小数的形式展示该数据。例如：2.247==&gt;2.25、2.20==&gt;2.2。 拿到这个需求后，当然最先考虑的是使用String.format(&quot;%.2f&quot;, 2.20),可是结果却是：很显然，String.format的形式只能适用于固定的小数保留需求。之后笔者在网上搜索了一圈，发现主要有DecimalFormat、BigDecimal、NumberFormat这几种方案。鉴于它们的功能一样，本文就对DecimalFormat做一番研究。 DecimalFormat 中的 0 和 #12345678910111213141516171819202122232425262728293031323334353637383940import java.text.DecimalFormat;public class DecimalFormatTest&#123;public static void main(String[]args)&#123;DecimalFormat df1,df2;System.out.println(&quot;整数部分0/#的区别&quot;);df1 = new DecimalFormat(&quot;#.00&quot;);df2 = new DecimalFormat(&quot;0.00&quot;);System.out.println(df1.format(0.1)); // .10System.out.println(df2.format(0.1)); // 0.10 System.out.println(&quot;小数部分0/#的区别&quot;);df1 = new DecimalFormat(&quot;0.00&quot;);df2 = new DecimalFormat(&quot;0.##&quot;);System.out.println(df1.format(0.1)); // 0.10System.out.println(df2.format(0.1)); // 0.1System.out.println(df1.format(0.006)); // 0.01System.out.println(df2.format(0.006)); // 0.01System.out.println(&quot;3、整数部分有多位&quot;);df1 = new DecimalFormat(&quot;0.00&quot;);df2 = new DecimalFormat(&quot;#.00&quot;);System.out.println(df1.format(2)); // 2.00System.out.println(df2.format(2)); // 2.00System.out.println(df1.format(20)); // 20.00System.out.println(df2.format(20)); // 20.00System.out.println(df1.format(200)); // 200.00System.out.println(df2.format(200)); // 200.00&#125;&#125; 结论：1、小数部分 #代表最多有几位，0代表必须有且只能有几位。.00 表示最终结果有两位小数,没有则补0，多了就四舍五入第三个小数。.## 表示最终结果最多有两位小数，一位或者没有都可以，多了同样四舍五入第三位。2、整数部分 0 和 #。当整数部分为0时，比如 0.1，# 此时认为整数部分不存在，所以不写 。0 认为没有至少也得一位，写上0。（这跟上面第一部分的表现是一致的：# 有就写，没有就不写；0 必须有，没有就补0。）3、整数部分有多位时： 2；20；200。由上面的结果可以看出 0和#对整数部分多位时的处理是一致的，就是有几位写多少位。（这跟上面两部分的表现是不一致的 在有多位时，0和#都没有匹配位数，而是有多少写多少。）通常，我们使用的处理方式有： 0.00 或者 0.## 。实践：对于问题中的2.247==&gt;2.25、2.20==&gt;2.2，采用DecimalFormat实现如下：1new DecimalFormat(&quot;0.##&quot;).format(dd); 问题延伸1、DecimalFormat对数值格式化的舍入问题——RoundingMode。2、恶心的0.5四舍五入问题。对于此条问题，笔者使用的方式是文中所提及的在具体数据后加上0.000001。3、String.format对于浮点型数据的展示问题。注意在精度要求高的情况下，String.format中使用的浮点数必须是双精度的，这样才能确保四舍五入的规则正确。比如：1System.out.println(String.format(&quot;%.2f&quot;, 2.245f)); 打印的结果是 2.24，错误。如果是这样：1System.out.println(String.format(&quot;%.2f&quot;, 2.245)); 打印的结果就是 2.25，正确。为什么会这样呢？这里涉及到精度损耗的问题。在String.format(&quot;%.2f&quot;, 2.245f)中接受的数值应该是double类型的，所以2.245f 实际上是被转换为了double类型。而 java 将2.245f 强制转化为double类型后，得到的实际double类型值为：2.244999885559082。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>DecimalFormat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由View.post()方法引发的想象]]></title>
    <url>%2F2018%2F07%2F21%2F%E7%94%B1View-post-%E6%96%B9%E6%B3%95%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%B3%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[如题，笔者在想这个标题的时候思考了很久，不知道应该取一个什么样的标题才能涵盖全本篇要涉及的内容。绞尽脑子，最终确定起这个不痛不痒的标题。原因是，写这篇文章之前的一系列相关疑惑就是从View.post()开始的。本篇要探究这么几个问题：1、都知道非静态内部类和匿名类会引发内存泄露，并且我们也知道如何取避免这个问题的发生，但是怎样做得更加完美呢？2、View.Post()中的run方法和Handler.post()方法中的run方法运行线程有什么不同呢？3、View.Post()中的run方法在整个Activity的生命周期的里处在哪个位置呢？好，以上三个问题就是我要总结的重点了。注意，下面对post方法将做的总结，对于postDelay同样适用。 问题一的情况这个问题前面说过我们知道如何去避免它的发生，避免的方法可参考这篇文章。但是，对于真正的生产环境，这些还是不够的。所引文章中所提虽然避免了 Activity 泄漏，不过 Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列MessageQueue 中的消息。下面几个方法都可以移除 Message：123456789public final void removeCallbacks(Runnable r);public final void removeCallbacks(Runnable r, Object token);public final void removeCallbacksAndMessages(Object token);public final void removeMessages(int what);public final void removeMessages(int what, Object object); 以上讨论的内容虽未提及View.post()系列，但是对于View.post()系列同样存在内存泄露的问题，我们可以用同样的方式避免，但是之后我们依然要记住removeCallbacks()噢。 问题二的情况请允许我直接从Stack Overflow粘过来吧(别打我😜)According to the documentation of Handler.postDelayed(Runnable r, long delayMillis): Causes the Runnable r to be added to the message queue, to be run after the specified amount of time elapses. The runnable will be run on the thread to which this handler is attached. On the other hand View.postDelayed(Runnable action, long delayMillis): Causes the Runnable to be added to the message queue, to be run after the specified amount of time elapses. The runnable will be run on the user interface thread. 问题三的情况探究这个问题主要是为了以后在post(new Runnable(){……})的run方法中写逻辑时，可以清晰的知道它在Activity的生命周期中所处的位置（这是很必要的，比如AnimationDrawable的start()方法只能在onStart()中或者之后执行才有效）。为了验证，我们直接上代码吧：123456789101112131415161718192021222324252627282930313233343536373839404142@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);tvContent=findViewById(R.id.tvContent);tvContent.post(new Runnable() &#123;@Overridepublic void run() &#123;Log.d(TAG, &quot;run&quot;);&#125;&#125;);&#125;@Overrideprotected void onStart() &#123;super.onStart();Log.d(TAG, &quot;onStart&quot;);&#125;@Overrideprotected void onStop() &#123;super.onStop();Log.d(TAG, &quot;onStop&quot;);&#125;@Overrideprotected void onPause() &#123;super.onPause();Log.d(TAG, &quot;onPause&quot;);&#125;@Overrideprotected void onResume() &#123;super.onResume();Log.d(TAG, &quot;onResume&quot;);&#125;@Overridepublic void onAttachedToWindow() &#123;super.onAttachedToWindow();Log.d(TAG, &quot;onAttachedToWindow&quot;);&#125;@Overrideprotected void onDestroy() &#123;super.onDestroy();Log.d(TAG, &quot;onDestroy&quot;);&#125; 代码很简单，这里不多解释了，直接看运行结果吧：1234onStartonResumeonAttachedToWindowrun 结论很明显了，此时的run方法处在onAttachedToWindow方法之后。题外话，对于onAttachedToWindow方法Google的解释是下面这样的： This is called when the view is attached to a window. At this point it has a Surface and will start drawing. Note that this function is guaranteed to be called before onDraw(android.graphics.Canvas), however it may be called any time before the first onDraw – including before or after onMeasure(int, int).If you override this method you must call through to the superclass implementation. 大概意思是onAttachedToWindow可以保证在首个ondraw方法调用前被调用。因此，我们可以很放心地将一些绘制之前的初始化操作放在onAttachedToWindow里面。 问题延伸我知道问题已经很杂了，既然标题是[**引发的想象]，那么请允许我发挥想象吧😄。这个问题是：对于Application，Service，Activity三者的Context的应用场景是怎样的呢？直接盗用一张图吧：其中： NO1表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建。]]></content>
      <categories>
        <category>Android 其它</category>
      </categories>
      <tags>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android演化历史]]></title>
    <url>%2F2018%2F06%2F21%2FAndroid%E5%90%84%E7%89%88%E6%9C%AC%E4%BB%A3%E5%8F%B7%E3%80%81%E7%89%88%E6%9C%AC%E5%8F%B7%E3%80%81API%E7%BA%A7%E5%88%AB%E3%80%81%E5%8F%91%E5%B8%83%E6%97%B6%E9%97%B4%E5%AF%B9%E7%85%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Android开发过程中，经常会遇到类似于这个版本号对应的API级别是多少？这个API级别对应的版本号是多少？这样的问题。本文就以此为出发点，详细的介绍一下Android的版本演化进程。一是为了下次再遇到前面说的问题时能够快速查找本文得到答案，二是让自己对Android发展历程有一个清晰的思路。 对照表 版本号 API级别 代号 发布时间 Android 9.0 28 P 2018-3 Android 8.1 27 Oreo Android 8.0 26 Oreo 2017-3 Android 7.1.1 25 Nougat 2016-10 Android 7.0 24 Nougat 2016-08 Android 6.0 23 Marshmallow 2015-10 Android 5.1 22 Lollipop 2015-03 Android 5.0 21 Lollipop 2014-11 Android 4.4W 20 KitKat 2014-06 Android 4.4 19 KitKat 2013-10 Android 4.3 18 Jelly Bean 2013-07 Android 4.2 17 Jelly Bean 2012-11 Android 4.1 16 Jelly Bean 2012-07 Android 4.0.3 15 Ice Cream Sandwich 2011-12 Android 4.0 14 Ice Cream Sandwich 2011-10 Android 3.2 13 Honeycomb 2011-07 Android 3.1 12 Honeycomb 2011-05 Android 3.0 11 Honeycomb 2011-02 Android 2.3.3 10 Gingerbread 2011-02 Android 2.3 9 Gingerbread 2010-12 Android 2.2 8 Froyo 2010-05 Android 2.1 7 Eclair 2010-01 Android 2.0.1 6 Eclair 2009-12 Android 2.0 5 Eclair 2009-10 Android 1.6 4 Donut 2009-09 Android 1.5 3 Cupcake 2009-04 Android 1.1 2 2009-02 Android 1.0 1 2008-09 Android重要历史版本功能Android 7.0 多语言区域支持，更多语言 多窗口支持 新增的表情符号see more>> Android 6.0 运行时权限及其管理 低电耗模式和应用待机模式 文本选择 WLAN 和网络连接变更 指纹身份验证 主题化 ColorStateListsee more>> Android 5.0 Material Design 全新的通知中心设计 支持64位ART虚拟机see more>> Android 4.4 全屏沉浸模式 透明系统 UI 样式 用于动画场景的转场框架 屏幕录制 步测器和计步器see more>> 参考资料Android平台版本对比]]></content>
      <categories>
        <category>Android 其它</category>
      </categories>
      <tags>
        <tag>Android演化历史</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecycleView探究（一）：添加头尾布局]]></title>
    <url>%2F2018%2F05%2F20%2FRecycleView%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%A4%B4%E5%B0%BE%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[笔者使用RecycleView也有一段时间了，每次遇到需要为RecycleView添加头尾布局的时候，都会是一阵头疼。之前我的做法是直接给依赖的实体集合添加头尾类型的Item Data。打脸的说，这是在赶需求的一种无赖做法。得益于最近项目不是很紧张，所以抽个周末的时间好好研究一下这一块的知识。言归正传，本篇文章我要实现的效果是简洁高效地为RecycleView无限增加头尾布局。 具体思路如下1、新建一个HeaderFooterWrapAdapter装饰类，它继承于RecycleView.Adapter，负责拓展普通RecycleView.Adapter对象（被装饰对象）的功能。2、在onCreateViewHolder、onBindViewHolder、getItemViewType、getItemCount这几个方法区分有无头尾布局。如果没有头尾布局，一律按照被装饰对象的逻辑处理。3、在onAttachedToRecyclerView方法内，做好GridView的适配。 下面我们就把以上的思路转化成可爱的代码吧。一、我们应该让HeaderFooterWrapAdapter继承自RecycleView.Adapter,并且定义好需要的成员对象。123456public class HeaderFooterWrapAdapter extends RecyclerView.Adapter &#123;RecyclerView.Adapter adapter;//被装饰对象private List&lt;View&gt; headerViews = new ArrayList&lt;&gt;();private List&lt;View&gt; footerViews = new ArrayList&lt;&gt;();……&#125; 二、重写RecyclerView.Adapter中几个重要的方法。 1、判断item个数。1234567891011121314@Overridepublic int getItemCount() &#123;if (headerViews.size() != 0 &amp;&amp; footerViews.size() != 0)//同时加了头部和尾部&#123;return adapter.getItemCount() + headerViews.size() + footerViews.size();&#125; else if (headerViews.size() != 0) &#123; //只有头部return adapter.getItemCount() + headerViews.size();&#125; else if (footerViews.size() != 0) //只有尾部&#123;return adapter.getItemCount() + footerViews.size();&#125; else &#123;return adapter.getItemCount();&#125;&#125; 2、区分Item类型。1234567891011121314@Overridepublic int getItemViewType(int position) &#123;if (headerViews.size() != 0) &#123;if (position &gt;= 0 &amp;&amp; position &lt; headerViews.size()) &#123;return headerViews.get(position).hashCode();&#125;&#125;if (footerViews.size() != 0) &#123;int i = position - headerViews.size() - adapter.getItemCount();if (i &gt;= 0)return footerViews.get(i).hashCode();&#125;return 0;&#125; 3、创建Item。 12345678910111213public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;for (View headerView : headerViews) &#123;if (headerView.hashCode() == viewType) &#123;return new HeaderViewHolder(headerView);&#125;&#125;for (View footerview : footerViews) &#123;if (footerview.hashCode() == viewType) &#123;return new FooterViewHolder(footerview);&#125;&#125;return adapter.onCreateViewHolder(parent, viewType);&#125; 4、绑定数据。1234567891011121314151617181920@Overridepublic void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) &#123;if (headerViews.size() != 0 &amp;&amp; footerViews.size() != 0)//同时加了头部和尾部&#123;if (position &gt;= headerViews.size() &amp;&amp; position &lt; headerViews.size() + adapter.getItemCount()) &#123;adapter.onBindViewHolder(holder, position - headerViews.size());&#125;&#125; else if (headerViews.size() != 0) &#123; //只有头部if (position &gt;= headerViews.size()) &#123;adapter.onBindViewHolder(holder, position - headerViews.size());&#125;&#125; else if (footerViews.size() != 0) //只有尾部&#123;if (position &gt;= 0 &amp;&amp; position &lt; adapter.getItemCount()) &#123;adapter.onBindViewHolder(holder, position);&#125;&#125; else &#123;adapter.onBindViewHolder(holder, position);&#125;&#125; 三、接下来适配GridView，这里主要是通过GridLayoutManager的setSpanSizeLookup方法动态处理头尾布局。 1234567891011121314151617181920212223242526272829303132@Overridepublic void onAttachedToRecyclerView(@NonNull RecyclerView recyclerView) &#123;super.onAttachedToRecyclerView(recyclerView);final RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();if (layoutManager instanceof GridLayoutManager) &#123;((GridLayoutManager) layoutManager).setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123;@Overridepublic int getSpanSize(int position) &#123;if (headerViews.size() != 0 &amp;&amp; footerViews.size() != 0) &#123;if (position &gt;= 0 &amp;&amp; position &lt; headerViews.size()) &#123;return ((GridLayoutManager) layoutManager).getSpanCount();&#125; else if (position &gt;= getItemCount() - footerViews.size() &amp;&amp; position &lt; getItemCount()) &#123;return ((GridLayoutManager) layoutManager).getSpanCount();&#125; else &#123;return 1;&#125;&#125; else if (headerViews.size() != 0) &#123;if (position &gt;= 0 &amp;&amp; position &lt; headerViews.size()) &#123;return ((GridLayoutManager) layoutManager).getSpanCount();&#125;return 1;&#125; else if (footerViews.size() != 0) &#123;if (position &gt;= getItemCount() - footerViews.size() &amp;&amp; position &lt; getItemCount()) &#123;return ((GridLayoutManager) layoutManager).getSpanCount();&#125;return 1;&#125;return 1;&#125;&#125;);&#125;&#125; 四、定义添加头部和尾部布局的公开方法。 12345678910//添加头布局public void addHeaderView(View headerView) &#123;this.headerViews.add(headerView);notifyItemInserted(headerViews.size() - 1);&#125;//添加尾布局public void addFooterView(View footerView) &#123;this.footerViews.add(footerView);notifyItemInserted(headerViews.size() + adapter.getItemCount() + footerViews.size() - 1);&#125; 好了，以上就是为RecycleView添加头尾布局的核心代码。调用方式也很简单，伪代码如下。12345678910MyAdapter myAdapter=....;....HeaderFooterWrapAdapter headerFooterWrapAdapter=new HeaderFooterWrapAdapter(myAdapter);headerFooterWrapAdapter.addFooterView(footerView01);headerFooterWrapAdapter.addFooterView(footerView02);headerFooterWrapAdapter.addFooterView(footerView03);headerFooterWrapAdapter.addHeaderView(headerView01);headerFooterWrapAdapter.addHeaderView(headerView02);headerFooterWrapAdapter.addHeaderView(headerView03);....... 这里有一点需要注意就是Inflate创建headerView或者footerView时，parent需要传入recyclerView对象才能时布局的顶层属性起效果,例如：1View footerView = LayoutInflater.from(this).inflate(R.layout.footerview, rcv, false); 关于inflate的使用技巧，可以参考一下这篇文章。最后，再贴一张实现的效果图片吧～ 参考资料学会自己给RecyclerView添加Header、Footer和加载更多回调]]></content>
      <categories>
        <category>Android View</category>
      </categories>
      <tags>
        <tag>RecycleView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PopupWindow使用教程]]></title>
    <url>%2F2018%2F04%2F29%2FPopupWindow%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[PopupWindow是android.widget中一个弹框控件，与普通dialog相比，它的优势在于可以任意改变其在界面中的位置。本篇我们就来好好研究一下它的用法吧。 创建PopupWindow有两种创建方式：1、通过视图创建，这是最常用的方法。12345678910PopupWindow () // 创建一个空的PopupWindowPopupWindow (View contentView) PopupWindow (int width, int height)PopupWindow (View contentView, // PopupWindow的内容View, 相当于setContentViewint width, // 宽, 相当于setwidth()int height,// 高, 相当于setHeightboolean focusable)//是否可获取焦点, 相当于setFocusable() 2、通过上下文创建，一般不使用。12345678910111213PopupWindow (Context context)PopupWindow (Context context, AttributeSet attrs)PopupWindow (Context context, AttributeSet attrs, int defStyleAttr)PopupWindow (Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) 创建PopuWindow必要的三个条件:void setHeight (int height) // 因为PopupWindow没有默认布局所以必须指定宽高void setWidth (int width)void setContentView (View contentView) // 需要显示的内容 注意PopupWindow指定宽高时用LayoutParams.WRAP_CONTENT包裹布局， 这时并不总是布局多大就显示多大，估计是BUG吧。所以遇到这种情况，具体的PopupWindow大小我们还是需要手动计算。 显示显示PopupWindow可以分为两种方式: 1、附着某个控件showAsDropDown。默认是PopupWindow的左上角对其控件的左下角,或者设置Gravity.RIGHT, PopupWindow的右上角对齐控件的右下角。不存在Gravity.TOP或Gravity.BOTTOM效果。12345void showAsDropDown (View anchor) //弹窗显示在anchor控件左下方void showAsDropDown (View anchor, int xoff, int yoff)//以控件左下角为原点的偏移坐标void showAsDropDown (View anchor,int xoff,int yoff,int gravity) //弹窗显示在控件的左下方还是右下方, 参数Gravity.RIGHT/Gravity.LEFT. 默认是左下方 2、设置屏幕坐标showAtLocation。当前窗口的任意位置(setClippingEnabled设置为ture时，不包括状态栏。)12345void showAtLocation (View parent, //只要是屏幕上任意控件对象即可int gravity, //屏幕位置int x, //偏移坐标int y) parent:该属性只要是当前任意控件对象即可(View和ViewGroup都行), 官方文档介绍该对象参数主要是为了得到该对象的getWindowToken()方法。需要注意的是多次调用show方法只会执行第一句1234mPopupWindow.showAtLocation(popupwindow, Gravity.TOP, 100, 0); // 只有该行生效mPopupWindow.showAtLocation(popupwindow, Gravity.LEFT, 100, 0);mPopupWindow.showAtLocation(popupwindow, Gravity.RIGHT, 100, 0);mPopupWindow.showAtLocation(popupwindow, Gravity.BOTTOM, 100, 0); 隐藏PopupWindow1void dismiss () 状态外部被点击取消如果为true点击PopupWindow外部区域可以取消PopupWindow1void setOutsideTouchable (boolean touchable) // 设置外部是否可被点击 但是在android6.0以下还是无法点击外部取消Popupwindow. 可以通过设置背景来解决这个Bug。1mPopupWindow.setBackgroundDrawable(new BitmapDrawable()); 解决NavigationBar重叠这是Android5.0(API22)后添加的方法, 默认为true，为true时将不会与导航栏重叠。1void setAttachedInDecor (boolean enabled) 可获取焦点一般控件都不需要焦点，但是输入框EditText需要先获取焦点才能输入。 最重要的是当PopupWindow可获取焦点时按下手机返回键将不会销毁当前Activity而是关闭当前PopupWindow。所以我们一般还是设置为true， 更加符合用户操作逻辑。该方法为true时同时拥有setOutsideTouchable(true)的作用。1void setFocusable (boolean focusable) 遮盖附着View1void setOverlapAnchor (boolean overlapAnchor) PopupWindow对齐方式从View anchor的左下角变成了左上角了。 窗口裁剪PopupWindow默认是不会超出屏幕边界的. 但是如果该方法为false时会采用精准位置, 能超出屏幕范围.1void setClippingEnabled (boolean enabled) 动画效果设置动画可以设置popupWindow的显示和隐藏动画。1void setAnimationStyle (int animationStyle) 可以看到方法是传入一个Style的样式id，示例:1234&lt;style name=&quot;popupwindow_anim_style&quot;&gt;&lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/dialog_bottom_enter&lt;/item&gt;&lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/dialog_bottom_exit&lt;/item&gt;&lt;/style&gt; 分别由两个属性组成. 两个属性各代表一个anim动画文件. 进入和退出动画这是在Android6.0(API 23)后加入的方法. 配合Material Design的转场动画使用.进入动画1void setEnterTransition (Transition enterTransition) 退出动画1void setExitTransition (Transition exitTransition) 输入模式针对PopupWindow中包含EditText控件. 输入模式1void setInputMethodMode (int mode) 支持三种模式：1、INPUT_METHOD_FROM_FOCUSABLE 根据可否获取焦点判断是否可输入2、INPUT_METHOD_NEEDED 允许输入3、INPUT_METHOD_NOT_NEEDED 不允许输入 软键盘模式1void setSoftInputMode (int mode) // mode为WindowManager.LayoutParams的softInputMode常量 softInputMode包含九种取值, 可组合使用,分为两类:显示状态模式 SOFT_INPUT_STATE_UNSPECIFIED 默认模式 SOFT_INPUT_STATE_HIDDEN SOFT_INPUT_STATE_ALWAYS_HIDDEN 总是隐藏 SOFT_INPUT_STATE_UNCHANGED SOFT_INPUT_STATE_VISIBLE SOFT_INPUT_STATE_ALWAYS_VISIBLE 自动弹出软键盘 调整模式 SOFT_INPUT_ADJUST_UNSPECIFIED 默认模式 SOFT_INPUT_ADJUST_RESIZE 软键盘弹出后PopupWindow会自动调整坐标,不被遮挡 SOFT_INPUT_ADJUST_PAN 监听事件隐藏事件监听即PopupWindow执行dismiss()后回调的方法。1void setOnDismissListener (PopupWindow.OnDismissListener onDismissListener) 触摸事件拦截1void setTouchInterceptor (View.OnTouchListener l) 更新以下的更新PopupWindow都必须在PopupWindow处于以及被显示的状态下才行，且PopupWindow的宽高设置都必须大于等于0， 如果想忽略PopupWindow的宽高设置就设为-1。 更新状态该方法不能更新PopupWindow的宽高, 只能更新PopupWindow的状态. 例如更新Focusable和OutsideTouchable。1void update () 更新尺寸上面说过update()不能更新PopupWindow的宽高, 但是提供更新宽高的update方法。12void update (int width, // 更新PopupWindow的宽高int height) 更新显示位置该方法是相当于重新showAsDropDown, 所以这是相对于控件的位置更新123456789void update (View anchor, // 更新显示控件的位置int width, int height)void update (View anchor, int xoff, // 相对于控件的偏移值int yoff, int width, int height) 相对位置更新相对于当前的位置进行偏移， 不同的显示位置对于的相对原点也不同。showAsDropDown的相对原点是整个屏幕左上角, 包括状态栏。所以由于包括状态栏所以坐标偏移的时候一定要y轴偏移大于60超出状态栏的高度。 否则因为遮挡状态栏导致PopupWindow无法显示.1mPopupWindow.update(50, 60, -1,-1); // x轴偏移50 showAtLocation的相对原点是自身位置。12345678910void update (int x, // 坐标偏移int y, int width, // PopupWindow宽高int height)void update (int x, int y, int width, int height, boolean force) // 可获取焦点 背景变灰当我们弹出PopupWindow时，有时希望背景能够变成灰色，那我们可以通过以下方式实现。1234567891011/*** 设置添加屏幕的背景透明度* * @param bgAlpha 屏幕透明度0.0-1.0 1表示完全不透明* */public void setBackgroundAlpha(float bgAlpha) &#123;WindowManager.LayoutParams lp = ((Activity) mContext).getWindow().getAttributes();lp.alpha = bgAlpha;((Activity) mContext).getWindow().setAttributes(lp);&#125; 参考资料PopupWindow最全使用说明]]></content>
      <categories>
        <category>Android View</category>
      </categories>
      <tags>
        <tag>PopupWindow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java枚举用法总结]]></title>
    <url>%2F2018%2F03%2F24%2FJava%E6%9E%9A%E4%B8%BE%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[枚举是JDK1.5引入的新类型，可以说是一个小功能，但是它却给我们的程序开发带来了极大的便捷，本文就对它的用法做一个小结。 常量在JDK 1.5之前，我们定义常量都是public final static ……，这种定义方式有一个很大的弊端就是代码紊乱，需要大量的注释。有了枚举类型，事情就好办了。比如我们要定义一组颜色常量，可以这样：123public enum Color&#123;WHITE,BLACK,RED&#125; 是不是很清晰了呢，除了会使代码结构清晰之外，枚举还提供了许多便捷的操作…… Switch12345678910111213141516171819enum Signal &#123; GREEN, YELLOW, RED &#125; public class TrafficLight &#123; Signal color = Signal.RED; public void change() &#123; switch (color) &#123; case RED: color = Signal.GREEN; break; case YELLOW: color = Signal.RED; break; case GREEN: color = Signal.YELLOW; break; &#125; &#125; &#125; 向枚举中添加新方法枚举中可以自定义方法，但是必须保证先定义枚举的实例，并且在最后一个实例后面用分号结尾。123456789101112131415161718192021222324252627282930313233public enum Color &#123; RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; // 普通方法 public static String getName(int index) &#123; for (Color c : Color.values()) &#123; if (c.getIndex() == index) &#123; return c.name; &#125; &#125; return null; &#125; // get set 方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125; &#125; 补充枚举有两个默认的方法，name()、ordinal()方法。前者可以理解为是枚举实例的名称。后者理解为枚举的编号，从0递增。 覆盖枚举的方法下面给出覆盖toString()方法的例子。12345678910111213141516public enum Color &#123; RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; //覆盖方法 @Override public String toString() &#123; return this.index+&quot;_&quot;+this.name; &#125; &#125; 实现接口所有枚举都自动继承自java.lang.Enum类。由于Java不支持多继承，所以我们不能将枚举类继承其它的类，但是枚举类可以实现多个接口。12345678910111213141516171819202122232425public interface Behaviour &#123; void print(); String getInfo(); &#125; public enum Color implements Behaviour&#123; RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; //接口方法 @Override public String getInfo() &#123; return this.name; &#125; //接口方法 @Override public void print() &#123; System.out.println(this.index+&quot;:&quot;+this.name); &#125; &#125; 使用接口组织枚举有时候我们需要在一个文件中统一管理常量话，可以使用接口组织枚举。12345678public interface Food &#123; enum Coffee implements Food&#123; BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO &#125; enum Dessert implements Food&#123; FRUIT, CAKE, GELATO &#125; &#125; 参考资料Java 枚举(enum) 详解7种常见的用法]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池]]></title>
    <url>%2F2018%2F03%2F13%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[在面向对象编程中，创建和销毁对象是很耗时间和资源的，因此，在多线程编程过程中如果能减少线程的创建和销毁操作，那么对于程序的性能将得到很大的提高。Java线程池的出现，解决了这个问题。不仅如此，线程池还可以控制线程的创建数量，避免内存消耗过多。学习线程池，需要用到以下几个关键类。1、Executor2、Executors3、ExecutorSevice4、ThreadPoolExecutor在分别介绍它们之前，让我们先捋清一下它们之间的关系。图中的AbstractExecutorService类可以不用理会，我们不讲它。另外，Excutors类不好在UML类图中将其涵盖进去，等会我们再介绍。 Executor查看Executor的API，有这么一段话： The Executor implementations provided in this package implement ExecutorService, which is a more extensive interface. The ThreadPoolExecutor class provides an extensible thread pool implementation. The Executors class provides convenient factory methods for these Executors. 大概意思是，ExecutorService接口在Executor接口的基础上又拓展了一些功能；而ThreadPoolExecutor类提供了一个可拓展的线程池实现；Executors类是一个工厂类，它为Executor类的实现提供了便捷的通道。这里我们注意到了之前提到的Executors类，它是一个工厂方法，用来产生Executor对象。123456Executor excutor = Executors.newFixedThreadPool(10); excutor.execute(new Runnable() &#123; public void run() &#123; System.out.println(&quot;Asynchronous task&quot;); &#125; &#125;); 注意以上是一个异步任务。同时，除了可以使用newFixedThreadPool创建Executor对象之外还可以使用12Executors.newSingleThreadExecutor(); Executors.newScheduledThreadPool(size); 生产Executor对象，具体用法之后会介绍。 ExecutorSevice如上所提，ExecutorSevice实际上只是比Executor多了一些方法而已，它同样可以通过Executors提供的工厂方法创造出来。1ExecutorSevice executorService = Executors.newFixedThreadPool(10); 除了execute()，ExecutorSevice提供了允许返回任务执行结果的submit()，返回结果的方式有两种：1、传入Runnable对象。123456Future&lt;String&gt; future=executor.submit(new Runnable() &#123;@Overridepublic void run() &#123;System.out.println(&quot;Asynchronous task&quot;);&#125;&#125;); 2、传入Callable对象。1234567Future&lt;String&gt; future = executor.submit(new Callable&lt;String&gt;() &#123;@Overridepublic String call() throws Exception &#123;System.out.println(&quot;Asynchronous task&quot;);return &quot;result&quot;;&#125;&#125;); 这个两种方式都可以通过future.get（）获得返回的结果，并且future.get（）是一个阻塞方法。不同的是，Runnable方式的返回值始终为null，Callable方式的返回值将取决于用户的设定。特别地，ExecutorSevice还提供了可以处理Callable集合的方法invokeAny和invokeAll,具体用法可以参考这一篇文章。将invokeAll运用在需要并行运行的场景，可以减少比较多的方法执行时间。比如：方法A和方法B分别都执行了一些耗时操作，而我们最后的值依赖于这两个方法的执行结果。那么第一种方法是让A、B串行执行，第二种方法是将A、B逻辑分别设置为callable对象，之后通过invokeAll并行执行它俩，实验结果是第二种方法优于第一种方法的实现。 ThreadPoolExecutorThreadPoolExecutor支持通过调整构造参数来配置不同的处理策略，下面主要介绍一下常用的策略配置方法以及应用场景。 ThreadPoolExecutor 的处理逻辑首先看一下 ThreadPoolExecutor 构造函数的定义：1234567public ThreadPoolExecutor(int corePoolSize, //线程池核心线程数量int maximumPoolSize, //线程池最大线程数量long keepAliveTime, //线程KeepAlive时间，当线程池数量超过核心线程数量以后，idle时间超过这个值的线程会被终止TimeUnit unit, //线程KeepAlive时间单位BlockingQueue&lt;Runnable&gt; workQueue, //任务队列ThreadFactory threadFactory, //创建线程的工厂对象RejectedExecutionHandler handler) //任务被拒绝后调用的handler ThreadPoolExecutor 对线程池和队列的使用方式如下：1、从线程池中获取可用线程执行任务，如果没有可用线程则使用ThreadFactory创建新的线程，直到线程数达到corePoolSize限制；2、线程池线程数达到corePoolSize以后，新的任务将被放入队列，直到队列不能再容纳更多的任务；3、当队列不能再容纳更多的任务以后，会创建新的线程，直到线程数达到maxinumPoolSize限制；4、线程数达到maxinumPoolSize限制以后新任务会被拒绝执行，调用 RejectedExecutionHandler 进行处理。 三种常用的 ThreadPoolExecutorExecutors 是提供了一组工厂方法用于创建常用的 ExecutorService ，分别是 FixedThreadPool，CachedThreadPool 以及 SingleThreadExecutor。这三种ThreadPoolExecutor都是调用 ThreadPoolExecutor 构造函数进行创建，区别在于参数不同。1、FixedThreadPool - 线程池大小固定，任务队列无界。下面是 Executors 类 newFixedThreadPool 方法的源码：12345public static ExecutorService newFixedThreadPool(int nThreads) &#123;return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 可以看到 corePoolSize 和 maximumPoolSize 设置成了相同的值，此时不存在线程数量大于核心线程数量的情况，所以KeepAlive时间设置不会生效。任务队列使用的是不限制大小的 LinkedBlockingQueue ，由于是无界队列所以容纳的任务数量没有上限。因此，FixedThreadPool的行为如下：1、从线程池中获取可用线程执行任务，如果没有可用线程则使用ThreadFactory创建新的线程，直到线程数达到nThreads；2、线程池线程数达到nThreads以后，新的任务将被放入队列。FixedThreadPool的优点是能够保证所有的任务都被执行，永远不会拒绝新的任务；同时缺点是队列数量没有限制，在任务执行时间无限延长的这种极端情况下会造成内存问题。2、SingleThreadExecutor - 线程池大小固定为1，任务队列无界123456public static ExecutorService newSingleThreadExecutor() &#123;return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 这个工厂方法中使用无界LinkedBlockingQueue，并的将线程数设置成1。虽然是单线程处理，一旦线程因为处理异常等原因终止的时候，ThreadPoolExecutor会自动创建一个新的线程继续进行工作。SingleThreadExecutor 适用于在逻辑上需要单线程处理任务的场景，同时无界的LinkedBlockingQueue保证新任务都能够放入队列，不会被拒绝；缺点和FixedThreadPool相同，当处理任务无限等待的时候会造成内存问题。3、CachedThreadPool - 线程池无限大（MAX INT），等待队列长度为112345public static ExecutorService newCachedThreadPool() &#123;return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;());&#125; SynchronousQueue是一个只有1个元素的队列，入队的任务需要一直等待直到队列中的元素被移出。核心线程数是0，意味着所有任务会先入队列；最大线程数是Integer.MAX_VALUE，可以认为线程数量是没有限制的。KeepAlive时间被设置成60秒，意味着在没有任务的时候超过核心线程数的线程等待60秒以后退出。CachedThreadPool对任务的处理策略是提交的任务会立即分配一个线程进行执行，线程池中线程数量会随着任务数的变化自动扩张和缩减，在任务执行时间无限延长的极端情况下会创建过多的线程。 说明：实验证明，当超过核心线程数后，线程池的机制是尽量重用还在KeepAlive时间内的线程。 参考资料ThreadPoolExecutor策略配置以及应用场景]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android图片压缩方略]]></title>
    <url>%2F2018%2F02%2F22%2FAndroid%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E6%96%B9%E7%95%A5%2F</url>
    <content type="text"><![CDATA[我们通常采用多种方式结合的方法实现图片压缩需求，这些方式包括质量压缩、尺寸压缩。本章将分别介绍这两种方式，并且最后将结合这两种方式实现图片压缩的最优解决方案。 质量压缩设置bitmap options属性，降低图片的质量，但像素不会减少，options 属性的值为0-100，来实现压缩。123456789101112131415public static void compressImageToFile(Bitmap bmp,File file) &#123;// 0-100 100为不压缩int options = 100; ByteArrayOutputStream baos = new ByteArrayOutputStream();// 把压缩后的数据存放到baos中bmp.compress(Bitmap.CompressFormat.JPEG, options, baos);try &#123; FileOutputStream fos = new FileOutputStream(file); fos.write(baos.toByteArray()); fos.flush(); fos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 尺寸压缩通过缩放图片像素来减少图片所占内存。123456789101112131415161718192021public static void compressBitmapToFile(Bitmap bmp, File file)&#123;// 尺寸压缩倍数,值越大，图片尺寸越小int ratio = 2;// 压缩Bitmap到对应尺寸Bitmap result = Bitmap.createBitmap(bmp.getWidth() / ratio, bmp.getHeight() / ratio, Config.ARGB_8888);Canvas canvas = new Canvas(result);Rect rect = new Rect(0, 0, bmp.getWidth() / ratio, bmp.getHeight() / ratio);canvas.drawBitmap(bmp, null, rect, null);ByteArrayOutputStream baos = new ByteArrayOutputStream();// 把压缩后的数据存放到baos中result.compress(Bitmap.CompressFormat.JPEG, 100 ,baos);try &#123; FileOutputStream fos = new FileOutputStream(file); fos.write(baos.toByteArray()); fos.flush(); fos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 设置图片采样率，减少图片像素。12345678910111213141516171819public static void compressBitmap(String filePath, File file)&#123;// 数值越高，图片像素越低int inSampleSize = 2;BitmapFactory.Options options = new BitmapFactory.Options();//采样率options.inSampleSize = inSampleSize;Bitmap bitmap = BitmapFactory.decodeFile(filePath, options); ByteArrayOutputStream baos = new ByteArrayOutputStream();// 把压缩后的数据存放到baos中bitmap.compress(Bitmap.CompressFormat.JPEG, 100 ,baos);try &#123; FileOutputStream fos = new FileOutputStream(file); fos.write(baos.toByteArray()); fos.flush(); fos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 小知识1、文件大小换算公式：1Byte=8bit1KB=1024Byte(字节)=8*1024bit1MB=1024KB1GB=1024MB1TB=1024GB2、图像占用内存空间的大小：分辨率 * 位深 ／ 8分辨率：宽 * 高位深度：指定图像中的每个像素可以使用的颜色信息数量。每个像素使用的信息位数越多，可用的颜色就越多，颜色表现就更逼真。例如：一幅图像分辨率：1024*768,24位，则其大小计算如下：大小 = 1024 * 768 * 24 / 8 = 2359296 byte = 2304 KB 最佳实践实际使用过程中，首先是将图片的尺寸压缩到一定大小，然后降低图片的质量到特定的内存要求。1234567891011121314151617Bitmap obtainBitmap() &#123;Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.imag);Bitmap bg = Bitmap.createBitmap(bitmap.getWidth() / 2, bitmap.getHeight() / 2, Bitmap.Config.ARGB_8888);Canvas canvas = new Canvas(bg);Rect rect = new Rect(0, 0, bitmap.getWidth() / 2, bitmap.getHeight() / 2);canvas.drawBitmap(bitmap, null, rect, null);ByteArrayOutputStream outputStream = new ByteArrayOutputStream();int quality = 100;//直到图片的大小小于100kbdo &#123;outputStream.reset();bg.compress(Bitmap.CompressFormat.JPEG, quality, outputStream);quality = quality - 3;&#125; while (outputStream.toByteArray().length / 1024 &gt;= 100 &amp;&amp; quality &gt; 0);Bitmap result = BitmapFactory.decodeByteArray(outputStream.toByteArray(), 0, outputStream.size());return result;&#125; 参考资料Android 图片压缩之多种压缩方式结合使用]]></content>
      <categories>
        <category>Android View</category>
      </categories>
      <tags>
        <tag>Bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coordinatorlayout使用全攻略]]></title>
    <url>%2F2018%2F01%2F20%2FCoordinatorlayout%E4%BD%BF%E7%94%A8%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[1.自定义Behavior基础概念其实Behavior就是一个应用于View的观察者模式，一个View跟随者另一个View的变化而变化，或者说一个View监听另一个View。在Behavior中，被观察View也就是事件源被称为denpendcy，而观察View，则被称为child。Button与TextView的爱恨情仇首先在布局文件中跟布局设置为CoordinatorLayout，里面放一个Button和一个TextView。12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;&lt;TextView app:layout_behavior=&quot;.EasyBehavior&quot;android:layout_width=&quot;wrap_content&quot;android:layout_height=&quot;wrap_content&quot;android:text=&quot;观察者View child&quot;/&gt;&lt;Button android:id=&quot;@+id/btn&quot;android:layout_width=&quot;wrap_content&quot;android:layout_height=&quot;wrap_content&quot;android:layout_gravity=&quot;center&quot;android:text=&quot;被观察View dependency&quot;/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 这里我们在Activity中做一些手脚，让Button动起来(不要在意坐标这些细节)123456789101112@Override protected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_easy_behavior);findViewById(R.id.btn).setOnTouchListener(new View.OnTouchListener() &#123;@Override public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_MOVE:v.setX(event.getRawX()-v.getWidth()/2);v.setY(event.getRawY()-v.getHeight()/2); break;&#125; return false;&#125;&#125;);&#125; 此时，Button已经可以跟随手指移动了。现在去自定义一个Behavior让TextView跟随Button一起动！创建一个EasyBehavior类，继承于Behavior12345678910111213141516public class EasyBehavior extends CoordinatorLayout.Behavior&lt;TextView&gt; &#123;//这里的泛型是child的类型，也就是观察者Viewpublic EasyBehavior(Context context, AttributeSet attrs) &#123;super(context, attrs);&#125;@Override public boolean layoutDependsOn(CoordinatorLayout parent, TextView child, View dependency) &#123; //告知监听的dependency是Buttonreturn dependency instanceof Button;&#125;@Override //当 dependency(Button)变化的时候，可以对child(TextView)进行操作public boolean onDependentViewChanged(CoordinatorLayout parent, TextView child, View dependency) &#123;child.setX(dependency.getX()+200);child.setY(dependency.getY()+200);child.setText(dependency.getX()+&quot;,&quot;+dependency.getY()); return true;&#125;&#125; 注意两个方法layoutDependsOn() 代表寻找被观察ViewonDependentViewChanged() 被观察View变化的时候回调用的方法在onDependentViewChanged中，我们让TextView跟随Button的移动而移动。代码比较简单，一看就懂。Tip必须重写带双参的构造器，因为从xml反射需要调用。接下来，在xml中，给TextView设置我们的Behavior。123456&lt;TextView app:layout_behavior=&quot;.EasyBehavior&quot;android:layout_width=&quot;wrap_content&quot;android:layout_height=&quot;wrap_content&quot;android:text=&quot;观察者View child&quot;/&gt; 运行效果如下： 2.CoordinatorLayout使用CoordinatorLayout是谷歌提供的Material Design许多功能的基础，使用它你可以轻松地实现许多动画效果。这些效果包括：1.滑动Floating Action Button为SnackBar的弹起提供空间。2.展开或者收起Toolbar为屏幕的主内容提供空间。3.控制某个应该被收起或展开的View以一定地视差效果完成动作，包括parallax scrolling effects 动画。 Floating Action Buttons 和 SnackbarsFloatingActionButton可以通过layout_anchor和layout_anchorGravity来控制显示的位置。当我们将其显示到屏幕的底端时，它会自动响应SnackBar的弹起或收起：SnackBar弹起后FloatingActionButton也弹起SnackBar的高度，收起后FloatingActionButton也收起。123456789101112131415161718192021&lt;android.support.design.widget.CoordinatorLayoutandroid:id=&quot;@+id/main_content&quot;xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;android.support.v7.widget.RecyclerViewandroid:id=&quot;@+id/rvToDoList&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;/&gt;&lt;android.support.design.widget.FloatingActionButtonandroid:layout_width=&quot;wrap_content&quot;android:layout_height=&quot;wrap_content&quot;android:layout_gravity=&quot;bottom|right&quot;android:layout_margin=&quot;16dp&quot;android:src=&quot;@mipmap/ic_launcher&quot;app:layout_anchor=&quot;@id/rvToDoList&quot;app:layout_anchorGravity=&quot;bottom|right|end&quot;/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; Expanding 和 Collapsing Toolbars1.确保CoordinatorLayout是主容器。1234567891011121314&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;android:id=&quot;@+id/main_content&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;android:fitsSystemWindows=&quot;true&quot;&gt;&lt;android.support.v7.widget.Toolbarandroid:id=&quot;@+id/toolbar&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;?attr/actionBarSize&quot;app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 2.为了响应滑动事件，我们必须使用AppBarLayout:1234567891011121314&lt;android.support.design.widget.AppBarLayoutandroid:id=&quot;@+id/appbar&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;@dimen/detail_backdrop_height&quot;android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;android:fitsSystemWindows=&quot;true&quot;&gt;&lt;android.support.v7.widget.Toolbarandroid:id=&quot;@+id/toolbar&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;?attr/actionBarSize&quot;app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 为了让滑动的View始终在AppBarLayout的下面，需要为滑动的View定义layout_behavior为@string/appbar_scrolling_view_behavior。我们还可以通过app:layout_scrollFlags控制AppBarLayout中的子View响应RecycleView的滑动。1234567891011121314151617&lt;android.support.design.widget.AppBarLayoutandroid:layout_width=&quot;match_parent&quot;android:layout_height=&quot;wrap_content&quot;android:fitsSystemWindows=&quot;true&quot;android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;&lt;android.support.v7.widget.Toolbarandroid:id=&quot;@+id/toolbar&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;?attr/actionBarSize&quot;app:layout_scrollFlags=&quot;scroll|enterAlways&quot;/&gt;&lt;android.support.v7.widget.RecyclerViewandroid:id=&quot;@+id/rvToDoList&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;/&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 关于layout_scrollFlags的值这里解释一下： scroll - 想滚动就必须设置这个。 enterAlways - 实现quick return效果, 当向下移动时，立即显示View（比如Toolbar)。 exitUntilCollapsed - 向上滚动时收缩View，但可以固定Toolbar一直在上面(可通过minHeight设置)。 enterAlwaysCollapsed - 当你的View已经设置minHeight属性又使用此标志时，你的View只能以最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。 snap - 如果头部滑动操作超过50%的距离，则自动关闭。如果头部滑动操作不超过50%的距离，则不关闭。 创建折叠效果CollapsingToolbarLayout作用是提供了一个可以折叠的Toolbar，它继承至FrameLayout，给它设置layout_scrollFlags，它可以控制包含在CollapsingToolbarLayout中的控件(如：ImageView、Toolbar)在响应layout_behavior事件时作出相应的scrollFlags滚动事件(移除屏幕或固定在屏幕顶端)。123456789101112131415161718192021222324252627282930313233&lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;256dp&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/collapsing_toolbar_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:contentScrim=&quot;#30469b&quot; app:expandedTitleMarginStart=&quot;48dp&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt; &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@mipmap/bg&quot; app:layout_collapseMode=&quot;parallax&quot; app:layout_collapseParallaxMultiplier=&quot;0.7&quot; /&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:layout_collapseMode=&quot;pin&quot; /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;android:scrollbars=&quot;none&quot; /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; 1、在CollapsingToolbarLayout中设置了一个ImageView和一个Toolbar。并把这个CollapsingToolbarLayout放到AppBarLayout中作为一个整体。在CollapsingToolbarLayout中，我们除了设置layout_scrollFlags，还可以设置一些其它的属性，简要说明一下： contentScrim - 设置当完全CollapsingToolbarLayout折叠(收缩)后的背景颜色。 expandedTitleMarginStart - 设置扩张时候(还没有收缩时)title向左填充的距离。 没扩张时候如图：2、在ImageView控件中：我们设置了layout_collapseMode (折叠模式) - 有两个值: pin - 设置为这个模式时，当CollapsingToolbarLayout完全收缩后，Toolbar还可以保留在屏幕上。 parallax - 设置为这个模式时，在内容滚动时，CollapsingToolbarLayout中的View（比如ImageView)也可以同时滚动，实现视差滚动效果，通常和layout_collapseParallaxMultiplier(设置视差因子)搭配使用。 layout_collapseParallaxMultiplier(视差因子) - 设置视差滚动因子，值为：0~1。 3、在Toolbar控件中，我们设置了layout_collapseMode(折叠模式)为pin。效果如图:综上分析：当设置了layout_behavior的控件响应起了CollapsingToolbarLayout中的layout_scrollFlags事件时，ImageView会有视差效果的向上滚动移除屏幕，当开始折叠时CollapsingToolbarLayout的背景色(也就是Toolbar的背景色)就会变为我们设置好的背景色，Toolbar也一直会固定在最顶端。 注意：使用CollapsingToolbarLayout时必须把title设置到CollapsingToolbarLayout上，设置到Toolbar上不会显示。即：mCollapsingToolbarLayout.setTitle(“ “); Bottom Sheet有两种类型的Bottom Sheet：1.Persistent bottom sheet :通常用于显示主界面之外的额外信息，它是主界面的一部分，只不过默认被隐藏了，其深度（elevation）跟主界面处于同一级别；还有一个重要特点是在Persistent bottom sheet打开的时候，主界面仍然是可以操作的。ps：Persistent bottom sheet该如何翻译呢？我觉得翻译为普通bottom sheet就好了，还看到有人翻译为“常驻bottom sheet”，可能更接近于英语的字面意思，可是反而不易理解。2.模态bottom sheet :顾名思义，模态的bottom sheet在打开的时候会阻止和主界面的交互，并且在视觉上会在bottom sheet背后加一层半透明的阴影，使得看上去深度（elevation）更深。总结起来这两种Bottom Sheet的区别主要在于视觉和交互上，当然使用方法也是不一样的。 参考资料CoordinatorLayout介绍]]></content>
      <categories>
        <category>Android View</category>
      </categories>
      <tags>
        <tag>Coordinatorlayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5加密算法]]></title>
    <url>%2F2017%2F12%2F20%2FMD5%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[MD5(Message-Digest Algorithm 5,信息-摘要算法5)用于确保信息传输完整一致，是计算机广泛使用的杂凑算法之一（又译摘要算法，哈希算法）。MD5算法将数据（如汉字）运算成另一固定长度值，MD5的前生有MD2，MD3和MD4。MD5算法具有如下特征：1、压缩性：任意长度的数据算出的MD5值是固定的，即128 位固定长度的散列值。2、容易计算：从原数据很容易算出MD5值。3、抗修改性：对原数据任何一个细微的改动，所得到的MD5值都会有很大的不同。4、强抗碰撞：MD5 使用的是散列函数（也称哈希函数），一定概率上也存在哈希冲突（也称哈希碰撞），即多个不同的原数据对应一个相同的 MD5 值。不过，经过 MD4、MD3 等几代算法的优化，MD5 已经充分利用散列的分散性高度避免碰撞的发生。 可以看出，MD5 是一种不可逆的算法，也就说，你无法通过得到的 MD5 值逆向算出原数据内容。正是凭借这些特点，MD5 被广泛使用。 MD5的使用场景场景一客户端与服务器的 HTTP 通信，通信双方可以将报文内容做一个 MD5 计算，并将计算所得 MD5 值一并传递给彼此，这样，接收方可以通过对报文内容再次做 MD5 计算得到一个 MD5 值，与传递报文中的 MD5 值做比较，验证数据是否完整，或者是否中途被拦截篡改过。 场景二网络云盘中的文件秒传功能也运用到 MD5 算法。服务器存储文件的时候，同时记录每一个文件的 MD5 值，不同文件对应着不同的 MD5 值。这样，遇到用户上传文件时，将上传文件的 MD5 值与服务器上所有存储的 MD5 值做比较，如果相同，则说明用户上传的文件已经在服务器存有。这样，只需要在数据库表中添加一个记录，映射到对应的文件，而不用重复上传，实现所谓秒传的功能。 注意：严格意义上来讲，MD5 并不属于加密算法，也不属于签名算法，而是一种摘要算法，用于数据完整性校验等。 Java 语言中计算 MD5 值的实现方式第一步，获取 MessageDigest 对象，参数为 MD5 字符串，表示这是一个 MD5 算法（其他还有 SHA1 算法等）：1MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); 第二步，输入原数据，参数类型为 byte[] ：1md5.update(buffer); 注意：update() 方法有点类似 StringBuilder 对象的 append() 方法，采用的是追加模式，属于一个累计更改的过程，比如：12md5.update(new byte[]&#123;&apos;a&apos;, &apos;b&apos;&#125;);md5.update(new byte[]&#123;&apos;c&apos;, &apos;d&apos;&#125;); 与1md5.update(new byte[]&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;, &apos;d&apos;&#125;); 是等效的。第三步，计算 MD5 值：1String resultArray = md5.digest(); 注意：digest() 方法被调用后，MessageDigest 对象就被重置，也就是说你不能紧接着再次调用该方法计算原数据的 MD5 值。当然，你可以手动调用 reset() 方法重置输入源。digest() 方法返回值是一个字节数组类型的 16 位长度的哈希值，通常，我们会转化为十六进制的 32 位长度的字符串来使用，可以利用 BigInteger 类来做这个转化：12BigInteger bigInt = new BigInteger(1, resultArray);String resultStr = bigInt.toString(16); 通过这层转换，得到的 MD5 值便是一个长度为 32 位的十六进制字符串，方便使用，类似这样：115aa7ec97a6288e46ae865a7211eb4eb 有了上面的基础我们再来看如何将一个文件通过MD5加密转化成32位的十六进制字符串。12345678910111213141516171819public static String fileToMD5(String filePath) &#123;String md5 = null;MessageDigest digest = null;try &#123;digest = MessageDigest.getInstance(&quot;MD5&quot;);FileInputStream inputStream = new FileInputStream(filePath);byte[] b = new byte[1024];int len = -1;while ((len = inputStream.read(b)) != -1) &#123;digest.update(b, 0, len);&#125;byte[] bytes = digest.digest();BigInteger bigInteger = new BigInteger(1, bytes);md5 = bigInteger.toString(16);&#125; catch (Exception e) &#123;e.printStackTrace();&#125;return md5;&#125; 注意：文件的大小直接影响字节流的读取速度，间接影响这里 MD5 的计算时长。Java 语言提供有多种方式读取文件，除了上面用到的 FileInputStream 这种顺序读取的 API 类，还有采用随机读取方式的 RandomAccessFile 类等。对于文件读取的效率问题，研究之后再作介绍。 参考资料MD5 简介，及其在 Java 中的实现方式]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>MD5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用规则补充]]></title>
    <url>%2F2017%2F12%2F16%2FGit%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[学习的git的同学想必看过了廖雪峰老师的Git教程，笔者在学习过程中也深受这篇文章的启发。但是在学习或使用过程中，笔者也遇到了一些比较实际的但是廖老师没有提到或者只是一笔带过的问题。这篇文章就把这些问题的解决办法记录一下吧～1.如何方便的使用一台机器向不同的远端仓库（如：github）提交代码?我们知道在往github的某一个仓库提交代码时，需要在本地生成一个SSH Key，然后将其添加到github中，如下。但是现在需要为github中的另外一个库添加SSH key，理所当然地，我们要再次在本地生成一个SSH key，命令如下。1ssh-keygen -t rsa -C &quot;youremail@yourcompany.com&quot; 若一路回车（密码可以不写），这样会覆盖~/.ssh/ 目录下生成 id_rsa 和 id_rsa.pub 两个文件。为了区分，我们在第一个回车后设置路径：1Enter file in which to save the key (/root/.ssh/id_rsa):~/.ssh/文件名 由此我们分别为github中的两个库（A库和B库）生成对应的公钥和私钥，完成后的目录：id_rsaid_rsa.pubid_subid_sub.pub之后我们将新生成的SSH key设置给B库，此时，理所当然地我们开始往B库中提交代码，但是事实没有那么美好，提示：没有权限。如何解决呢？1、 首先查看代理1ssh-add -l 若提示1Could not open a connection to your authentication agent. 则系统代理里没有任何key，执行如下操作1exec ssh-agent bash 若系统已经有ssh-key 代理 ,可以删除1ssh-add -D 2.添加私钥12ssh-add ~/.ssh/id_rsa ssh-add ~/.ssh/id_sub 3.添加公钥在github对应的管理页面，添加对应的公钥（.pub 文件内容），保存到代码管理服务器。4.添加和编辑配置文件config在 ~/.ssh 目录下新建一个config文件1touch ~/.ssh/config 添加内容1234567# github Host github.com HostName github.com PreferredAuthentications publickey # IdentityFile ~/.ssh/id_subIdentityFile ~/.ssh/id_rsa user git 注意到第五、六行,如果我们需要往对应的远端版本库中提交代码，那么定义相应的IdentityFile行即可。但是，同一个时间只能配置一个IdentityFile，切换的时候只需更换IdentityFile即可。2.如何修改commit的备注？试想你在调用git commit -m &quot;备注&quot;后，如果突然反悔了，想重新修改commit的备注语，可以调用git commit —amend,之后可以在vi编辑器中重新编辑我们的备注了。3.Git忽略规则及.gitignore规则不生效的解决办法在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如：1234567# 此为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：123git rm -r --cached .git add .git commit -m &apos;update .gitignore&apos;]]></content>
      <categories>
        <category>Git使用</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获取系统图片的研究]]></title>
    <url>%2F2017%2F11%2F13%2FAndroid%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%9B%BE%E7%89%87%E7%9A%84%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[在Android开发过程中，我们经常会遇到从相册中获取图片、拍照获取图片、相册多选的需求，那么今天就从这三点出发来研究一下Android获取系统的图片的方法吧～ 1.相册获取图片（单张）从相册获取单张图片的方式主要有两个，一种是直接获取，另外一种是在进入内容（图片）选择界面之前弹出一个类别选择窗。 直接获取12345void getImageFromAlbum() &#123; Intent intent = new Intent(Intent.ACTION_PICK); intent.setType(&quot;image/*&quot;);//相片类型 startActivityForResult(intent, REQUEST_CODE_PICK_IMAGE); &#125; 进行内容类别选择之后，才进入具体的内容界面123456void getContent() &#123;Intent intent = new Intent();intent.setType(&quot;image/*&quot;);intent.setAction(Intent.ACTION_GET_CONTENT);startActivityForResult(Intent.createChooser(intent, &quot;Select Picture&quot;), 1);//定义弹窗的标题。&#125; 2.从照相机获取照片1234567891011protected void getImageFromCamera() &#123; String state = Environment.getExternalStorageState(); if (state.equals(Environment.MEDIA_MOUNTED)) &#123; Intent intent = new Intent();intent.setAction(&quot;android.media.action.IMAGE_CAPTURE&quot;);startActivityForResult(intent, 2); &#125; else &#123; Toast.makeText(getApplicationContext(), &quot;请确认已经插入SD卡&quot;, Toast.LENGTH_LONG).show(); &#125; &#125; 当图片的信息返回后，我们要在onActivityResult方法中获取返回的图片信息。12345678910@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == 1) &#123; Uri uri = data.getData(); //to do find the path of pic &#125; else if (requestCode == 2 ) &#123; Uri uri = data.getData(); //to do find the path of pic &#125; &#125; 不同的机器获得相片的方式不太一样，可能有的相机能够通过 inten.getData()获取到uri然后再根据uri获取数据的路径，在封装成bitmap，但有时候有的相机获取到的是null的，这时候我们该怎么办呢？其实这时候我们就应该从bundle中获取数据，通过(Bitmap) bundle.get(“data”)直接获取到相机图片的bitmap数据。为了能够同时适应上述两种情况，我们这时候就应该在获取图片时做判断了。我们可以在响应的时候做一个判断：123456789101112131415161718192021222324@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == 1) &#123; Uri uri = data.getData(); //to do find the path of pic by uri &#125; else if (requestCode == 2 ) &#123; Uri uri = data.getData(); if(uri == null)&#123; //use bundle to get data Bundle bundle = data.getExtras(); if (bundle != null) &#123; Bitmap photo = (Bitmap) bundle.get(&quot;data&quot;); //get bitmap //spath :生成图片取个名字和路径包含类型 saveImage(Bitmap photo, String spath); &#125; else &#123; Toast.makeText(getApplicationContext(), &quot;err****&quot;, Toast.LENGTH_LONG).show(); return; &#125; &#125;else&#123; //to do find the path of pic by uri &#125; &#125; &#125; 后面的过程就需要通过bitmap转化成相应的图片文件了。不过得到最终的图片是被压缩了的。12345678910111213public static void saveImage(Bitmap photo, String spath) &#123; try &#123; BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(spath, false)); photo.compress(Bitmap.CompressFormat.JPEG, 100, bos); bos.flush(); bos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return true; &#125; 3.实现相册多选功能Android自身没有实现相册多选功能，如果想要实现的话，还是有办法的。通过getContentResolver().query()遍历整个相册即可获取所有的本地图片，然后利用GridView或者其它的方式将这些图片展示即可。123456789ContentResolver contentResolver = getContentResolver();Cursor cursor = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, null, null, null, null);if (cursor.moveToFirst()) &#123;do &#123;String uriStr = cursor.getString(cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA));//这里可以先将uriStr保存到内存，之后再加载到Adapter中。Log.d(&quot;TAG&quot;, &quot;query: &quot; + column);&#125; while (cursor.moveToNext());&#125; 4.最佳实践获取权限不要忘记了，Android在读取外部存储空间时需要获取android.permission.READ_EXTERNAL_STORAGE权限。但是6.0以上的Android系统有了动态获取权限的概念，具体请查看官方文档。上面提到读取外部存储空间时需要读取权限，其实所有需要访问外部存储空间的操作都是需要访问权限的。但是对于内部存储空间的访问则不需要权限的申请。关于内部存储空间与外部存储空间的区别，具体请查看这篇文章。 参考资料Android开发之获取相册照片和获取拍照照片]]></content>
      <categories>
        <category>Android多媒体操作</category>
      </categories>
      <tags>
        <tag>获取拍照或相册图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View详细教程]]></title>
    <url>%2F2017%2F10%2F09%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[自定义View一直都是Android开发的一个重要模块，在实际开发过程中我们也无法避免地会用到它。那么今天就来详细的梳理一下这一块的知识点吧。 1.自定义View首先我们要明白，为什么要自定义View？主要是Android系统内置的View无法实现我们的需求，我们需要针对我们的业务需求定制我们想要的View。自定义View我们大部分时候只需重写两个函数：onMeasure()、onDraw()。onMeasure负责对当前View的尺寸进行测量，onDraw负责把当前这个View绘制出来。 从构造方法讲起View有四种形式的构造方法，其中四个参数的构造方法是API 21才出现，所以一般我们只需要重写其他三个构造方法即可。它们的参数不一样分别对应不同的创建方式，比如只有一个Context参数的构造方法通常是通过代码初始化控件时使用；而两个参数的构造方法通常对应布局文件中控件被映射成对象时调用（需要解析属性）；通常我们让这两个构造方法最终调用三个参数的构造方法，然后在第三个构造方法中进行一些初始化操作。123456789101112public MyTextView(Context context) &#123;this(context, null);&#125;public MyTextView(Context context, AttributeSet attrs) &#123;this(context, attrs, 0);&#125;public MyTextView(Context context, AttributeSet attrs, int defStyleAttr) &#123;super(context, attrs, defStyleAttr);//初始化操作……&#125; onMeasure在学习Android的时候，我们就知道，在xml布局文件中，我们的layout_width和layout_height参数可以不用写具体的尺寸，而是wrap_content或者是match_parent。其意思我们都知道，就是将尺寸设置为“包住内容”和“填充父布局给我们的所有空间”。这两个设置并没有指定真正的大小，可是我们绘制到屏幕上的View必须是要有具体的宽高的，正是因为这个原因，我们必须自己去处理和设置尺寸。当然了，View类给了默认的处理，但是如果View类的默认处理不满足我们的要求，我们就得重写onMeasure函数啦。这里举个例子，比如我们希望我们的View是个正方形，如果在xml中指定宽高为wrap_content，如果使用View类提供的measure处理方式，显然无法满足我们的需求。先看看onMeasure函数原型：1protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) 参数中的widthMeasureSpec和heightMeasureSpec是个什么鬼？看起来很像width和height，没错，这两个参数就是包含宽和高的信息。什么？包含？难道还要其他信息？是的！它还包含测量模式，也就是说，一个int整数，里面放了测量模式和尺寸大小。那么一个数怎么放两个信息呢？我们知道，我们在设置宽高时有3个选择：wrap_content、match_parent以及指定固定尺寸，而测量模式也有3种：UNSPECIFIED，EXACTLY，AT_MOST，当然，他们并不是一一对应关系哈，这三种模式后面我会详细介绍，但测量模式无非就是这3种情况，而如果使用二进制，我们只需要使用2个bit就可以做到，因为2个bit取值范围是[0,3]里面可以存放4个数足够我们用了。那么Google是怎么把一个int同时放测量模式和尺寸信息呢？我们知道int型数据占用32个bit，而google实现的是，将int数据的前面2个bit用于区分不同的布局模式，后面30个bit存放的是尺寸的数据。那我们怎么从int数据中提取测量模式和尺寸呢？放心，不用你每次都要写一次移位&lt;&lt;和取且&amp;操作，Android内置类MeasureSpec帮我们写好啦~，我们只需按照下面方法就可以拿到啦：12int widthMode = MeasureSpec.getMode(widthMeasureSpec);int widthSize = MeasureSpec.getSize(widthMeasureSpec); 爱思考的你肯定会问，既然我们能通过widthMeasureSpec拿到宽度尺寸大小，那我们还要测量模式干嘛？测量模式会不会是多余的？请注意：这里的的尺寸大小并不是最终我们的View的尺寸大小，而是父View提供的参考大小。我们看看测量模式，测量模式是干啥用的呢？ 测量模式 表示意思 UNSPECIFIED 父容器没有对当前View有任何限制，当前View可以任意取尺寸 EXACTLY 当前的尺寸就是当前View应该取的尺寸 AT_MOST 当前尺寸是当前View能取的最大尺寸 而上面的测量模式跟我们的布局时的wrap_content、match_parent以及写成固定的尺寸有什么对应关系呢？1、match_parent—&gt;EXACTLY。怎么理解呢？match_parent就是要利用父View给我们提供的所有剩余空间，而父View剩余空间是确定的，也就是这个测量模式的整数里面存放的尺寸。2、wrap_content—&gt;AT_MOST。怎么理解：就是我们想要将大小设置为包裹我们的view内容，那么尺寸大小就是父View给我们作为参考的尺寸，只要不超过这个尺寸就可以啦，具体尺寸就根据我们的需求去设定。3、固定尺寸（如100dp）—&gt;EXACTLY。用户自己指定了尺寸大小，我们就不用再去干涉了，当然是以指定的大小为主啦。 动手重写onMeasure函数上面讲了太多理论，我们实际操作一下吧，感受一下onMeasure的使用，假设我们要实现这样一个效果：将当前的View以正方形的形式显示，即要宽高相等，并且默认的宽高值为100像素。就可以这些编写：1234567891011121314151617181920212223242526272829303132333435363738private int getMySize(int defaultSize, int measureSpec) &#123;int mySize = defaultSize;int mode = MeasureSpec.getMode(measureSpec);int size = MeasureSpec.getSize(measureSpec);switch (mode) &#123;case MeasureSpec.UNSPECIFIED: &#123;//如果没有指定大小，就设置为默认大小mySize = defaultSize;break;&#125;case MeasureSpec.AT_MOST: &#123;//如果测量模式是最大取值为size//我们将大小取最大值,你也可以取其他值mySize = size;break;&#125;case MeasureSpec.EXACTLY: &#123;//如果是固定的大小，那就不要去改变它mySize = size;break;&#125;&#125;return mySize;&#125;@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;super.onMeasure(widthMeasureSpec, heightMeasureSpec);int width = getMySize(100, widthMeasureSpec);int height = getMySize(100, heightMeasureSpec);if (width &lt; height) &#123;height = width;&#125; else &#123;width = height;&#125;setMeasuredDimension(width, height);&#125; 我们设置一下布局1234&lt;com.hc.studyview.MyViewandroid:layout_width=&quot;match_parent&quot;android:layout_height=&quot;100dp&quot;android:background=&quot;#ff0000&quot; /&gt; 看看使用了我们自己定义的onMeasure函数后的效果：而如果我们不重写onMeasure，效果则是如下： 注意：实际使用过程中可能会遇到当MyView的父View是RelativeLayout时，无法通过重写onMeasure定义方形View的情况，解决方案请看这里。 重写onDraw上面我们学会了自定义尺寸大小，那么尺寸我们会设定了，接下来就是把我们想要的效果画出来吧~绘制我们想要的效果很简单，直接在画板Canvas对象上绘制就好啦，为了简单，我们以一个简单的例子去学习：在我们的View上显示一个圆形。我们在上面已经实现了宽高尺寸相等的基础上，继续往下做：12345678910111213@Overrideprotected void onDraw(Canvas canvas) &#123;int r = getMeasuredWidth() / 2;//也可以是getMeasuredHeight()/2,本例中我们已经将宽高设置相等了//圆心的横坐标为当前的View的半径值（注意是将当前View坐上角的第一个点视为原点。）int centerX = r;//圆心的纵坐标为当前的View的半径值int centerY =r;Paint paint = new Paint();paint.setColor(Color.GREEN);//开始绘制canvas.drawCircle(centerX, centerY, r, paint);&#125; 注意：因为onDraw()可能会被调用多次（任何invalidate()的调用都会触发onDraw方法），所以要特别注意onDraw中变量值的管理。 自定义布局属性如果有些属性我们希望由用户指定，只有当用户不指定的时候才用我们硬编码的值，比如上面的默认尺寸，我们想要由用户自己在布局文件里面指定该怎么做呢？那当然是通过自定义属性，让用户用我们定义的属性啦~首先我们需要在res/values/styles.xml文件（如果没有请自己新建）里面声明一个我们自定义的属性：1234567&lt;resources&gt;&lt;!--name为声明的&quot;属性集合&quot;名，可以随便取，但是最好是设置为跟我们的View一样的名称--&gt;&lt;declare-styleable name=&quot;MyView&quot;&gt;&lt;!--声明我们的属性，名称为default_size,取值类型为尺寸类型（dp,px等）--&gt;&lt;attr name=&quot;default_size&quot; format=&quot;dimension&quot; /&gt;&lt;/declare-styleable&gt;&lt;/resources&gt; 接下来就是在布局文件用上我们的自定义的属性啦~123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:hc=&quot;http://schemas.android.com/apk/res-auto&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;com.hc.studyview.MyViewandroid:layout_width=&quot;match_parent&quot;android:layout_height=&quot;100dp&quot;hc:default_size=&quot;100dp&quot; /&gt;&lt;/LinearLayout&gt; 注意：如果是我们的自定义属性，就需要在根标签（LinearLayout）里面设定命名空间。命名空间的一种写法是xmlns:hc=”http://schemas.android.com/apk/res-auto&quot;，res-auto表示自动查找，还有一种写法是xmlns:hc=&quot;http://schemas.android.com/apk/com.hc.studyview.MyView&quot;，`com.hc.studyview.MyView`为我们的应用程序包名。而命名空间的名称可以随意取，如上就是`hc`。最后就是在我们的自定义的View里面把我们自定义的属性的值取出来，在构造函数中，还记得有个AttributeSet属性吗？就是靠它帮我们把布局里面的属性取出来：12345678910111213private int defalutSize;public MyView(Context context, AttributeSet attrs) &#123;super(context, attrs);//第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签//即属性集合的标签，在R文件中名称为R.styleable+nameTypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyView);//第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称//第二个参数为默认值defalutSize = a.getDimensionPixelSize(R.styleable.MyView_default_size, 100);//最后记得将TypedArray对象回收a.recycle();&#125; 最后，把MyView的完整代码附上：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.hc.studyview;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.view.View;/*** Package com.hc.studyview* Created by HuaChao on 2016/6/3.*/public class MyView extends View &#123;private int defalutSize;public MyView(Context context) &#123;super(context);&#125;public MyView(Context context, AttributeSet attrs) &#123;super(context, attrs);//第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签//即属性集合的标签，在R文件中名称为R.styleable+nameTypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyView);//第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称//第二个参数为，如果没有设置这个属性，则设置的默认的值defalutSize = a.getDimensionPixelSize(R.styleable.MyView_default_size, 100);//最后记得将TypedArray对象回收a.recycle();&#125;private int getMySize(int defaultSize, int measureSpec) &#123;int mySize = defaultSize;int mode = MeasureSpec.getMode(measureSpec);int size = MeasureSpec.getSize(measureSpec);switch (mode) &#123;case MeasureSpec.UNSPECIFIED: &#123;//如果没有指定大小，就设置为默认大小mySize = defaultSize;break;&#125;case MeasureSpec.AT_MOST: &#123;//如果测量模式是最大取值为size//我们将大小取最大值,你也可以取其他值mySize = size;break;&#125;case MeasureSpec.EXACTLY: &#123;//如果是固定的大小，那就不要去改变它mySize = size;break;&#125;&#125;return mySize;&#125;@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;super.onMeasure(widthMeasureSpec, heightMeasureSpec);int width = getMySize(defalutSize, widthMeasureSpec);int height = getMySize(defalutSize, heightMeasureSpec);if (width &lt; height) &#123;height = width;&#125; else &#123;width = height;&#125;setMeasuredDimension(width, height);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123;int r = getMeasuredWidth() / 2;//也可以是getMeasuredHeight()/2,本例中我们已经将宽高设置相等了int centerX = r;int centerY = r;Paint paint = new Paint();paint.setColor(Color.GREEN);//开始绘制canvas.drawCircle(centerX, centerY, r, paint);&#125;&#125; 2.自定义ViewGroup基本步骤自定义View的过程很简单，就那几步，可自定义ViewGroup可就没那么简单啦~，因为它不仅要管好自己的，还要兼顾它的子View。我们都知道ViewGroup是个View容器，它装纳child View并且负责把child View放入指定的位置。我们假象一下，如果是让你负责设计ViewGroup，你会怎么去设计呢？1、首先，我们得知道各个子View的大小吧，只有先知道子View的大小，我们才知道当前的ViewGroup该设置为多大去容纳它们。2、根据子View的大小，以及我们的ViewGroup要实现的功能，决定出ViewGroup的大小。3、ViewGroup和子View的大小算出来了之后，接下来就是去摆放了吧，具体怎么去摆放呢？这得根据你定制的需求去摆放了，比如，你想让子View按照垂直顺序一个挨着一个放，或者是按照先后顺序一个叠一个去放，这是你自己决定的。4、已经知道怎么去摆放还不行啊，决定了怎么摆放就是相当于把已有的空间”分割”成大大小小的空间，每个空间对应一个子View，我们接下来就是把子View对号入座了，把它们放进它们该放的地方去。现在就完成了ViewGroup的设计了，我们来个具体的案例：将子View按从上到下垂直顺序一个挨着一个摆放，即模仿实现LinearLayout的垂直布局。首先重写onMeasure，实现测量子View大小以及设定ViewGroup的大小：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;super.onMeasure(widthMeasureSpec, heightMeasureSpec);//将所有的子View进行测量，这会触发每个子View的onMeasure函数//注意要与measureChild区分，measureChild是对单个view进行测量measureChildren(widthMeasureSpec, heightMeasureSpec);int widthMode = MeasureSpec.getMode(widthMeasureSpec);int widthSize = MeasureSpec.getSize(widthMeasureSpec);int heightMode = MeasureSpec.getMode(heightMeasureSpec);int heightSize = MeasureSpec.getSize(heightMeasureSpec);int childCount = getChildCount();if (childCount == 0) &#123;//如果没有子View,当前ViewGroup没有存在的意义，不用占用空间setMeasuredDimension(0, 0);&#125; else &#123;//如果宽高都是包裹内容if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;//我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度int height = getTotleHeight();int width = getMaxChildWidth();setMeasuredDimension(width, height);&#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容//宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和setMeasuredDimension(widthSize, getTotleHeight());&#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容//宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值setMeasuredDimension(getMaxChildWidth(), heightSize);&#125;&#125;&#125;/**** 获取子View中宽度最大的值*/private int getMaxChildWidth() &#123;int childCount = getChildCount();int maxWidth = 0;for (int i = 0; i &lt; childCount; i++) &#123;View childView = getChildAt(i);if (childView.getMeasuredWidth() &gt; maxWidth)maxWidth = childView.getMeasuredWidth();&#125;return maxWidth;&#125;/**** 将所有子View的高度相加**/private int getTotleHeight() &#123;int childCount = getChildCount();int height = 0;for (int i = 0; i &lt; childCount; i++) &#123;View childView = getChildAt(i);height += childView.getMeasuredHeight();&#125;return height;&#125; 代码中的注释我已经写得很详细，不再对每一行代码进行讲解。上面的onMeasure将子View测量好了，以及把自己的尺寸也设置好了，接下来我们去摆放子View吧~123456789101112131415@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123;int count = getChildCount();//记录当前的高度位置int curHeight = t;//将子View逐个摆放for (int i = 0; i &lt; count; i++) &#123;View child = getChildAt(i);int height = child.getMeasuredHeight();int width = child.getMeasuredWidth();//摆放子View，参数分别是子View矩形区域的左、上、右、下边child.layout(l, curHeight, l + width, curHeight + height);curHeight += height;&#125;&#125; 我们测试一下，将我们自定义的ViewGroup里面放3个Button ,将这3个Button的宽度设置不一样，把我们的ViewGroup的宽高都设置为包裹内容wrap_content，为了看的效果明显，我们给ViewGroup加个背景：1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;com.hc.studyview.MyViewGroupandroid:layout_width=&quot;wrap_content&quot;android:layout_height=&quot;wrap_content&quot;android:background=&quot;#ff9900&quot;&gt;&lt;Buttonandroid:layout_width=&quot;100dp&quot;android:layout_height=&quot;wrap_content&quot;android:text=&quot;btn&quot; /&gt;&lt;Buttonandroid:layout_width=&quot;200dp&quot;android:layout_height=&quot;wrap_content&quot;android:text=&quot;btn&quot; /&gt;&lt;Buttonandroid:layout_width=&quot;50dp&quot;android:layout_height=&quot;wrap_content&quot;android:text=&quot;btn&quot; /&gt;&lt;/com.hc.studyview.MyViewGroup&gt;&lt;/LinearLayout&gt; 看看最后的效果吧~是不是很激动我们自己也可以实现LinearLayout的效果啦~~~ 注意：getMeasureWidth()/getMeasureHeight()需要在调用setMeasuredDimension()之后使用；getWidth()/getHeight()需要在调用layout()函数之后使用。一般情况，我们使用getMeasureWidth()/getMeasureHeight()获取宽高即可。 自定义LayoutParamsViewGroup中有两个内部类ViewGroup.LayoutParams和ViewGroup.MarginLayoutParams，MarginLayoutParams继承自LayoutParams，这两个内部类就是ViewGroup的布局参数类，比如我们在LinearLayout等布局中使用的layout_width\layoutheight等以“layout ”开头的属性都是布局属性。 为什么LayoutParams 类要定义在ViewGroup中？大家都知道ViewGroup是所有容器的基类，一个控件需要被包裹在一个容器中，这个容器必须提供一种规则控制子控件的摆放，比如你的宽高是多少，距离那个位置多远等。所以ViewGroup有义务提供一个布局属性类，用于控制子控件的布局属性。 在View中有一个mLayoutParams的变量用来保存这个View的所有布局属性。ViewGroup.LayoutParams有两个属性layout_width和layout_height，因为所有的容器都需要设置子控件的宽高，所以这个LayoutParams是所有布局参数的基类，如果需要扩展其他属性，都应该继承自它。比如RelativeLayout中就提供了它自己的布局参数类RelativeLayout.LayoutParams，并扩展了很多布局参数，我们平时在RelativeLayout中使用的布局属性都来自它：123456789101112131415161718192021222324&lt;declare-styleable name= &quot;RelativeLayout_Layout&quot;&gt;&lt;attr name =&quot;layout_toLeftOf&quot; format= &quot;reference&quot; /&gt;&lt;attr name =&quot;layout_toRightOf&quot; format= &quot;reference&quot; /&gt;&lt;attr name =&quot;layout_above&quot; format=&quot;reference&quot; /&gt;&lt;attr name =&quot;layout_below&quot; format=&quot;reference&quot; /&gt;&lt;attr name =&quot;layout_alignBaseline&quot; format= &quot;reference&quot; /&gt;&lt;attr name =&quot;layout_alignLeft&quot; format= &quot;reference&quot; /&gt;&lt;attr name =&quot;layout_alignTop&quot; format= &quot;reference&quot; /&gt;&lt;attr name =&quot;layout_alignRight&quot; format= &quot;reference&quot; /&gt;&lt;attr name =&quot;layout_alignBottom&quot; format= &quot;reference&quot; /&gt;&lt;attr name =&quot;layout_alignParentLeft&quot; format= &quot;boolean&quot; /&gt;&lt;attr name =&quot;layout_alignParentTop&quot; format= &quot;boolean&quot; /&gt;&lt;attr name =&quot;layout_alignParentRight&quot; format= &quot;boolean&quot; /&gt;&lt;attr name =&quot;layout_alignParentBottom&quot; format= &quot;boolean&quot; /&gt;&lt;attr name =&quot;layout_centerInParent&quot; format= &quot;boolean&quot; /&gt;&lt;attr name =&quot;layout_centerVertical&quot; format= &quot;boolean&quot; /&gt;&lt;attr name =&quot;layout_alignWithParentIfMissing&quot; format= &quot;boolean&quot; /&gt;&lt;attr name =&quot;layout_toStartOf&quot; format= &quot;reference&quot; /&gt;&lt;attr name =&quot;layout_toEndOf&quot; format=&quot;reference&quot; /&gt;&lt;attr name =&quot;layout_alignStart&quot; format= &quot;reference&quot; /&gt;&lt;attr name =&quot;layout_alignEnd&quot; format= &quot;reference&quot; /&gt;&lt;attr name =&quot;layout_alignParentStart&quot; format= &quot;boolean&quot; /&gt;&lt;attr name =&quot;layout_alignParentEnd&quot; format= &quot;boolean&quot; /&gt;&lt;/declare-styleable &gt; 为什么View中会有一个mLayoutParams变量？我们在之前学习自定义控件的时候学过自定义属性，我们在构造方法中，初始化布局文件中的属性值，我们姑且把属性分为两种。一种是本View的绘制属性，比如TextView的文本、文字颜色、背景等，这些属性是跟View的绘制相关的。另一种就是以“layout_”打头的叫做布局属性，这些属性是父控件对子控件的大小及位置的一些描述属性，这些属性在父控件摆放它的时候会使用到，所以先保存起来，而这些属性都是ViewGroup.LayoutParams定义的，所以用一个变量保存着。 看了上面的介绍，我们大概知道怎么为我们的布局容器定义自己的布局属性了吧，就不绕弯子了，按照下面的步骤做： ①. 大致明确布局容器的需求，初步定义布局属性在定义属性之前要弄清楚，我们自定义的布局容器需要满足那些需求，需要哪些属性，比如，我们现在要实现像相对布局一样，为子控件设置一个位置属性layout_position=”“，来控制子控件在布局中显示的位置。暂定位置有五种：左上、左下、右上、右下、居中。有了需求，我们就在attr.xml定义自己的布局属性（和之前讲的自定义属性一样的操作)。123456789101112&lt;?xml version=&quot;1.0&quot; encoding= &quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name =&quot;CustomLayout&quot;&gt;&lt;attr name =&quot;layout_position&quot;&gt;&lt;enum name =&quot;center&quot; value=&quot;0&quot; /&gt;&lt;enum name =&quot;left&quot; value=&quot;1&quot; /&gt;&lt;enum name =&quot;right&quot; value=&quot;2&quot; /&gt;&lt;enum name =&quot;bottom&quot; value=&quot;3&quot; /&gt;&lt;enum name =&quot;rightAndBottom&quot; value=&quot;4&quot; /&gt;&lt;/attr &gt;&lt;/declare-styleable&gt;&lt;/resources&gt; left就代表是左上（按常理默认就是左上方开始，就不用写leftTop了，简洁一点），bottom左下，right 右上，rightAndBottom右下，center居中。属性类型是枚举，同时只能设置一个值。 ②. 继承LayoutParams，定义布局参数类我们可以选择继承ViewGroup.LayoutParams，这样的话我们的布局只是简单的支持layout_width和layout_height；也可以继承MarginLayoutParams，就能使用layout_marginxxx属性了。因为后面我们还要用到margin属性，所以这里方便起见就直接继承MarginLayoutParams了。覆盖构造方法，然后在有AttributeSet参数的构造方法中初始化参数值，这个构造方法才是布局文件被映射为对象的时候被调用的。123456789101112131415161718192021222324252627public static class CustomLayoutParams extends MarginLayoutParams &#123;public static final int POSITION_MIDDLE = 0; // 中间public static final int POSITION_LEFT = 1; // 左上方public static final int POSITION_RIGHT = 2; // 右上方public static final int POSITION_BOTTOM = 3; // 左下角public static final int POSITION_RIGHTANDBOTTOM = 4; // 右下角public int position = POSITION_LEFT; // 默认我们的位置就是左上角public CustomLayoutParams(Context c, AttributeSet attrs) &#123;super(c, attrs);TypedArray a = c.obtainStyledAttributes(attrs,R.styleable.CustomLayout );//获取设置在子控件上的位置属性position = a.getInt(R.styleable.CustomLayout_layout_position ,position );a.recycle();&#125;public CustomLayoutParams( int width, int height) &#123;super(width, height);&#125;public CustomLayoutParams(ViewGroup.LayoutParams source) &#123;super(source);&#125;&#125; ③. 重写generateLayoutParams()在ViewGroup中有下面几个关于LayoutParams的方法，generateLayoutParams (AttributeSet attrs)是在布局文件被填充为对象的时候调用的，这个方法是下面几个方法中最重要的，如果不重写它，我么布局文件中设置的布局参数都不能拿到。其他几个方法我们最好也能重写一下，将里面的LayoutParams换成我们自定义的CustomLayoutParams类，避免以后会遇到布局参数类型转换异常。12345678910111213141516@Overridepublic LayoutParams generateLayoutParams(AttributeSet attrs) &#123;return new CustomLayoutParams(getContext(), attrs);&#125;@Overrideprotected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) &#123;return new CustomLayoutParams (p);&#125;@Overrideprotected LayoutParams generateDefaultLayoutParams() &#123;return new CustomLayoutParams (LayoutParams.MATCH_PARENT , LayoutParams.MATCH_PARENT);&#125;@Overrideprotected boolean checkLayoutParams(ViewGroup.LayoutParams p) &#123;return p instanceof CustomLayoutParams ;&#125; ④. 在布局文件中使用布局属性注意引入命名空间xmlns:openxu= “http://schemas.android.com/apk/res/包名“12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding= &quot;utf-8&quot;?&gt;&lt;com.openxu.costomlayout.CustomLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:openxu= &quot;http://schemas.android.com/apk/res/com.openxu.costomlayout&quot;android:background=&quot;#33000000&quot;android:layout_width= &quot;match_parent &quot;android:layout_height= &quot;match_parent&quot; &gt;&lt;Buttonandroid:layout_width= &quot;wrap_content&quot;android:layout_height= &quot;wrap_content&quot;openxu:layout_position= &quot;left&quot;android:background= &quot;#FF8247&quot;android:textColor= &quot;#ffffff&quot;android:textSize=&quot;20dip&quot;android:padding= &quot;20dip&quot;android:text= &quot;按钮1&quot; /&gt;&lt;Buttonandroid:layout_width= &quot;wrap_content&quot;android:layout_height= &quot;wrap_content&quot;openxu:layout_position= &quot;right&quot;android:background= &quot;#8B0A50&quot;android:textColor= &quot;#ffffff&quot;android:textSize= &quot;18dip&quot;android:padding= &quot;10dip&quot;android:text= &quot;按钮2222222222222&quot; /&gt;&lt;Buttonandroid:layout_width= &quot;wrap_content&quot;android:layout_height= &quot;wrap_content&quot;openxu:layout_position= &quot;bottom&quot;android:background= &quot;#7CFC00&quot;android:textColor= &quot;#ffffff&quot;android:textSize= &quot;20dip&quot;android:padding= &quot;15dip&quot;android:text= &quot;按钮333333&quot; /&gt;&lt;Buttonandroid:layout_width= &quot;wrap_content&quot;android:layout_height= &quot;wrap_content&quot;openxu:layout_position= &quot;rightAndBottom&quot;android:background= &quot;#1E90FF&quot;android:textColor= &quot;#ffffff&quot;android:textSize= &quot;15dip&quot;android:padding= &quot;10dip&quot;android:text= &quot;按钮4&quot; /&gt;&lt;Buttonandroid:layout_width= &quot;wrap_content&quot;android:layout_height= &quot;wrap_content&quot;openxu:layout_position= &quot;center&quot;android:background= &quot;#191970&quot;android:textColor= &quot;#ffffff&quot;android:textSize= &quot;20dip&quot;android:padding= &quot;15dip&quot;android:text= &quot;按钮5&quot; /&gt;&lt;/com.openxu.costomlayout.CustomLayout&gt; ⑤. 在onMeasure和onLayout中使用布局参数经过上面几步之后，我们运行程序，就能获取子控件的布局参数了，在onMeasure方法和onLayout方法中，我们按照自定义布局容器的特殊需求，对宽度和位置坐特殊处理。这里我们需要注意一下，如果布局容器被设置为包裹类容，我们只需要保证能将最大的子控件包裹住就ok，代码注释比较详细，就不多说了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586@Overrideprotected void onMeasure( int widthMeasureSpec, int heightMeasureSpec) &#123; //获得此ViewGroup上级容器为其推荐的宽和高，以及计算模式 int widthMode = MeasureSpec. getMode(widthMeasureSpec); int heightMode = MeasureSpec. getMode(heightMeasureSpec); int sizeWidth = MeasureSpec. getSize(widthMeasureSpec); int sizeHeight = MeasureSpec. getSize(heightMeasureSpec); int layoutWidth = 0;int layoutHeight = 0;// 计算出所有的childView的宽和高measureChildren(widthMeasureSpec, heightMeasureSpec);int cWidth = 0;int cHeight = 0;int count = getChildCount(); if(widthMode == MeasureSpec. EXACTLY)&#123;//如果布局容器的宽度模式是确定的（具体的size或者match_parent），直接使用父窗体建议的宽度layoutWidth = sizeWidth;&#125; else&#123;//如果是未指定或者wrap_content，我们都按照包裹内容做，宽度方向上只需要拿到所有子控件中宽度做大的作为布局宽度for ( int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); cWidth = child.getMeasuredWidth(); //获取子控件最大宽度layoutWidth = cWidth &gt; layoutWidth ? cWidth : layoutWidth;&#125;&#125;//高度很宽度处理思想一样if(heightMode == MeasureSpec. EXACTLY)&#123;layoutHeight = sizeHeight;&#125; else&#123;for ( int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); cHeight = child.getMeasuredHeight();layoutHeight = cHeight &gt; layoutHeight ? cHeight : layoutHeight;&#125;&#125;// 测量并保存layout的宽高setMeasuredDimension(layoutWidth, layoutHeight);&#125;@Overrideprotected void onLayout( boolean changed, int left, int top, int right,int bottom) &#123;final int count = getChildCount();int childMeasureWidth = 0;int childMeasureHeight = 0;CustomLayoutParams params = null;for ( int i = 0; i &lt; count; i++) &#123;View child = getChildAt(i);// 注意此处不能使用getWidth和getHeight，这两个方法必须在onLayout执行完，才能正确获取宽高childMeasureWidth = child.getMeasuredWidth();childMeasureHeight = child.getMeasuredHeight();params = (CustomLayoutParams) child.getLayoutParams(); switch (params. position) &#123;case CustomLayoutParams. POSITION_MIDDLE: // 中间left = (getWidth()-childMeasureWidth)/2;top = (getHeight()-childMeasureHeight)/2;break;case CustomLayoutParams. POSITION_LEFT: // 左上方left = 0;top = 0;break;case CustomLayoutParams. POSITION_RIGHT: // 右上方left = getWidth()-childMeasureWidth;top = 0;break;case CustomLayoutParams. POSITION_BOTTOM: // 左下角left = 0;top = getHeight()-childMeasureHeight;break;case CustomLayoutParams. POSITION_RIGHTANDBOTTOM:// 右下角left = getWidth()-childMeasureWidth;top = getHeight()-childMeasureHeight;break;default:break;&#125;// 确定子控件的位置，四个参数分别代表（左上右下）点的坐标值child.layout(left, top, left+childMeasureWidth, top+childMeasureHeight);&#125;&#125; 3. 支持layout_margin属性如果我们自定义的布局参数类继承自MarginLayoutParams，就自动支持了layout_margin属性了，我们需要做的就是直接在布局文件中使用layout_margin属性，然后再onMeasure和onLayout中使用margin属性值测量和摆放子控件。需要注意的是我们测量子控件的时候应该调用measureChildWithMargin()方法。布局文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=&quot;1.0&quot; encoding= &quot;utf-8&quot;?&gt;&lt;com.openxu.costomlayout.CustomLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:openxu= &quot;http://schemas.android.com/apk/res/com.openxu.costomlayout&quot;android:background=&quot;#33000000&quot;android:layout_width= &quot;match_parent&quot;android:layout_height= &quot;match_parent&quot; &gt;&lt;Buttonandroid:layout_width= &quot;wrap_content&quot;android:layout_height= &quot;wrap_content&quot;openxu:layout_position= &quot;left&quot;android:layout_marginLeft = &quot;20dip&quot;android:background= &quot;#FF8247&quot;android:textColor= &quot;#ffffff&quot;android:textSize=&quot;20dip&quot;android:padding= &quot;20dip&quot;android:text=&quot;按钮1&quot; /&gt;&lt;Buttonandroid:layout_width= &quot;wrap_content&quot;android:layout_height= &quot;wrap_content&quot;android:layout_marginTop = &quot;30dip&quot;openxu:layout_position= &quot;right&quot;android:background= &quot;#8B0A50&quot;android:textColor= &quot;#ffffff&quot;android:textSize=&quot;18dip&quot;android:padding= &quot;10dip&quot;android:text=&quot;按钮2222222222222&quot; /&gt;&lt;Buttonandroid:layout_width= &quot;wrap_content&quot;android:layout_height= &quot;wrap_content&quot;android:layout_marginLeft = &quot;30dip&quot;android:layout_marginBottom = &quot;10dip&quot;openxu:layout_position= &quot;bottom&quot;android:background= &quot;#7CFC00&quot;android:textColor= &quot;#ffffff&quot;android:textSize=&quot;20dip&quot;android:padding= &quot;15dip&quot;android:text=&quot;按钮333333&quot; /&gt;&lt;Buttonandroid:layout_width= &quot;wrap_content&quot;android:layout_height= &quot;wrap_content&quot;openxu:layout_position= &quot;rightAndBottom&quot;android:layout_marginBottom = &quot;30dip&quot;android:background= &quot;#1E90FF&quot;android:textColor= &quot;#ffffff&quot;android:textSize=&quot;15dip&quot;android:padding= &quot;10dip&quot;android:text=&quot;按钮4&quot; /&gt;&lt;Buttonandroid:layout_width= &quot;wrap_content&quot;android:layout_height= &quot;wrap_content&quot;openxu:layout_position= &quot;center&quot;android:layout_marginBottom = &quot;30dip&quot;android:layout_marginRight = &quot;30dip&quot;android:background= &quot;#191970&quot;android:textColor= &quot;#ffffff&quot;android:textSize=&quot;20dip&quot;android:padding= &quot;15dip&quot;android:text=&quot;按钮5&quot; /&gt;&lt;/com.openxu.costomlayout.CustomLayout&gt; onMeasure和onLayout：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 获得此ViewGroup上级容器为其推荐的宽和高，以及计算模式 int widthMode = MeasureSpec. getMode(widthMeasureSpec); int heightMode = MeasureSpec. getMode(heightMeasureSpec); int sizeWidth = MeasureSpec. getSize(widthMeasureSpec); int sizeHeight = MeasureSpec. getSize(heightMeasureSpec); int layoutWidth = 0;int layoutHeight = 0;int cWidth = 0;int cHeight = 0;int count = getChildCount(); // 计算出所有的childView的宽和高for( int i = 0; i &lt; count; i++)&#123;View child = getChildAt(i); measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);&#125;CustomLayoutParams params = null;if(widthMode == MeasureSpec. EXACTLY)&#123;//如果布局容器的宽度模式时确定的（具体的size或者match_parent）layoutWidth = sizeWidth;&#125; else&#123;//如果是未指定或者wrap_content，我们都按照包裹内容做，宽度方向上只需要拿到所有子控件中宽度做大的作为布局宽度for ( int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); cWidth = child.getMeasuredWidth(); params = (CustomLayoutParams) child.getLayoutParams(); //获取子控件宽度和左右边距之和，作为这个控件需要占据的宽度int marginWidth = cWidth+params.leftMargin+params.rightMargin ;layoutWidth = marginWidth &gt; layoutWidth ? marginWidth : layoutWidth;&#125;&#125;//高度很宽度处理思想一样if(heightMode == MeasureSpec. EXACTLY)&#123;layoutHeight = sizeHeight;&#125; else&#123;for ( int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); cHeight = child.getMeasuredHeight();params = (CustomLayoutParams) child.getLayoutParams(); int marginHeight = cHeight+params.topMargin+params.bottomMargin ;layoutHeight = marginHeight &gt; layoutHeight ? marginHeight : layoutHeight;&#125;&#125;// 测量并保存layout的宽高setMeasuredDimension(layoutWidth, layoutHeight);&#125;@Overrideprotected void onLayout( boolean changed, int left, int top, int right,int bottom) &#123;final int count = getChildCount();int childMeasureWidth = 0;int childMeasureHeight = 0;CustomLayoutParams params = null;for ( int i = 0; i &lt; count; i++) &#123;View child = getChildAt(i);childMeasureWidth = child.getMeasuredWidth();childMeasureHeight = child.getMeasuredHeight();params = (CustomLayoutParams) child.getLayoutParams(); switch (params. position) &#123;case CustomLayoutParams. POSITION_MIDDLE: // 中间left = (getWidth()-childMeasureWidth)/2 - params.rightMargin + params.leftMargin ;top = (getHeight()-childMeasureHeight)/2 + params.topMargin - params.bottomMargin ;break;case CustomLayoutParams. POSITION_LEFT: // 左上方left = 0 + params. leftMargin;top = 0 + params. topMargin;break;case CustomLayoutParams. POSITION_RIGHT: // 右上方left = getWidth()-childMeasureWidth - params.rightMargin;top = 0 + params. topMargin;break;case CustomLayoutParams. POSITION_BOTTOM: // 左下角left = 0 + params. leftMargin;top = getHeight()-childMeasureHeight-params.bottomMargin ;break;case CustomLayoutParams. POSITION_RIGHTANDBOTTOM:// 右下角left = getWidth()-childMeasureWidth - params.rightMargin;top = getHeight()-childMeasureHeight-params.bottomMargin ;break;default:break;&#125;// 确定子控件的位置，四个参数分别代表（左上右下）点的坐标值child.layout(left, top, left+childMeasureWidth, top+childMeasureHeight);&#125;&#125; 运行效果： 好了，就写到这里，如果想尝试设置其他属性，比如above、below等，也是可以的。最后，要隆重推荐一下作者：扔物线写的关于自定义View绘制的一系列文章，写的真的很用心，大赞。 参考资料自定义View教程1自定义View教程2]]></content>
      <categories>
        <category>Android View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit使用详解及源码分析]]></title>
    <url>%2F2017%2F09%2F06%2FRetrofit%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Retrofit是Square团队旗下一个知名的Android网络请求库，准确的说，它是由Square对okhttp再次封装所成。本章在详细的介绍Retrofit用法的同时，还会分析它的前世今生，包括okhttp介绍、源码分析、java注解的掌握以及Retrofit的二次封装知识。 从okhttp的使用讲起前面说了Retrofit是在Okhttp的基础之上发展起来，那么要想全面的理解之，还是要把okhttp这块的用法搞懂的（不涉及源码），下面就从okhttp开始吧～ okHttp主要类下面是okhttp的几大主要类，这一部分的内容就围绕它们进行。OkHttpClient.javaRequest.javaCall.javaRequestBody.javaResponse.java 用法HTTP GET12345678910111213141516171819202122232425package okhttp3.guide;import java.io.IOException;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class GetExample &#123;OkHttpClient client = new OkHttpClient();String run(String url) throws IOException &#123;Request request = new Request.Builder().url(url).build();Response response = client.newCall(request).execute();return response.body().string();&#125;public static void main(String[] args) throws IOException &#123;GetExample example = new GetExample();String response = example.run(&quot;https://raw.github.com/square/okhttp/master/README.md&quot;);System.out.println(response);&#125;&#125; 上面执行的流程是这样的：第一步，在程序第9行处获取了okhttpclient的实例；第二步，在程序第12行处，通过Request.Builder()构建一个request请求对象，这里可以配置许多网络请求所需的参数：url、header、post对象等。第三步，在程序第16行处，通过Call类的execute()同步方法返回一个response响应对象，对象中包含了服务端返回的字符串信息。至此，一个简单的Http Get流程算是完成了。这里要注意的是:1、在第二步中，我们说通过Request.Builder()可以配置许多网络请求相关的信息，其实我们还可以通过okHttpClient.newBuilder()方法配置一些更加全局的网络参数，比如：拦截器、超时时间等。2、在第二步中提到配置的参数可以是post对象，它对应的方法是post(RequestBody body)，那么有没有提供类似get(T params)的方法供请求参数的配置呢？答案是没有。所以如果需要在url中配置请求参数，还需要以拼接字符串的方式完成。3、在第三步中除了能用Call类的execute()同步方法返回响应之外，还可以使用它的enqueue()方法异步返回响应信息，这里要看具体的使用场景了。 HTTP POST123456789101112131415161718192021222324252627282930313233343536public class PostExample &#123;public static final MediaType JSON= MediaType.parse(&quot;application/json; charset=utf-8&quot;);OkHttpClient client = new OkHttpClient();String post(String url, String json) throws IOException &#123;RequestBody body = RequestBody.create(JSON, json);Request request = new Request.Builder().url(url).post(body).build();try (Response response = client.newCall(request).execute()) &#123;return response.body().string();&#125;&#125;String bowlingJson(String player1, String player2) &#123;return &quot;&#123;&apos;winCondition&apos;:&apos;HIGH_SCORE&apos;,&quot;+ &quot;&apos;name&apos;:&apos;Bowling&apos;,&quot;+ &quot;&apos;round&apos;:4,&quot;+ &quot;&apos;lastSaved&apos;:1367702411696,&quot;+ &quot;&apos;dateStarted&apos;:1367702378785,&quot;+ &quot;&apos;players&apos;:[&quot;+ &quot;&#123;&apos;name&apos;:&apos;&quot; + player1 + &quot;&apos;,&apos;history&apos;:[10,8,6,7,8],&apos;color&apos;:-13388315,&apos;total&apos;:39&#125;,&quot;+ &quot;&#123;&apos;name&apos;:&apos;&quot; + player2 + &quot;&apos;,&apos;history&apos;:[6,10,5,10,10],&apos;color&apos;:-48060,&apos;total&apos;:41&#125;&quot;+ &quot;]&#125;&quot;;&#125;public static void main(String[] args) throws IOException &#123;PostExample example = new PostExample();String json = example.bowlingJson(&quot;Jesse&quot;, &quot;Jake&quot;);String response = example.post(&quot;http://www.roundsapp.com/post&quot;, json);System.out.println(response);&#125;&#125; 上面是一个向服务端发送Post请求的例子，仔细观察发现它和Get部分的不同之处主要在于第11行的post(body)配置方法。参数body是我们需要上传到服务器的数据，他是RequestBody类型的对象，该对象由RequestBody.create(MediaType contentType, T t)方法生成。MediaType代表消息内容的类型，具体可翻阅Media Types、MIME 参考手册这两篇文章。后面的T对象由MediaType的类型决定，可以看出RequestBody.create是一个重载方法。对于RequestBody，api还提供了它的两个实现类：FormBody、MultipartBody，分别对应表单和文件的上传。当然，OkHttp在实际应用中可能还会涉及到需要重复验证的问题，具体请结合这篇文章以及掘金网的这篇文章看看。 Retrofit的使用有了前面okhttp的使用经验，再来说Retrofit的使用就简单了。Retrofit其实质就是对okHttp的封装，使用面向接口的方式进行网络请求，利用动态生成的代理类封装了网络接口。Retrofit非常适合于 RESTful 风格的请求，使用注解的方式提供功能，对于注解不了解的同学，还可以结合这篇文章看看。 RESTful特征：URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。 用法介绍创建API接口在retrofit中通过一个Java接口作为http请求的api接口。12345//定以接口public interface GitHubService &#123;@GET(&quot;users/&#123;user&#125;/repos&quot;)Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);&#125; 创建Retrofit实例123456789/**获取实例*/Retrofit retrofit = new Retrofit.Builder()//设置OKHttpClient,如果不设置会提供一个默认的.client(new OkHttpClient())//设置baseUrl.baseUrl(&quot;https://api.github.com/&quot;)//添加Gson转换器.addConverterFactory(GsonConverterFactory.create()).build(); 注意：1.retrofit2.0后：BaseUrl要以/结尾；@GET 等请求不要以/开头；@Url: 可以定义完整url，不要以 / 开头。2.addConverterFactory提供Gson支持，可以添加多种序列化Factory，但是GsonConverterFactory必须放在最后,否则会抛出异常。 调用API接口1234567891011121314151617181920212223242526272829303132GitHubService service = retrofit.create(GitHubService.class);//同步请求//https://api.github.com/users/octocat/reposCall&lt;List&lt;Repo&gt;&gt; call = service.listRepos(&quot;octocat&quot;);try &#123;Response&lt;List&lt;Repo&gt;&gt; repos = call.execute();&#125; catch (IOException e) &#123;e.printStackTrace();&#125;//不管同步还是异步，call只能执行一次。否则会抛 IllegalStateExceptionCall&lt;List&lt;Repo&gt;&gt; clone = call.clone();//异步请求clone.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() &#123;@Overridepublic void onResponse(Response&lt;List&lt;Repo&gt;&gt; response, Retrofit retrofit) &#123;// Get result bean from response.body()List&lt;Repo&gt; repos = response.body();// Get header item from responseString links = response.headers().get(&quot;Link&quot;);/*** 不同于retrofit1 可以同时操作序列化数据javabean和header*/&#125;@Overridepublic void onFailure(Throwable throwable) &#123;showlog(throwable.getCause().toString()); &#125;&#125;); 取消请求我们可以终止一个请求。终止操作是对底层的httpclient执行cancel操作。即使是正在执行的请求，也能够立即终止。1call.cancel(); retrofit注解 方法注解，包含@GET、@POST、@PUT、@DELETE、@PATH、@HEAD、@OPTIONS、@HTTP。 标记注解，包含@FormUrlEncoded、@Multipart、@Streaming。 参数注解，包含@Query、@QueryMap、@Body、@Field，@FieldMap、@Part，@PartMap。 其他注解，包含@Path、@Header、@Headers、@Url。 (1)一般的get请求1234public interface IWeatherGet &#123;@GET(&quot;GetMoreWeather?cityCode=101020100&amp;weatherType=0&quot;)Call&lt;Weather&gt; getWeather();&#125; 可以看到有一个getWeather(）方法，通过@GET注解标识为get请求，@GET中所填写的value和baseUrl组成完整的路径，baseUrl在构造retrofit对象时给出。123456789101112131415161718192021Retrofit retrofit = new Retrofit.Builder()/**http://weather.51wnl.com/weatherinfo/GetMoreWeather?cityCode=101020100&amp;weatherType=0*///注意baseurl要以/结尾.baseUrl(&quot;http://weather.51wnl.com/weatherinfo/&quot;).addConverterFactory(GsonConverterFactory.create()).build();IWeatherGet weather = retrofit.create(IWeatherGet.class);Call&lt;Weather&gt; call = weather.getWeather();call.enqueue(new Callback&lt;Weather&gt;() &#123;@Overridepublic void onResponse(Response&lt;Weather&gt; response, Retrofit retrofit) &#123;Weather weather = response.body();WeatherInfo weatherinfo = weather.weatherinfo;showlog(&quot;weather=&quot;+weatherinfo.toString());&#125;@Overridepublic void onFailure(Throwable throwable) &#123;showlog(throwable.getCause().toString()); &#125;&#125;); （2）动态url访问@PATH上面说的@GET注解是将baseUrl和@GET中的value组成完整的路径。有时候我们可以将路径中某个字符串设置为不同的值来请求不同的数据，这时候怎么办呢？譬如：可以通过retrofit提供的@PATH注解非常方便的完成上述需求。1234public interface IWeatherPath &#123;@GET(&quot;&#123;info&#125;?cityCode=101020100&amp;weatherType=0&quot;)Call&lt;Weather&gt; getWeather(@Path(&quot;info&quot;) String info);&#125; 可以看到我们定义了一个getWeather方法，方法接收一个info参数，并且我们的@GET注解中使用{info}?cityCode=101020100&amp;weatherType=0声明了访问路径，这里你可以把{info}当做占位符，而实际运行中会通过@PATH(“info”)所标注的参数进行替换。 （3）查询参数的设置@Query@QueryMap文章开头提过，retrofit非常适用于restful url的格式，那么例如下面这样的url：12345//用于访问上海天气http://weather.51wnl.com/weatherinfo/GetMoreWeather?cityCode=101020100&amp;weatherType=0//用于访问北京天气http://weather.51wnl.com/weatherinfo/GetMoreWeather?cityCode=101010100&amp;weatherType=0 即通过传参方式使用不同的citycode访问不同城市的天气，返回数据为json字符串。我们可以通过@Query注解方便的完成，我们再次在接口中添加一个方法：12345678public interface IWeatherQuery &#123;@GET(&quot;GetMoreWeather&quot;)Call&lt;Weather&gt; getWeather(@Query(&quot;cityCode&quot;) String cityCode, @Query(&quot;weatherType&quot;) String weatherType);&#125;/**省略retrofit的构建代码*/Call&lt;Weather&gt; call = weather.getWeather(&quot;101020100&quot;, &quot;0&quot;);//Call&lt;Weather&gt; call = weather.getWeather(&quot;101010100&quot;, &quot;0&quot;);/**省略call执行相关代码*/ 当我们的参数过多的时候我们可以通过@QueryMap注解和map对象参数来指定每个表单项的Key，value的值，同样是上面的例子，还可以这样写：12345678910public interface IWeatherQueryMap &#123;@GET(&quot;GetMoreWeather&quot;)Call&lt;Weather&gt; getWeather(@QueryMap Map&lt;String,String&gt; map);&#125;//省略retrofit的构建代码Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();map.put(&quot;cityCode&quot;, &quot;101020100&quot;);map.put(&quot;weatherType&quot;, &quot;0&quot;);Call&lt;Weather&gt; call = weather.getWeather(map);//省略call执行相关代码 （4）POST请求体方式向服务器传入json字符串@Body我们app很多时候跟服务器通信，会选择直接使用POST方式将json字符串作为请求体发送到服务器，那么我们看看这个需求使用retrofit该如何实现。1234567public interface IUser &#123;@POST(&quot;add&quot;)Call&lt;List&lt;User&gt;&gt; addUser(@Body User user);&#125;/省略retrofit的构建代码Call&lt;List&lt;User&gt;&gt; call = user.addUser(new User(&quot;watson&quot;, &quot;male&quot;, &quot;28&quot;));//省略call执行相关代码 可以看到其实就是使用@Body这个注解标识我们的参数对象即可，那么这里需要考虑一个问题，retrofit是如何将user对象转化为字符串呢？将实例对象根据转换方式转换为对应的json字符串参数，这个转化方式是GsonConverterFactory定义的。对应okhttp，还有两种requestBody，一个是FormBody，一个是MultipartBody，前者以表单的方式传递简单的键值对，后者以表单的方式上传文件可以携带参数，retrofit也二者也有对应的注解，下面继续~ （5）表单的方式传递键值对@FormUrlEncoded + @Field@FieldMap这里我们模拟一个登录的方法，添加一个方法：12345678public interface IUser &#123;@FormUrlEncoded@POST(&quot;login&quot;) Call&lt;User&gt; login(@Field(&quot;username&quot;) String username, @Field(&quot;password&quot;) String password);&#125;//省略retrofit的构建代码Call&lt;User&gt; call = user.login(&quot;watson&quot;, &quot;123&quot;);//省略call执行相关代码 看起来也很简单，通过@POST指明url，添加FormUrlEncoded，然后通过@Field添加参数即可。当我们有很多个表单参数时也可以通过@FieldMap注解和Map对象参数来指定每个表单项的Key，value的值。1234567891011public interface IUser &#123;@FormUrlEncoded@POST(&quot;login&quot;) Call&lt;User&gt; login(@FieldMap Map&lt;String,String&gt; fieldMap);&#125;//省略retrofit的构建代码Map&lt;String, String&gt; propertity = new HashMap&lt;String, String&gt;();positories.put(&quot;name&quot;, &quot;watson&quot;);positories.put(&quot;password&quot;, &quot;123&quot;);Call&lt;User&gt; call = user.login(propertity);//省略call执行相关代码 （6）文件上传@Multipart + @Part@PartMap1.下面先看一下单文件上传，依然是再次添加个方法：12345public interface IUser &#123;@Multipart@POST(&quot;register&quot;)Call&lt;User&gt; registerUser(@Part MultipartBody.Part photo, @Part(&quot;username&quot;) RequestBody username, @Part(&quot;password&quot;) RequestBody password);&#125; 这里@MultiPart的意思就是允许多个@Part了，我们这里使用了3个@Part，第一个我们准备上传个文件，使用了MultipartBody.Part类型，其余两个均为简单的键值对。12345File file = new File(Environment.getExternalStorageDirectory(), &quot;icon.png&quot;);RequestBody photoRequestBody = RequestBody.create(MediaType.parse(&quot;image/png&quot;), file);MultipartBody.Part photo = MultipartBody.Part.createFormData(&quot;photos&quot;, &quot;icon.png&quot;, photoRequestBody);Call&lt;User&gt; call = user.registerUser(photo, RequestBody.create(null, &quot;abc&quot;), RequestBody.create(null, &quot;123&quot;)); 这里感觉略为麻烦。不过还是蛮好理解~~多个@Part，每个Part对应一个RequestBody。注：这里还有另外一个方案也是可行的：12345public interface ApiInterface &#123;@Multipart@POST (&quot;/api/Accounts/editaccount&quot;)Call&lt;User&gt; editUser (@Header(&quot;Authorization&quot;) String authorization, @Part(&quot;photos\&quot;; filename=\&quot;icon.png&quot;) RequestBody file , @Part(&quot;FirstName&quot;) RequestBody fname, @Part(&quot;Id&quot;) RequestBody id);&#125; 这个value设置的值不用看就会觉得特别奇怪，然而却可以正常执行，原因是什么呢？当上传key-value的时候，实际上对应这样的代码：1builder.addPart(Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;&quot; + key + &quot;\&quot;&quot;), RequestBody.create(null, params.get(key))); 也就是说，我们的@Part转化为了1Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;&quot; + key + &quot;\&quot;&quot;) 这么一看，很随意，只要把key放进去就可以了。但是，retrofit2并没有对文件做特殊处理，文件的对应的字符串应该是这样的1Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=&quot;photos&quot;;filename=&quot;icon.png&quot;&quot;); 与键值对对应的字符串相比，多了个\”; filename=\”icon.png，就因为retrofit没有做特殊处理，所以你现在看这些hack的做法123456@Part(&quot;photos\&quot;; filename=\&quot;icon.png&quot;)==&gt; key = photos\&quot;; filename=\&quot;icon.pngform-data; name=\&quot;&quot; + key + &quot;\&quot;拼接结果：==&gt;form-data; name=&quot;photos&quot;; filename=&quot;icon.png&quot; 因为这种方式文件名写死了，我们上文使用的的是@Part MultipartBody.Part file,可以满足文件名动态设置。 2.如果是多文件上传呢？12345public interface IUser &#123;@Multipart@POST(&quot;register&quot;)Call&lt;User&gt; registerUser(@PartMap Map&lt;String, RequestBody&gt; params, @Part(&quot;password&quot;) RequestBody password);&#125; 这里使用了一个新的注解@PartMap，这个注解用于标识一个Map，Map的key为String类型，代表上传的键值对的key(与服务器接受的key对应),value即为RequestBody，有点类似@Part的封装版本。1234567File file = new File(Environment.getExternalStorageDirectory(), &quot;local.png&quot;);RequestBody photo = RequestBody.create(MediaType.parse(&quot;image/png&quot;, file);Map&lt;String, RequestBody&gt; map = new HashMap&lt;&gt;(String, RequestBody);map.put(&quot;photos\&quot;; filename=\&quot;icon.png&quot;, photo);map.put(&quot;username&quot;, RequestBody.create(null, &quot;abc&quot;));Call&lt;User&gt; call = user.registerUser(map, RequestBody.create(null, &quot;123&quot;)); 可以看到，可以在Map中put进一个或多个文件，键值对等，当然你也可以分开，单独的键值对也可以使用@Part，这里又看到设置文件的时候，相对应的key很奇怪，例如上例”photos\”; filename=\”icon.png”,前面的photos就是与服务器对应的key，后面filename是服务器得到的文件名，ok，参数虽然奇怪，但是也可以动态的设置文件名，不影响使用。 （7）下载文件1234567891011121314@GET(&quot;download&quot;)Call&lt;ResponseBody&gt; downloadTest();Call&lt;ResponseBody&gt; call = user.downloadTest();call.enqueue(new Callback&lt;ResponseBody&gt;() &#123;@Overridepublic void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123;InputStream is = response.body().byteStream();//save file&#125;@Overridepublic void onFailure(Call&lt;ResponseBody&gt; call, Throwable t)&#123;&#125;&#125;); （8）添加请求头@Header@Headers@Header：header处理，不能被互相覆盖，所有具有相同名字的header将会被包含到请求中。1234//静态设置Header值@Headers(&quot;Authorization: authorization&quot;)@GET(&quot;widget/list&quot;)Call&lt;User&gt; getUser() @Headers 用于修饰方法,用于设置多个Header值。123456@Headers(&#123;&quot;Accept: application/vnd.github.v3.full+json&quot;,&quot;User-Agent: Retrofit-Sample-App&quot;&#125;)@GET(&quot;users/&#123;username&#125;&quot;)Call&lt;User&gt; getUser(@Path(&quot;username&quot;) String username); 还可以使用@Header注解动态的更新一个请求的header。必须给@Header提供相应的参数，如果参数的值为空header将会被忽略，否则就调用参数值的toString()方法并使用返回结果。123//动态设置Header值@GET(&quot;user&quot;)Call&lt;User&gt; getUser(@Header(&quot;Authorization&quot;) String authorization) 配置OkHttpClient很多时候，比如你使用retrofit需要统一的log管理，缓存管理，给每个请求添加统一的header等，这些都应该通过okhttpclient去操作。Retrofit 2.0 底层依赖于okHttp，所以需要使用okHttp的Interceptors来对所有请求进行拦截。12345678910111213141516OkHttpClient client = new OkHttpClient();client.networkInterceptors().add(new Interceptor() &#123;@Overridepublic com.squareup.okhttp.Response intercept(Chain chain) throws IOException &#123;com.squareup.okhttp.Response response = chain.proceed(chain.request());// Do anything with response herereturn response;&#125;&#125;);Retrofit retrofit = new Retrofit.Builder().baseUrl(BASE_URL)....client(client) //传入自己定义的client.build(); 或许你需要更多的配置，你可以单独写一个OkhttpClient的单例生成类，在这个里面完成你所需的所有的配置，然后将OkhttpClient实例通过方法公布出来，设置给retrofit。123Retrofit retrofit = new Retrofit.Builder().callFactory(OkHttpUtils.getClient()).build(); callFactory方法接受一个okhttp3.Call.Factory对象，OkHttpClient即为一个实现类。 Retrofit2.0源码分析接下来我们对retrofit的源码做简单的分析，首先我们看retrofit如何为我们的接口实现实例；然后看整体的执行流程；最后再看详细的细节； （1）retrofit如何为我们的接口实现实例使用retrofit需要去定义一个接口，然后可以通过调用retrofit.create(IUser.class)方法，得到一个接口的实例，最后通过该实例执行我们的操作，那么retrofit如何实现我们指定接口的实例呢？其实原理是：动态代理。但是不要被动态代理这几个词吓唬到，Java中已经提供了非常简单的API帮助我们来实现动态代理。看源码前先看一个例子：12345678910111213141516171819202122232425public interface ITest&#123;@GET(&quot;/heiheihei&quot;)public void add(int a, int b);&#125;public static void main(String[] args)&#123;ITest iTest = (ITest) Proxy.newProxyInstance(ITest.class.getClassLoader(), new Class&lt;?&gt;[]&#123;ITest.class&#125;, new InvocationHandler()&#123;@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123;Integer a = (Integer) args[0];Integer b = (Integer) args[1];System.out.println(&quot;方法名：&quot; + method.getName());System.out.println(&quot;参数：&quot; + a + &quot; , &quot; + b);GET get = method.getAnnotation(GET.class);System.out.println(&quot;注解：&quot; + get.value());return null;&#125;&#125;);iTest.add(3, 5);&#125; 输出结果为：123方法名：add参数：3 , 5注解：/heiheihei 可以看到我们通过Proxy.newProxyInstance产生的代理类，当调用接口的任何方法时，都会调用InvocationHandler#invoke方法，在这个方法中可以拿到传入的参数，注解等。其实retrofit也可以通过同样的方式，在invoke方法里面，拿到所有的参数，注解信息然后就可以去构造RequestBody，再去构建Request，得到Call对象封装后返回。下面看retrofit#create的源码：1234567public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,new InvocationHandler() &#123;@Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123;&#125;);&#125; 和上面对应。到这里，你应该明白retrofit为我们接口生成实例对象并不神奇，仅仅是使用了Proxy这个类的API而已，然后在invoke方法里面拿到足够的信息去构建最终返回的Call而已。 （2）retrofit整体实现流程Retrofit的构建：这里依然是通过构造者模式进行构建retrofit对象，好在其内部的成员变量比较少，我们直接看build()方法。1234567891011121314151617181920212223242526272829public Builder() &#123;this(Platform.get());&#125;public Retrofit build() &#123;if (baseUrl == null) &#123;throw new IllegalStateException(&quot;Base URL required.&quot;);&#125;okhttp3.Call.Factory callFactory = this.callFactory;if (callFactory == null) &#123;callFactory = new OkHttpClient();&#125;Executor callbackExecutor = this.callbackExecutor;if (callbackExecutor == null) &#123;callbackExecutor = platform.defaultCallbackExecutor();&#125;// Make a defensive copy of the adapters and add the default Call adapter.List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));// Make a defensive copy of the converters.List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories);return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,callbackExecutor, validateEagerly);&#125; baseUrl必须指定，这个是理所当然的； 然后可以看到如果不着急设置callFactory，则默认直接new OkHttpClient()，可见如果你需要对okhttpclient进行详细的设置，需要构建OkHttpClient对象，然后传入；接下来是callbackExecutor，这个想一想大概是用来将回调传递到UI线程了，当然这里设计的比较巧妙，利用platform对象，对平台进行判断，判断主要是利用Class.forName(“”)进行查找，如果是Android平台，会自定义一个Executor对象，并且利用Looper.getMainLooper()实例化一个handler对象，在Executor内部通过handler.post(runnable)，ok，整理凭大脑应该能构思出来，暂不贴代码了。接下来是adapterFactories，这个对象主要用于对Call进行转化，基本上不需要我们自己去自定义。最后是converterFactories，该对象用于转化数据，例如将返回的responseBody转化为对象等；当然不仅仅是针对返回的数据，还能用于一般注解的参数的转化，例如@Body标识的对象做一些操作，后面遇到源码详细再描述。具体Call构建流程：我们构造完成retrofit，就可以利用retrofit.create方法去构建接口的实例了，上面我们已经分析了这个环节利用了动态代理，而且我们也分析了具体的Call的构建流程在invoke方法中，下面看代码：1234567891011121314public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;Utils.validateServiceInterface(service);//...return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,new InvocationHandler() &#123;@Override public Object invoke(Object proxy, Method method, Object... args)&#123;//...ServiceMethod serviceMethod = loadServiceMethod(method);OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);return serviceMethod.callAdapter.adapt(okHttpCall);&#125;&#125;);&#125; 主要也就三行代码，第一行是根据我们的method将其包装成ServiceMethod，第二行是通过ServiceMethod和方法的参数构造retrofit2.OkHttpCall对象，第三行是通过serviceMethod.callAdapter.adapt()方法，将OkHttpCall进行代理包装。总结一下： 首先构造retrofit，几个核心的参数呢，主要就是baseurl,callFactory(默认okhttpclient),converterFactories,adapterFactories,excallbackExecutor。 然后通过create方法拿到接口的实现类，这里利用Java的Proxy类完成动态代理的相关代理。 在invoke方法内部，拿到我们所声明的注解以及实参等，构造ServiceMethod，ServiceMethod中解析了大量的信息，最终可以通过toRequest构造出okhttp3.Request对象。有了okhttp3.Request对象就可以很自然的构建出okhttp3.call，最后calladapter对Call进行装饰返回。 拿到Call就可以执行enqueue或者execute方法了。 结束语最后在推荐一个非常火的网络调试工具：stetho。利用它你可以非常方便地查看应用的本地数据库、SharePerence、网络请求等数据。这里有一篇关于它的使用指南。 参考资料OkHttpAndroid Retrofit框架解析]]></content>
      <categories>
        <category>Android框架</category>
      </categories>
      <tags>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android屏幕适配方案]]></title>
    <url>%2F2017%2F08%2F03%2FAndroid%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[Android的屏幕适配一直以来都在折磨着我们这些开发者，本篇文章将以Google的官方文档为基础，全面而深入的讲解Android屏幕适配的原因、重要概念、解决方案及最佳实践。 Android屏幕适配出现的原因Android的屏幕尺寸很多，为了让我们开发的程序能够比较美观的显示在不同尺寸、分辨率、像素密度(这些概念我会在下面详细讲解)的设备上，那就要在开发的过程中进行处理，至于如何去进行处理，这就是我们今天的主题了。 重要概念什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？什么是dp、dip、dpi、sp、px？他们之间的关系是什么？什么是mdpi、hdpi、xdpi、xxdpi？如何计算和区分？在下面的内容中我们将介绍这些概念。 屏幕尺寸屏幕尺寸指屏幕的对角线的长度，单位是英寸，1英寸=2.54厘米。比如常见的屏幕尺寸有2.4、2.8、3.5、3.7、4.2、5.0、5.5、6.0等。 屏幕分辨率屏幕分辨率是指在横纵向上的像素点数，单位是px，1px=1个像素点。一般以纵向像素*横向像素，如1960*1080。 屏幕像素密度屏幕像素密度是指每英寸上的像素点数，单位是dpi，即“dot per inch”的缩写。屏幕像素密度与屏幕尺寸和屏幕分辨率有关，在单一变化条件下，屏幕尺寸越小、分辨率越高，像素密度越大，反之越小。 dp、dip、dpi、sp、pxpx我们应该是比较熟悉的，前面的分辨率就是用的像素为单位，大多数情况下，比如UI设计、Android原生API都会以px作为统一的计量单位，像是获取屏幕宽高等。dip和dp是一个意思，都是Density Independent Pixels的缩写，即密度无关像素，上面我们说过，dpi是屏幕像素密度，假如一英寸里面有160个像素，这个屏幕的像素密度就是160dpi，那么在这种情况下，dp和px如何换算呢？在Android中，规定以160dpi为基准，1dip=1px，如果密度是320dpi，则1dip=2px，以此类推。假如同样都是画一条320px的线，在480*800分辨率手机上显示为2/3屏幕宽度，在320*480的手机上则占满了全屏，如果使用dp为单位，在这两种分辨率下，160dp都显示为屏幕一半的长度。这也是为什么在Android开发中，写布局的时候要尽量使用dp而不是px的原因。而sp，即scale-independent pixels，除了拥有dp的特性，还会随着系统的字体大小改变而改变，建议在设置字体大小的数值要使用sp作为单位，具体可参考这篇文章。sp与dp之间的转换方法如下：12345678910111213141516171819public static int px2dip(Context context, float pxValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125; public static int dip2px(Context context, float dipValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dipValue * scale + 0.5f); &#125;public static int px2sp(Context context, float pxValue) &#123; final float fontScale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (pxValue / fontScale + 0.5f); &#125; public static int sp2px(Context context, float spValue) &#123; final float fontScale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (spValue * fontScale + 0.5f); &#125; mdpi、hdpi、xdpi、xxdpi其实之前还有个ldpi，但是随着移动设备配置的不断升级，这个像素密度的设备已经很罕见了，所在现在适配时不需考虑。mdpi、hdpi、xdpi、xxdpi用来修饰Android中的drawable文件夹及values文件夹，用来区分不同像素密度下的图片和dimen值。那么如何区分呢？Google官方指定按照下列标准进行区分： 名称 像素密度范围 mdpi 120dpi~160dpi hdpi 160dpi~240dpi xhdpi 240dpi~320dpi xxhdpi 320dpi~480dpi xxxhdpi 480dpi~640dpi 在进行开发的时候，我们需要把合适大小的图片放在合适的文件夹里面。下面以图标设计为例进行介绍。在设计图标时，对于五种主流的像素密度（MDPI、HDPI、XHDPI、XXHDPI 和 XXXHDPI）应按照 2:3:4:6:8 的比例进行缩放。例如，一个启动图标的尺寸为48x48 dp，这表示在 MDPI 的屏幕上其实际尺寸应为 48x48 px，在 HDPI 的屏幕上其实际大小是 MDPI 的 1.5 倍 (72x72 px)，在 XDPI 的屏幕上其实际大小是 MDPI 的 2 倍 (96x96 px)，依此类推。虽然 Android 也支持低像素密度 (LDPI) 的屏幕，但无需为此费神，系统会自动将 HDPI 尺寸的图标缩小到 1/2 进行匹配。下图为图标的各个屏幕密度的对应尺寸: 屏幕密度 图标尺寸 mdpi 48x48px hdpi 72x72px xhdpi 96x96px xxhdpi 144x144px xxxhdpi 192x192px 解决方案支持各种屏幕尺寸使用wrap_content、match_parent、weight为了确保布局的灵活性并适应各种尺寸的屏幕，应尽量使用 “wrap_content” 和 “match_parent” 控制某些视图组件的宽度和高度。使用 “wrap_content”，系统就会将视图的宽度或高度设置成所需的最小尺寸以适应视图中的内容，而 “match_parent”（在低于 API 级别 8 的级别中称为 “fill_parent”）则会展开组件以匹配其父视图的尺寸。weight是线性布局的一个独特的属性，我们可以使用这个属性来按照比例对界面进行分配，完成一些特殊的需求。但是，我们对于这个属性的计算应该如何理解呢？首先，我们将布局设置为线性布局，横向排列，然后放置两个宽度为0dp的按钮，分别设置weight为1和2，我们可以想象到两个按钮按照1：2的宽度比例正常排列了，这也是我们经常使用到的场景。但是假如我们的宽度不是0dp(wrap_content和0dp的效果相同)，而是match_parent呢？在这种情况下，占比和上面正好相反，这是怎么回事呢？说到这里，我们就不得不提一下weight的计算方法了。android:layout_weight的真实含义是:如果View设置了该属性并且有效，那么该 View的宽度等于原有宽度+剩余空间的占比。从这个角度我们来解释一下上面的现象。在上面的代码中，我们设置每个Button的宽度都是match_parent，假设屏幕宽度为L，那么每个Button的宽度也应该都为L，剩余宽度就等于L-（L+L）= -L。Button1的weight=1，所以最终宽度为L+1/3*(-L)=2/3L，Button2的计算类似，最终宽度为L+2/3(-L)=1/3L。同时，垂直方向上的结论和水平是完全一样的。虽然说我们演示了match_parent的显示效果，并说明了原因，但是在真正用的时候，我们都是设置某一个属性为0dp，然后按照权重计算所占百分比。 使用相对布局，禁用绝对布局在开发中，我们大部分时候使用的都是线性布局、相对布局和帧布局，绝对布局由于适配性极差，所以极少使用。由于各种布局的特点不一样，所以不能说哪个布局好用，到底应该使用什么布局只能根据实际需求来确定。我们可以使用 LinearLayout 的嵌套实例并结合 “wrap_content” 和 “match_parent”，以便构建相当复杂的布局。不过，我们无法通过 LinearLayout 精确控制子视图的特殊关系；系统会将 LinearLayout 中的视图直接并排列出。如果我们需要将子视图排列出各种效果而不是一条直线，通常更合适的解决方法是使用 RelativeLayout，这样就可以根据各组件之间的特殊关系指定布局了。例如，我们可以将某个子视图对齐到屏幕左侧，同时将另一个视图对齐到屏幕右侧。 使用限定符使用尺寸限定符上面所提到的灵活布局或者是相对布局，可以为我们带来的优势就只有这么多了。虽然这些布局可以拉伸组件内外的空间以适应各种屏幕，但它们不一定能为每种屏幕都提供最佳的用户体验。因此，我们的应用不仅仅只实施灵活布局，还应该应针对各种屏幕配置提供一些备用布局。如何做到这一点呢？我们可以通过使用配置限定符，在运行时根据当前的设备配置自动选择合适的资源了，例如根据各种屏幕尺寸选择不同的布局。很多应用会在较大的屏幕上实施“双面板”模式，即在一个面板上显示项目列表，而在另一面板上显示对应内容。平板电脑和电视的屏幕已经大到可以同时容纳这两个面板了，但手机屏幕就需要分别显示。因此，我们可以使用以下文件以便实施这些布局：res/layout/main.xml，单面板（默认）布局：12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:orientation=&quot;vertical&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;fragment android:id=&quot;@+id/headlines&quot;android:layout_height=&quot;fill_parent&quot;android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout-large/main.xml，双面板布局：1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;fill_parent&quot;android:orientation=&quot;horizontal&quot;&gt;&lt;fragment android:id=&quot;@+id/headlines&quot;android:layout_height=&quot;fill_parent&quot;android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;android:layout_width=&quot;400dp&quot;android:layout_marginRight=&quot;10dp&quot;/&gt;&lt;fragment android:id=&quot;@+id/article&quot;android:layout_height=&quot;fill_parent&quot;android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 请注意第二种布局名称目录中的 large 限定符。系统会在属于较大屏幕（例如 7 英寸或更大的平板电脑）的设备上选择此布局。系统会在较小的屏幕上选择其他布局（无限定符）。 使用最小宽度限定符在版本低于 3.2 的 Android 设备上，开发人员遇到的问题之一是“较大”屏幕的尺寸范围，该问题会影响戴尔 Streak、早期的 Galaxy Tab 以及大部分 7 英寸平板电脑。即使这些设备的屏幕属于“较大”的尺寸，但很多应用可能会针对此类别中的各种设备显示不同的布局（“较大”的概念不清晰导致的）。这就是 Android 3.2 版在引入其他限定符的同时引入“最小宽度”限定符的原因。最小宽度限定符可让您通过指定某个最小宽度（以 dp 为单位）来定位屏幕。例如，标准 7 英寸平板电脑的最小宽度为 600 dp，因此如果您要在此类屏幕上的用户界面中使用双面板（但在较小的屏幕上只显示列表），您可以使用上文中所述的单面板和双面板这两种布局，但您应使用 sw600dp 指明双面板布局仅适用于最小宽度为 600 dp 的屏幕，而不是使用 large 尺寸限定符。res/layout/main.xml，单面板（默认）布局：12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:orientation=&quot;vertical&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;fragment android:id=&quot;@+id/headlines&quot;android:layout_height=&quot;fill_parent&quot;android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout-sw600dp/main.xml，双面板布局：1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;fill_parent&quot;android:orientation=&quot;horizontal&quot;&gt;&lt;fragment android:id=&quot;@+id/headlines&quot;android:layout_height=&quot;fill_parent&quot;android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;android:layout_width=&quot;400dp&quot;android:layout_marginRight=&quot;10dp&quot;/&gt;&lt;fragment android:id=&quot;@+id/article&quot;android:layout_height=&quot;fill_parent&quot;android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 也就是说，对于最小宽度大于等于 600 dp 的设备，系统会选择 layout-sw600dp/main.xml（双面板）布局，否则系统就会选择 layout/main.xml（单面板）布局。但 Android 版本低于 3.2 的设备不支持此技术，原因是这些设备无法将 sw600dp 识别为尺寸限定符，因此我们仍需使用 large 限定符。这样一来，就会有一个名称为 res/layout-large/main.xml 的文件（与 res/layout-sw600dp/main.xml 一样）。但是没有太大关系，我们将马上学习如何避免此类布局文件出现的重复。 使用布局别名最小宽度限定符仅适用于 Android 3.2 及更高版本。因此，如果我们仍需使用与较低版本兼容的概括尺寸范围（小、正常、大和特大）。例如，如果要将用户界面设计成在手机上显示单面板，但在 7 英寸平板电脑、电视和其他较大的设备上显示多面板，那么我们就需要提供以下文件： res/layout/main.xml: 单面板布局 res/layout-large: 多面板布局 res/layout-sw600dp: 多面板布局 后两个文件是相同的，因为其中一个用于和 Android 3.2 设备匹配，而另一个则是为使用较低版本 Android 的平板电脑和电视准备的。要避免平板电脑和电视的文件出现重复（以及由此带来的维护问题），您可以使用别名文件。例如，您可以定义以下布局： res/layout/main.xml，单面板布局 res/layout/main_twopanes.xml，双面板布局 然后添加这两个文件：res/values-large/layout.xml:123&lt;resources&gt;&lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;&lt;/resources&gt; res/values-sw600dp/layout.xml:123&lt;resources&gt;&lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;&lt;/resources&gt; 后两个文件的内容相同，但它们并未实际定义布局。它们只是将 main 设置成了 main_twopanes 的别名。由于这些文件包含 large 和 sw600dp 选择器，因此无论 Android 版本如何，系统都会将这些文件应用到平板电脑和电视上（版本低于 3.2 的平板电脑和电视会匹配 large，版本高于 3.2 的平板电脑和电视则会匹配 sw600dp）。 使用屏幕方向限定符某些布局会同时支持横向模式和纵向模式，但我们可以通过调整优化其中大部分布局的效果。在新闻阅读器示例应用中，每种屏幕尺寸和屏幕方向下的布局行为方式如下所示： 小屏幕，纵向：单面板，带徽标 小屏幕，横向：单面板，带徽标 7 英寸平板电脑，纵向：单面板，带操作栏 7 英寸平板电脑，横向：双面板，宽，带操作栏 10 英寸平板电脑，纵向：双面板，窄，带操作栏 10 英寸平板电脑，横向：双面板，宽，带操作栏 电视，横向：双面板，宽，带操作栏 因此，这些布局中的每一种都定义在了 res/layout/ 目录下的某个 XML 文件中。为了继续将每个布局分配给各种屏幕配置，该应用会使用布局别名将两者相匹配：res/layout/onepane.xml:(单面板)12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:orientation=&quot;vertical&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;fragment android:id=&quot;@+id/headlines&quot;android:layout_height=&quot;fill_parent&quot;android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/onepane_with_bar.xml:(单面板带操作栏)1234567891011121314151617181920212223242526272829303132&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:orientation=&quot;vertical&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;LinearLayout android:layout_width=&quot;match_parent&quot;android:id=&quot;@+id/linearLayout1&quot; android:gravity=&quot;center&quot;android:layout_height=&quot;50dp&quot;&gt;&lt;ImageView android:id=&quot;@+id/imageView1&quot;android:layout_height=&quot;wrap_content&quot;android:layout_width=&quot;wrap_content&quot;android:src=&quot;@drawable/logo&quot;android:paddingRight=&quot;30dp&quot;android:layout_gravity=&quot;left&quot;android:layout_weight=&quot;0&quot; /&gt;&lt;View android:layout_height=&quot;wrap_content&quot;android:id=&quot;@+id/view1&quot;android:layout_width=&quot;wrap_content&quot;android:layout_weight=&quot;1&quot; /&gt;&lt;Button android:id=&quot;@+id/categorybutton&quot;android:background=&quot;@drawable/button_bg&quot;android:layout_height=&quot;match_parent&quot;android:layout_weight=&quot;0&quot;android:layout_width=&quot;120dp&quot;style=&quot;@style/CategoryButtonStyle&quot;/&gt;&lt;/LinearLayout&gt;&lt;fragment android:id=&quot;@+id/headlines&quot;android:layout_height=&quot;fill_parent&quot;android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/twopanes.xml:(双面板，宽布局)1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;fill_parent&quot;android:orientation=&quot;horizontal&quot;&gt;&lt;fragment android:id=&quot;@+id/headlines&quot;android:layout_height=&quot;fill_parent&quot;android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;android:layout_width=&quot;400dp&quot;android:layout_marginRight=&quot;10dp&quot;/&gt;&lt;fragment android:id=&quot;@+id/article&quot;android:layout_height=&quot;fill_parent&quot;android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/twopanes_narrow.xml:(双面板，窄布局)1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;fill_parent&quot;android:orientation=&quot;horizontal&quot;&gt;&lt;fragment android:id=&quot;@+id/headlines&quot;android:layout_height=&quot;fill_parent&quot;android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;android:layout_width=&quot;200dp&quot;android:layout_marginRight=&quot;10dp&quot;/&gt;&lt;fragment android:id=&quot;@+id/article&quot;android:layout_height=&quot;fill_parent&quot;android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 既然我们已定义了所有可能的布局，那就只需使用配置限定符将正确的布局映射到各种配置即可。现在只需使用布局别名技术即可做到这一点：res/values/layouts.xml:1234&lt;resources&gt;&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane_with_bar&lt;/item&gt;&lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;&lt;/resources&gt; res/values-sw600dp-land/layouts.xml:1234&lt;resources&gt;&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes&lt;/item&gt;&lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; res/values-sw600dp-port/layouts.xml:1234&lt;resources&gt;&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane&lt;/item&gt;&lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;&lt;/resources&gt; res/values-large-land/layouts.xml:1234&lt;resources&gt;&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes&lt;/item&gt;&lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; res/values-large-port/layouts.xml:1234&lt;resources&gt;&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes_narrow&lt;/item&gt;&lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; 使用自动拉伸位图(.9图)在Android的设计过程中，为了适配不同的手机分辨率，图片大多需要拉伸或者压缩，这样就出现了可以任意调整大小的一种图片格式“.9.png”。详细教程请参考这篇文章。 支持各种屏幕密度使用密度无关像素由于各种屏幕的像素密度都有所不同，因此相同数量的像素在不同设备上的实际大小也有所差异，这样使用像素定义布局尺寸就会产生问题。因此，请务必使用 dp 或 sp 单位指定尺寸。例如，请使用 dp（而非 px）指定两个视图间的间距：1234&lt;Button android:layout_width=&quot;wrap_content&quot;android:layout_height=&quot;wrap_content&quot;android:text=&quot;@string/clickme&quot;android:layout_marginTop=&quot;20dp&quot; /&gt; 请务必使用 sp 指定文字大小： 1234&lt;TextViewandroid:layout_width=&quot;match_parent&quot;android:layout_height=&quot;wrap_content&quot;android:textSize=&quot;20sp&quot; /&gt; 除了介绍这些最基础的知识之外，我们下面再来讨论一下另外一个问题。经过上面的介绍，我们都清楚，为了能够规避不同像素密度的陷阱，Google推荐使用dp来代替px作为控件长度的度量单位，但是我们来看下面的一个场景。假如我们以Nexus5作为书写代码时查看效果的测试机型，Nexus5的总宽度为360dp，我们现在需要在水平方向上放置两个按钮，一个是150dp左对齐，另外一个是200dp右对齐，最后中间留有10dp间隔。但是如果在Nexus S或者是Nexus One运行，两个按钮就发生了重叠。我们都已经用了dp了，为什么会出现这种情况呢？虽然说dp可以去除不同像素密度的问题，使得1dp在不同像素密度上面的物理长度基本相同(如果xdpi，ydpi与densityDpi不一样，则物理长度会有偏差)，但是还是由于Android屏幕设备的多样性，如果使用dp来作为度量单位，并不是所有的屏幕的宽度都是相同的dp长度，比如说，Nexus S和Nexus One属于hdpi，屏幕宽度是320dp，而Nexus 5属于xxhdpi，屏幕宽度是360dp，Galaxy Nexus属于xhdpi，屏幕宽度是384dp，Nexus 6 属于xxxhdpi，屏幕宽度是410dp。所以说，光Google自己一家的产品就已经有这么多的标准，而且屏幕宽度和像素密度没有任何关联关系，即使我们使用dp，在320dp宽度的设备和410dp的设备上，还是会有90dp的差别。所以总结的结果是，我们要尽量使用match_parent和wrap_content，尽可能少的用dp来指定控件的具体长宽，再结合上权重，大部分的情况我们都是可以做到适配的。如果遇到上述情况的话，这里有一种方法就是，我们假设手机屏幕的宽度都是320某单位，那么我们将一个屏幕宽度的总像素数平均分成320份，每一份对应具体的像素就可以了。具体介绍可以参考这篇文章。 提供备用位图由于 Android 可在具有各种屏幕密度的设备上运行，因此我们提供的位图资源应始终可以满足各类普遍密度范围的要求：低密度、中等密度、高密度以及超高密度。这将有助于我们的图片在所有屏幕密度上都能得到出色的质量和效果。要生成这些图片，我们应先提取矢量格式的原始资源，然后根据以下尺寸范围针对各密度生成相应的图片。 xhdpi：2.0 hdpi：1.5 mdpi：1.0（最低要求） ldpi：0.75 也就是说，如果我们为 xhdpi 设备生成了 200x200 px尺寸的图片，就应该使用同一资源为 hdpi、mdpi 和 ldpi 设备分别生成 150x150、100x100 和 75x75 尺寸的图片。然后，将生成的图片文件放在 res/ 下的相应子目录中(mdpi、hdpi、xhdpi、xxhdpi)，系统就会根据运行您应用的设备的屏幕密度自动选择合适的图片。 注意：实际开发的过程中，通常都会做三套配图，对应着drawable-hdpi、drawable-xhdpi、drawable-xxhdpi三个文件夹。当然时间赶的话，做一套也是可以的。具体可以参考王月半子的文章和慕课网的这篇文章。对于慕课网的这篇，其中对资源的加载策略做了详细的讲解，值得一看，同时，慕课网一文所提及的资源加载策略同样适用于values文件夹。对于王月半子的文章中有提及过mipmap和drawable的区别，我在此基础上的总结是APP的桌面图标坚决用mipmap-[]dpi，其它的资源除所提及的必须放在drawable文件夹中的外，google并没有给出明确的指示，所以放mipmap-[]dpi中和drawable-[*]dpi都可以。最后还需要注意的一点是，如果有的手机尺寸比较奇葩，可以试试wdp限定符，还是不行的话，就建议动态设置了。 这样一来，只要我们引用 @drawable/id，系统都能根据相应屏幕的 dpi 选取合适的位图。还记得我们上面提到的图标设计尺寸吗？和这个其实是一个意思。但是还有个问题需要注意下，如果是.9图或者是不需要多个分辨率的图片，就放在drawable文件夹即可。 drawable对应的dpi是160dpi，相当于drawable-mdpi，但是不会作为一个特定dpi的文件夹使用。它的作用是存放一些xml文件、.9图以及一些不需要适配多个分辨率的图片。 最佳实践关于高清设计图尺寸Google官方给出的高清设计图尺寸有两种方案，一种是以mdpi设计，然后对应放大得到更高分辨率的图片，另外一种则是以高分辨率作为设计大小，然后按照倍数对应缩小到小分辨率的图片。根据经验，我更推荐第二种方法，因为小分辨率在生成高分辨率图片的时候，会出现像素丢失，我不知道是不是有方法可以阻止这种情况发生。而分辨率可以以1280*720或者是1960*1080作为主要分辨率进行设计。这里有一篇关于UI设计的规范说明,UI设计时可以参考。 ImageView的ScaleType属性设置不同的ScaleType会得到不同的显示效果，一般情况下，设置为centerCrop能获得较好的适配效果。 动态设置有一些情况下，我们需要动态的设置控件大小或者是位置，比如说popwindow的显示位置和偏移量等，这个时候我们可以动态的获取当前的屏幕属性，然后设置合适的数值。1234567891011public class ScreenSizeUtil &#123;public static int getScreenWidth(Activity activity) &#123;return activity.getWindowManager().getDefaultDisplay().getWidth();&#125;public static int getScreenHeight(Activity activity) &#123;return activity.getWindowManager().getDefaultDisplay().getHeight();&#125;&#125; 参考资料Android屏幕适配全攻略(最权威的官方适配指导)]]></content>
      <categories>
        <category>Android View</category>
      </categories>
      <tags>
        <tag>屏幕适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android软键盘]]></title>
    <url>%2F2017%2F07%2F01%2FAndroid%E8%BD%AF%E9%94%AE%E7%9B%98%2F</url>
    <content type="text"><![CDATA[说起Android软键盘，这里遇到的坑多数就是对它理解不够全面导致的，所以决定好好总结一下它。在避免自己二次掉坑的同时，如果能帮助到在这个知识区正疑惑的你，那就太好了。本篇的讲解将分以下几个主题：1、操作软键盘2、监听键盘的弹起与隐藏3、如何避免键盘遮挡输入框 操作软键盘想要操作软键盘，需要使用到 InputMethodManager ，它是一个系统服务，可以使用 Context.getSystemService() 获取到它。 显示软键盘在 InputMethodManager中，有两个方法showSoftInput()和showSoftInputFromInputMethod()，而实际上，只有showSoftInput()是有效的。这里我们只需要传递两个参数。它首先需要一个View ，使用软键盘就是为了输入，而输入就需要有接收输入内容的View ，这里接收输入的View ，最好是一个EditText（但这不是必须的）。而第二个参数flags就是个标志位，从上面截图的方法签名上的文档上可以看到，它接收0或者SHOW_INPYT_IMPLICIT 两个参数，但是实际上，它有第三个参数，另外一个是SHOW_FORCED。一般没有特别需要的话，我们直接传递0就好了(实际上SHOW_INPYT_IMPLICIT、SHOW_FORCED并不影响显示，只是在隐藏的时候，会有一些限制。而且我们一般的话，不管显示或者隐藏都将flag设置为0，特殊情况遇到再做分析)。现在，简单总结一下调用showSoftInput()会生效的关键点：1、第一个参数，最好是EditText或者它的子类。考虑到软键盘就是为了输入，EditText就是一个接收输入的控件。而这不是绝对的，如果不是一个EditText ，就必须要求这个View有两个属性，分别是：android:focusable=”true” 和android:focusableInTouchMode=”true”。2、第一个参数，必须是可获取焦点的，并且当前已经获取到焦点。EditText默认是允许获取焦点的，但是假如布局中，存在多个可获取焦点的控件，就需要提前让我们传递进去的View获取到焦点。获取焦点可以使用requestFocus()方法。3、布局必须加载完成。在onCreate()中，如果立即调用showSoftInput()是不会生效的。想要在页面一启动的时候就弹出键盘，可以在Activity上，设置 android:windowSoftInputMode属性来完成，或者做一个延迟加载，View.postDelayed()也是一个解决方案。所以最终，完整的显示软键盘的代码就如下所示了。 隐藏软键盘虽然showSoftInput()方法是有效的，但是想要隐藏软键盘，就没有提供对应的hideSoftInput()方法，但是却有一个hideSoftInputFromWindow()方法，可以用来隐藏软键盘。先来看看这个方法的签名，它同样有两个方法可以调用。它接收两个参数，第一个参数是一个IBinder ，可以直接传递一个 View.getWindowToken()的windowToken对象就可以了。而第二个参数，就是隐藏软键盘的标志位，如果没有特殊要求的话，直接传递0就好了。 注意：这里虽然原则上需要传递一个之前弹出键盘传递的时候，传递的View的windowToken，但是实际情况是你只需要传递一个存在于当前布局ViewTree中，随意一个View的windowToken就可以了。 最终隐藏软件的代码就是这样的。 切换键盘的弹出和隐藏在InputMethodManager中，还提供了一个toggleSoftInput()方法，如同它的名字一样，它可以让软键盘在显示和隐藏之间切换。该方法，接收两个flags ，分别是控制show和hide时候的标识，它们的含义和前面介绍的showSoftInput()和hideSoftInputFromWindow()一致，所以没有特殊要求，直接传递0就好了。toggleSoftInput()方法不要求传递一个View或者windowToken，所以它并没有showSoftInput()中的一些限制，但是依然还有需要在布局绘制完成之后调用才会有效果。虽然这个方法，限制很少，但是我们基本上不会使用它。主要原因在于，它是一个开关的方法，会根据当前的状态做相反的操作。这就导致很多时候，我们在代码中，无法直接根据InputMethodManager提供的方法判断当前软键盘的显示状态，这样也就无法确定调用它的时候的效果了。 监听键盘的弹起与隐藏如果想要监听键盘的弹出和收起，可以使用ViewTreeObserver.OnGlobalLayoutListener这个监听，来监听布局的调整，从而判断出键盘的弹出和隐藏。下面是一个使用ViewTreeObserver.OnGlobalLayoutListener后获取屏幕中各个类型高度的例子，请注意代码中的注释：123456789101112getWindow().getDecorView().getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;@Overridepublic void onGlobalLayout() &#123;Log.d(&quot;sss_main&quot;, &quot;root.getHeight(): &quot; + root.getHeight());//当前所引用视图的高度Log.d(&quot;sss_main&quot;, &quot;root.getRootView().getHeight(): &quot; + root.getRootView().getHeight());//屏幕高度Log.d(&quot;sss_main&quot;, &quot;getWindow().getDecorView(): &quot; + getWindow().getDecorView().getHeight());//屏幕高度Rect r = new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(r);Log.d(&quot;sss_main&quot;, &quot;r.top: &quot; + r.top);//状态栏高度Log.d(&quot;sss_main&quot;, &quot;r.bottom-r.top: &quot; + (r.bottom - r.top));//用户界面的可视高度（除去状态栏和底部导航）&#125;&#125;); 代码中r.bottom - r.top代表了除去状态栏、底部导航栏后，手机屏幕剩余可视高度。注意，这个剩余可视高度也不包括输入法弹窗的高度（如果屏幕中有输入法弹窗的话）。有了以上的基础，我们就可以通过getWindow().getDecorView().getHeight()-r.bottom&gt;100?键盘弹出：键盘隐藏来判断键盘是否隐藏了。 注意：为什么要大于100呢？因为如果手机具备底部导航区域的话，要排除这个值的干扰。当然了，直接默认底部导航区域高度为100肯定是不精确的，实际应用中我们应该获取到真实的底部导航区域高度，具体如何获取底部导航区域高度可以参考这篇文章。 如何避免键盘遮挡输入框在开发中，经常会遇到键盘挡住输入框的情况，比如登录界面或注册界面，弹出的软键盘把登录或注册按钮挡住了，用户必须把软键盘收起，才能点击相应按钮，这样的用户体验非常不好。下面对几种在开发中常用的避免键盘遮挡输入框的方法进行总结。 方法一：windowSoftInputMode:adjustResize和adjustPan主要实现方法：在 AndroidManifest.xml 对应的Activity里添加 android:windowSoftInputMode=”adjustPan” 或是 android:windowSoftInputMode=”adjustResize”属性这两种属性的区别，官方的解释是：这两个属性作用都是为了调整界面使键盘不挡住输入框,这里对这两种属性使用场景、优缺点、注意事项进行了全方面总结。对于fitsystemwindows还比较懵逼的你，可以参考这篇文章。最后附一张官方的截图。 插播知识：这里再提一下clipToPadding和clipChildren这两个属性吧，虽然和本篇没有关系但是同样是有一定概率出现的，所以要讲一下。clipToPadding就是说控件的绘制区域是否在padding里面的，true的情况下如果你设置了padding那么绘制的区域就往里缩，clipToPadding主要应用在listview头部和尾部设置padding后希望可以在滑动item时能滑动到padding区域。clipChildren表示是否限制子View在所属父View的范围内，我们将其值设置为false后那么当子控件的高度高于父控件时也会完全显示,而不会被压缩。注意clipChildren一定是在布局文件的根节点设置，否则不起作用,具体的使用请看这篇文章以及这篇文章。注意：有时候clipChildren会不起作用，如果确定考虑到了之前两篇文章所提及的内容，则应该想其它的办法替代clipChildren，这可以认为是clipChildren的BUG。 方法二：当键盘弹起时，让界面整体上移；键盘收起，让界面整体下移使用场景：针对界面全屏模式，输入框不会被键盘遮挡。主要用于一些登录界面，或是需要把界面整体都顶上去的场景。 1､主要实现步骤(1). 获取Activity布局xml的最外层控件，如xml文件如下：123456789101112131415161718192021222324252627282930&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:tools=&quot;http://schemas.android.com/tools&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;android:id=&quot;@+id/main&quot;tools:context=&quot;com.example.liubin1.softkeyboardhelper.MainActivity&quot;&gt;&lt;EditTextandroid:id=&quot;@+id/name&quot;android:hint=&quot;请输入用户名：&quot;android:layout_centerInParent=&quot;true&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;50dp&quot;/&gt;&lt;EditTextandroid:id=&quot;@+id/pas&quot;android:layout_below=&quot;@id/name&quot;android:hint=&quot;请输入密码：&quot;android:layout_centerInParent=&quot;true&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;50dp&quot;/&gt;&lt;Buttonandroid:id=&quot;@+id/login_btn&quot;android:layout_below=&quot;@id/rpas&quot;android:layout_centerHorizontal=&quot;true&quot;android:text=&quot;登录&quot;android:layout_width=&quot;180dp&quot;android:layout_height=&quot;50dp&quot; /&gt;&lt;/RelativeLayout&gt; 先获取到最外层控件:RelativeLayout main = (RelativeLayout) findViewById(R.id.main);(2). 获取到最后一个控件，如上面的xml文件，最后一个控件是Button:Button login_btn = (Button) findViewById(R.id.login_btn);(3). 给最外层控件和最后一个控件添加监听事件:123456789101112131415161718192021222324252627282930313233//在Activity的onCreate里添加如下方法addLayoutListener(main,login_btn);/** * addLayoutListener方法如下* @param main 根布局* @param scroll 需要显示的最下方View*/public void addLayoutListener(final View main, final View scroll) &#123;main.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;@Overridepublic void onGlobalLayout() &#123;Rect rect = new Rect();//1、获取main在窗体的可视区域main.getWindowVisibleDisplayFrame(rect);//2、获取main在窗体的不可视区域高度，在键盘没有弹起时，main.getRootView().getHeight()调节度应该和rect.bottom高度一样int mainInvisibleHeight = main.getRootView().getHeight() - rect.bottom;int screenHeight = main.getRootView().getHeight();//屏幕高度//3、不可见区域大于屏幕本身高度的1/4：说明键盘弹起了if (mainInvisibleHeight &gt; screenHeight / 4) &#123;int[] location = new int[2];scroll.getLocationInWindow(location);// 4､获取Scroll的窗体坐标，算出main需要滚动的高度int srollHeight = (location[1] + scroll.getHeight()) - rect.bottom;//5､让界面整体上移键盘的高度main.scrollTo(0, srollHeight);&#125; else &#123;//3、不可见区域小于屏幕高度1/4时,说明键盘隐藏了，把界面下移，移回到原有高度main.scrollTo(0, 0);&#125;&#125;&#125;);&#125;&#125; 2､实现原理此方法通过监听 Activity 最外层布局控件来检测软键盘是否弹出，然后去手动调用控件的scrollTo方法达到调整布局目的。 参考资料1.Android软键盘的显示与隐藏2.Android各种键盘挡住输入框解决办法3.API指南4.stackoverflow:监听软件的弹出与隐藏]]></content>
      <categories>
        <category>Android View</category>
      </categories>
      <tags>
        <tag>软键盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中退出APP的解决方案]]></title>
    <url>%2F2017%2F06%2F20%2FAndroid%E4%B8%AD%E9%80%80%E5%87%BAAPP%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[对于单一Activity的应用来说，退出很简单，直接调用finish（）方法即可。但是对于多个activity的应用来说，当打开多个activity后，想再最后一个activity中直接退出app，这就需要每个activity都关掉，然后退出。下面介绍四种安全退出已调用多个activity的application的方法。 抛出异常退出该方法通过抛出异常，使程序强制关闭。但是，这种方法会让程序弹出Force close的弹窗，用户体验很差。 记录打开的activity并逐一关闭这种方法的操作需要抽取到Activity的父类中进行，在父类的onCreate()中将每个打开的Activity加载到一个activity的集合中。当退出时，需要在父类定义一个killAll()方法，在该方法复制一个Activity的集合，然后遍历复制后的集合关闭所有打开的Activity。 发送特定广播实现安全退出（推荐）在需要结束应用时，发送一个特定广播，每个Activity收到广播后，关闭即可。在这个过程中，注册广播接受者的逻辑可以抽取到父类中实现，需要安全退出时，发送的action为注册时指定的action即可，所有开启的activity都注册有能够响应改action的广播接受者，广播接受者接受到此类广播后，将直接调用finish（）方法，关闭当前Activity。 递归退出每个Activity当需要打开新的activity时，使用startActivityForResult()方法打开Activity,需要退出整个应用时，自定义一个标志退出的Flag，在各个activity的onActivityResult方法中处理该Flay，来实现递归关闭。]]></content>
      <categories>
        <category>四大组件</category>
      </categories>
      <tags>
        <tag>退出APP</tag>
        <tag>广播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GlobalDialog框架使用教程]]></title>
    <url>%2F2017%2F06%2F10%2FGlobalDialog%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[GlobalDialog是由ITalk应用开源的一款全局对话框库。相比于Android原生对话框的繁琐配置，GlobalDialog的优势在于能够快速实现全局对话框的功能（通知账号下线、通知账号异常等）。进一步了解，请访问笔者的Github。 #集成方法在Module的build.gradle文件中添加如下依赖即可。1compile &apos;com.txm.topcodes.globaldialog:globaldialog:0.1.6&apos; #调用方式常规方式：1234567891011new GlobalDialog.Builder().setContext(context) .setDescription(&quot;hello world&quot;) //弹出框的提示信息。.setStyle(GlobalDialog.Style.SingleAlert) //弹窗的样式。有DoubleAlert、SingleAlert两种，默认为后者。.setForce(ture) //设置弹框销毁的策略。默认为true。.setDialogClickListener(new OnDialogClickListener() &#123; //设置回调，也可以不设置。@Overridepublic void onSure() &#123;super.onSure();&#125;&#125;).build().show(); 精简方式：1234new GlobalDialog.Builder().setContext(context) .setDescription(&quot;hello world&quot;) .build().show(); #FAQ 我发现GlobalDialog还存在BUG？GlobalDialog是一个完全开源的框架，如果您在使用过程中发现问题，欢迎在笔者的GitHub创建一个Issue。 我是Eclipse用户，可以使用GlobalDialog么？不可以。 我在Android studio中链接GlobalDialog库失败了？确保您的工程使用的远程仓库为jcenter。12345allprojects &#123;repositories &#123;jcenter()&#125;&#125;]]></content>
      <categories>
        <category>我的Android框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android实现阴影效果的三种方式]]></title>
    <url>%2F2017%2F05%2F20%2FAndroid%E5%AE%9E%E7%8E%B0%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[实现Android阴影共有三种方式：使用.9图（略）、设置视图的高度、在layer-list资源文件中模拟阴影效果，本篇文章将对后两种方式做介绍。 视图高度（Z值）实现阴影Material Design为UI元素引入了高度（Z值）概念，拥有较高 Z 值的视图将投射更大且更柔和的阴影，并将挡住拥有较低Z值的视图，不过视图的Z值并不影响视图的大小。阴影的效果是由被提升视图的父项所提供的，因此阴影裁剪也是受父视图影响的，值得注意的是，如果父视图没有提供额外的空间给被提升视图，则阴影效果不会被展现。 指定视图高度视图的Z值包含两个组件： 高度：静态组件。 转换：用于动画的动态组件。 Z = elevation + translationZ如果要在布局定义中设置视图的高度，请使用 android:elevation 属性。如果要在Activity的代码中设置视图高度，请使用 View.setElevation() 方法。如果要设置视图转换，请使用 View.setTranslationZ() 方法，同时，该方法可以通过属性动画为视图高度添加动画。 自定义视图阴影视图的背景将决定其阴影的默认形状，下面举一个例子：12345&lt;TextViewandroid:id=&quot;@+id/myview&quot;...android:elevation=&quot;2dp&quot;android:background=&quot;@drawable/myrect&quot; /&gt; 背景被定义为一个拥有圆角的矩形：123456&lt;!-- res/drawable/myrect.xml --&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:shape=&quot;rectangle&quot;&gt;&lt;solid android:color=&quot;#42000000&quot; /&gt;&lt;corners android:radius=&quot;5dp&quot; /&gt;&lt;/shape&gt; 视图将投射一个带有圆角的阴影，因为背景将定义视图的轮廓。 如果提供一个自定义轮廓，则此轮廓将替换视图阴影的默认形状。 layer-list模拟阴影效果使用layer-list可以将多个drawable按照顺序层叠在一起显示，默认情况下，所有的item中的drawable都会自动根据所依附view的大小而进行缩放，layer-list中的item是按照顺序从下往上叠加的，即先定义的item在下面，后面的依次往上面叠放。以下是带阴影的圆角矩形：12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;itemandroid:left=&quot;2dp&quot;android:top=&quot;2dp&quot;&gt;&lt;shape&gt;&lt;corners android:radius=&quot;20dp&quot; /&gt;&lt;solid android:color=&quot;#acacac&quot; /&gt;&lt;/shape&gt;&lt;/item&gt;&lt;itemandroid:right=&quot;2dp&quot;android:bottom=&quot;2dp&quot;&gt;&lt;shape&gt;&lt;corners android:radius=&quot;20dp&quot; /&gt;&lt;solid android:color=&quot;#FFFFFF&quot; /&gt;&lt;/shape&gt;&lt;/item&gt;&lt;/layer-list&gt; layer-list可以添加多个item子节点，每个item子节点对应一个drawable资源，按照item从上到下的顺序叠加在一起，再通过设置每个item的偏移量就可以看到阴影等效果了。layer-list的item可以通过下面四个属性设置偏移量：android:top 顶部的偏移量android:bottom 底部的偏移量android:left 左边的偏移量android:right 右边的偏移量这四个偏移量和控件的margin设置差不多，都是外间距的效果。 两种方式对比 视图高度 layer-list资源 只兼容Android 5.0以上版本 都兼容 效果逼真 效果不真实 需要额外的空间展示阴影 不需要额外的空间 参考资料1.定义阴影2.Android中layer-list使用详解]]></content>
      <categories>
        <category>Android View</category>
      </categories>
      <tags>
        <tag>layer-list</tag>
        <tag>elevation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SurfaceView使用教程]]></title>
    <url>%2F2017%2F04%2F26%2FSurfaceView%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[介绍SurfaceView是视图(View)的继承类，这个视图里内嵌了一个专门用于绘制的Surface。你可以控制这个Surface的格式和尺寸。Surfaceview控制这个Surface的绘制位置。Surface是纵深排序(Z-ordered)的，这表明它总在自己所在窗口的后面。Surfaceview提供了一个可见区域，只有在这个可见区域内Surface部分内容才可见，可见区域外的部分不可见。Surface的排版显示受到视图层级关系的影响，它的兄弟视图结点会在顶端显示。这意味者 surface 的内容会被它的兄弟视图遮挡，这一特性可以用来放置遮盖物(overlays)(例如，文本和按钮等控件)。如果 surface 上面有透明控件，那么它的每次变化都会引起框架重新计算它和顶层控件之间的透明效果，这会影响性能。你可以通过getHolder()返回的SurfaceHolder实例访问Surface。Surfaceview变得可见时，Surface被创建；Surfaceview隐藏前，Surface被销毁，这样能节省资源。如果你要查看Surface被创建和销毁的时机，可以重载surfaceCreated(SurfaceHolder)和 surfaceDestroyed(SurfaceHolder)。这里应注意： 所有SurfaceView和SurfaceHolder.Callback的方法都会在UI线程里调用，一般来说就是应用程序主线程。所以渲染线程所要访问的各种变量应该作同步处理。 由于Surface可能被销毁，它只在SurfaceHolder.Callback.surfaceCreated()和SurfaceHolder.Callback.surfaceDestroyed()之间有效，所以要确保渲染线程访问的是合法有效的Surface。 SurfaceView最终会和UI线程打交道：SurfaceView带有独立的Surface（独立与Window的Surface），这可以让子线程在独立的Surface上面绘制东西，进行SurfaceView的界面绘制，这个子线程就叫做渲染线程，但是要让独立的Surface上面的东西在View上面展示出来，需要post一个消息给主线程，目的是把该Surface中canvas 上的东西绘制到View的真正的画布上面（window的Surface的canvas上）。 SurfaceView和View的不同之处 View SurfaceView 适用于主动更新 适用于被动刷新 在主线程中进行画面更新 通常通过一个子线程来进行画面更新 绘图中没有使用双缓冲机制 在底层实现中就实现了双缓冲机制 比较了上面的不同之处，显然可以发现，如果一个View需要频繁的刷新，或者在刷新时数据处理量大（可能引起卡顿），可以考虑使用SurfaceView来替代View。 SurfaceView的双缓冲机制对于每一个SurfaceView对象而言，有两个独立的graphic buffer。在Android SurfaceView的双缓冲机制中是这样实现的：在Buffer A中绘制内容，然后让屏幕显示Buffer A；在下一个循环中，在Buffer B中绘制内容，然后让屏幕显示Buffer B，如此往复。而由于这个双缓冲机制的存在，可能会引起闪屏现象。在第一个”lockCanvas-drawCanvas-unlockCanvasAndPost “循环中，更新的是buffer A的内容；到下一个”lockCanvas-drawCanvas-unlockCanvasAndPost”循环中，更新的是buffer B的内容。 如果buffer A与buffer B中某个buffer内容为空，当屏幕轮流显示它们时，就会出现画面黑屏闪烁现象。解决方法:当准备更新内容时，先判断内容是否为空，只有非空时才启动”lockCanvas-drawCanvas-unlockCanvasAndPost”这个流程。 SurfaceView使用步骤 获取到SurfaceView对应的SurfaceHolder，通过addCallback()方法设置SurfaceHolder.Callback用于监听Surface的创建和销毁。 创建渲染线程对象。 在子线程中使用SurfaceHolder的lockCanvas获取Surface上面指定区域的Canvas。 在该Canvas上绘制图形。绘制结束后，使用SurfaceHolder的unlockCanvasAndPost（）方法解锁Canvas，并且让UI线程把Surface上面的东西绘制到View的Canvas上面。 使用SurfaceHolder的例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class GameUI extends SurfaceView implements SurfaceHolder.Callback &#123;private SurfaceHolder holder;private RenderThread renderThread;private boolean isDraw = false;public GameUI(Context context) &#123;super(context);holder = getHolder();holder.addCallback(this);renderThread = new RenderThread();&#125;public GameUI(Context context, AttributeSet attrs) &#123;super(context, attrs);&#125;public GameUI(Context context, AttributeSet attrs, int defStyleAttr) &#123;super(context, attrs, defStyleAttr);&#125;@Overridepublic void surfaceCreated(SurfaceHolder holder) &#123;isDraw = true;if (!renderThread.isAlive()) &#123;renderThread.start();&#125;&#125;@Overridepublic void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;&#125;@Overridepublic void surfaceDestroyed(SurfaceHolder holder) &#123;isDraw = false;&#125;private class RenderThread extends Thread &#123;@Overridepublic void run() &#123;super.run();while (isDraw) &#123;drawUI();&#125;&#125;&#125;private void drawUI() &#123;try &#123;Canvas canvas = holder.lockCanvas();drawCanvas(canvas);&#125; catch (Exception e) &#123;e.printStackTrace();&#125; finally &#123;//由于双缓冲机制的存在，判断画布是否为空，从而避免黑屏情况。if(canvas!=null)&#123;holder.unlockCanvasAndPost(canvas);&#125;&#125;&#125;private void drawCanvas(Canvas canvas) &#123;// 在 canvas 上绘制需要的图形&#125;&#125; 参考资料1.SurfaceView2.SurfaceView的基本使用3.SurfaceView基础用法]]></content>
      <categories>
        <category>Android View</category>
      </categories>
      <tags>
        <tag>SurfaceView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView使用教程]]></title>
    <url>%2F2017%2F03%2F10%2FWebView%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[如果你想在将web页面作为APP的一部分，那么我们可以使用WebView。WebView在Android中继承了view类，作为承载网页的控件。但是我们应该知道它并没有继承web浏览器的所有特性，它所实现的也只是展示网页，以及一些基本的交互和监听功能。WebView经常被使用的场景是，当你的APP需要向用户展示一个随时可更新的内容，比如用户条款、使用向导。那么这样的话，我们可以在一个Activity中包含一个WebView控件用来展示服务器维护的内容，这些内容可以在服务器随时更改。WeblView另一个使用场景是，当我们需要在一个页面中请求所有用户的数据，一般的做法是写一个layout，然后利用网络请求所有所需数据，最后将这些数据填充到layout中。但最简洁的方式是，我们其实可以直接加载一个网页，这个网页包含了需要的数据。这个教程将帮助你学会使用WebView，以及关于它高级一点的用法，比如页面跳转、js交互等。 添加WebView到你的应用添加WebView到你的应用最简单的方式是在Layout中添加&lt; WebView &gt;标签，例如下面的例子表示一个全屏的WebView。123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;WebView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:id=&quot;@+id/webview&quot;android:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;fill_parent&quot;/&gt; 加载网页，调用loadUrl()方法即可。12WebView myWebView = (WebView) findViewById(R.id.webview);myWebView.loadUrl(&quot;http://www.example.com&quot;); 请求服务器网页时，别忘了要加网络请求权限。1234&lt;manifest ... &gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;...&lt;/manifest&gt; 以上就是最简单的加载网页方式。 在WebView中使用JavaScript如果你在APP展示的网页中包含JS，那么请确保WebView支持JS的加载。在此之后，你还可以新建接口让WebView与Android代码交互。 授权使用JavaScriptWebView默认不支持JS的加载，开启它需要调用WebSetting的setJavaScriptEnable()方法。WebSetting可以通过WebView的getSettings()方法获得。123WebView myWebView = (WebView) findViewById(R.id.webview);WebSettings webSettings = myWebView.getSettings();webSettings.setJavaScriptEnabled(true); WebSetting提供了许多使用性的功能，比如你想让你幸幸苦苦开发的web page只能在自己的android应用中展示，那么可以在客户端通过setUserAgentString()设置用户代理之后，在服务端遍历userAgentString字段是否是自己的客户端所设定的。 在Android代码中绑定JavaScript代码通过接口的方式，你可以使你的Android代码和JavaScript代码进行交互。例如，你的JavaScript代码可以调用Android代码弹出一个提示框，而不是使用JavaScript的Alert（）方法。让JavaScript和Android代码产生联系的关键是addJavaScriptInterface()方法，此方法包含两个参数，第一个是一个类对象，供JavaScript调用。第二个是接口名称，它用在JavaScript中作为调用Android方法的别名。例如：1234567891011121314public class WebAppInterface &#123;Context mContext;/** Instantiate the interface and set the context */WebAppInterface(Context c) &#123;mContext = c;&#125;/** Show a toast from the web page */@JavascriptInterfacepublic void showToast(String toast) &#123;Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();&#125;&#125; 特别提醒：如果你的Android目标SDK版本在17或以上，你必须在那些将要在JavaScript中调用的方法体前使用@JavascriptInterface标识。否则，这些方法将不会被调用。 在这个实例中，WebAppInterface允许JavaScript运行showToast方法弹出一个Toast。你可以运行这段代码通过WebView的addJavaScriptInterface()方法，并指定接口的名称为“Android”，例如：12WebView webView = (WebView) findViewById(R.id.webview);webView.addJavascriptInterface(new WebAppInterface(this), &quot;Android&quot;); 这段代码为运行在WebView中的JavaScript创建了一个接口“Android”，那么现在你的JavaScript已经有能力访问WebAppInterface中的showToast方法了。下面的HTML和JS代码将调用showToast方法弹出Toast提示。123456&lt;input type=&quot;button&quot; value=&quot;Say hello&quot; onClick=&quot;showAndroidToast(&apos;Hello Android!&apos;)&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt;function showAndroidToast(toast) &#123;Android.showToast(toast);&#125;&lt;/script&gt; 如你所看到的，在JS中使用“Android”这个接口时，并不需要初始化它，在此之前，WebView已经为你准备好了一些，你只需要通过它调用逻辑即可。 注意：1.WebAppInterface的实例将运行在另一个线程，并不在原来新建它的线程。2.由于通过JS可以调用本地的Android代码，那么我们对于这点要非常的谨慎。对于不受信任的web链接，不应该使用addJavascriptInterface()，除非这个链接是自己本人写的或者其它应该充分信任它的理由。同时，对于不信任的网站，我们在处理它的跳转时应该非常小心，不应该在我们的WebView中直接接受链接的跳转。（默认情况，WebView网页中的链接会跳转到手机的Web浏览器，这是保证安全的前提下一种很好的处理方法。但是，在接下来会提到的serWebViewClient()方法中，你可以自定义链接的行为，这就需要小心了。） 页面导航当用户在WebView点击一个链接后，默认的行为是在web浏览器中打开该链接所指向的网页。正如上面所提及的一样，你是可以通过WebView的serWebViewClient方法自定义这个行为的。例如在自己的WebView中展示跳转的内容，而不是跳转到web浏览器。12WebView myWebView = (WebView) findViewById(R.id.webview);myWebView.setWebClient(new WebClient()); 当然你还可以做更多：12345678910111213private class MyWebViewClient extends WebViewClient &#123;@Overridepublic boolean shouldOverrideUrlLoading(WebView view,String url)&#123;if (Uri.parse(url).getHost().equals(&quot;www.example.com&quot;)) &#123;// This is my web site, so do not override; let my WebView load the pagereturn false;&#125;// Otherwise, the link is not for a page on my site, so launch another Activity that handles URLsIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));startActivity(intent);return true;&#125;&#125; 然后创建MyWebViewClient的实例作为setWebClient()的参数。12WebView myWebView = (WebView) findViewById(R.id.webview);myWebView.setWebClient(new MyWebViewClient()); 导航web的浏览记录在WebView中浏览网页时，我们可能会通过web中包含的外链跳转到其它的网页（在同一Webview页面中），那么这些跳转记录是可以来回切换的，这里主要涉及到goBack()和goForward()方法的使用。例如下面的例子，我们通过设备的返回按钮让WebView回退到上一个页面，或者退出当前Activity。1234567891011@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123; // Check if the key event was the Back button and if there&apos;s history if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; myWebView.canGoBack()) &#123; myWebView.goBack()); return true; &#125; // If it wasn&apos;t the Back key or there&apos;s no web page history, bubble up to the default // system behavior (probably exit the activity) return super.onKeyDown(keyCode, event);&#125; 参考资料Building Web Apps in WebView]]></content>
      <categories>
        <category>Android View</category>
      </categories>
      <tags>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之Volatile和Automic]]></title>
    <url>%2F2017%2F02%2F21%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BVolatile%E5%92%8CAutomic%2F</url>
    <content type="text"><![CDATA[volatile的特性当我们声明共享变量为volatile后，对这个变量的读/写将会很特别。理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步(实际上不是完全一样的，后面会提到)。下面我们通过具体的示例来说明，请看下面的示例代码：12345678910111213141516class VolatileFeaturesExample &#123;//使用volatile声明64位的long型变量volatile long vl = 0L;public void set(long l) &#123;vl = l; //单个volatile变量的写&#125;public void getAndIncrement () &#123;vl++; //复合（多个）volatile变量的读/写&#125;public long get() &#123;return vl; //单个volatile变量的读&#125;&#125; 假设有多个线程分别调用上面程序的三个方法，这个程序在语义上和下面程序等价：123456789101112131415161718class VolatileFeaturesExample &#123;long vl = 0L; // 64位的long型普通变量//对单个的普通 变量的写用同一个锁同步public synchronized void set(long l) &#123; vl = l;&#125;public void getAndIncrement () &#123; //普通方法调用long temp = get(); //调用已同步的读方法temp += 1L; //普通写操作set(temp); //调用已同步的写方法&#125;public synchronized long get() &#123; //对单个的普通变量的读用同一个锁同步return vl;&#125;&#125; 如上面示例程序所示，对一个volatile变量的单个读/写操作，与对一个普通变量的读/写操作使用同一个锁来同步，它们之间的执行效果相同。锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。简而言之，volatile变量自身具有下列特性：1.可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。2.原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。 volatile 与 synchronized 的比较volatile主要用在多个线程感知实例变量被更改的场合，从而使得各个线程获得最新的值。比较：①volatile轻量级，只能修饰变量。synchronized重量级，还可修饰方法。②volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞。synchronized不仅保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。 由锁释放和获取的内存语义引申volatile当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须要“从主内存中去读取共享变量”。实际上，锁释放-获取的内存语义与volatile写-读的内存语义有着一一对应的关系，锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。下面对锁释放和锁获取的内存语义做个总结（volatile的读、写类似）： 线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。 线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。 AtomicInteger介绍原子操作在多线程场景是很有必要的，它可以避免数据的二义性产生。下面的程序中我们新建了两个线程，每个线程对同一个数增加了4次，每次加1，最后的结果正确应该是8。12345678910111213141516171819202122232425262728293031323334353637383940public class JavaAtomic &#123;public static void main(String[] args) throws InterruptedException &#123;ProcessingThread pt = new ProcessingThread();Thread t1 = new Thread(pt, &quot;t1&quot;);t1.start();Thread t2 = new Thread(pt, &quot;t2&quot;);t2.start();t1.join();t2.join();System.out.println(&quot;Processing count=&quot; + pt.getCount());&#125;&#125;class ProcessingThread implements Runnable &#123;private int count;@Overridepublic void run() &#123;for (int i = 1; i &lt; 5; i++) &#123;processSomething(i);count++;&#125;&#125;public int getCount() &#123;return this.count;&#125;private void processSomething(int i) &#123;// processing some jobtry &#123;Thread.sleep(i * 1000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125; 运行上面的程序后，你会发现最后的运行结果每次都不一样，可能是5，6，7或者8。原因就是count++不具备原子性，当一个线程读取了count的值并进行完加1操作时，另外一个线程还是引用的原来旧的count值，这样就导致了最后加1后的结果不符合预期的现象。为了解决这个问题，我们除了可以使用Synchronized、Lock，还可以使用 Java 5 java.util.concurrent.atomic提供的AutomicInteger实现原子操作。并且在程序逻辑允许的情况下，我们应该优先使用atomic，它在执行速度、可读性、实用性方面均优于前两者。1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.concurrent.atomic.AtomicInteger;public class JavaAtomic &#123;public static void main(String[] args) throws InterruptedException &#123;ProcessingThread pt = new ProcessingThread();Thread t1 = new Thread(pt, &quot;t1&quot;);t1.start();Thread t2 = new Thread(pt, &quot;t2&quot;);t2.start();t1.join();t2.join();System.out.println(&quot;Processing count=&quot; + pt.getCount());&#125;&#125;class ProcessingThread implements Runnable &#123;private AtomicInteger count = new AtomicInteger();@Overridepublic void run() &#123;for (int i = 1; i &lt; 5; i++) &#123;processSomething(i);count.incrementAndGet();&#125;&#125;public int getCount() &#123;return this.count.get();&#125;private void processSomething(int i) &#123;// processing some jobtry &#123;Thread.sleep(i * 1000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125; 参考资料1.并发编程网2.AtomicInteger in Java]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment的理解]]></title>
    <url>%2F2017%2F02%2F16%2FFragment%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[碎片化的出现让一些复杂冗长的内容在一些屏幕与分辨率存在差异的屏幕上得到了合理的展示，极大地提高了用户的体验。下面对Fragment的一些热点问题进行一下讲解。 概念Fragment（碎片）是在Android 3.0出现的。可以把Fragment理解成Activity的一个模块化区域，他拥有自己的生命周期，接收属于自己的输入事件，并且可以在Activity运行期间被添加和删除。Fragment必须被嵌入一个Activity中，它们的生命周期直接受宿主Activity的影响。当一个Activity正在运行时，可以独立的操作其中的每一个Fragment，如添加和删除。Fragment的加载方式有两种：静态加载和动态加载。静态加载很简单，只需把Fragment当成普通UI放在界面Layout中。动态加载需要先了解Fragment事务，事务指的就是原子性，不可分割的操作。所谓的Fragment事务。所谓Fragment事务，就是对Fragment的进行添加、删除、替换或者其它操作，提交给Activity的每一个变化，这就是事务。动态加载的流程如下： 开启一个新事务； 通过事务添加Fragment； 提交事务，否则添加不成功。 Fragment的生命周期Fragment的生命周期与Activity类似，用到的方法如下表所示。 方法名称 方法说明 onAttach() 绑定Fragment到Activity onCreate() 创建Fragment onCreateView() 创建Fragment的布局 onActivityCreated() Activity创建完成后回调该方法 onStart() 可见，不可交互状态 onResume() 可见，可交互状态 onPause() 部分可见，不可交互状态 onStop() 不可见 onDestroyView() 销毁Fragment的View对象 onDestroy() Fragment被销毁 onDetach() Fragment从Activity解绑 这里有几点需要注意的地方：1、因为Fragment与Activity是绑定在一起的，所以当Activity被销毁时，Fragment也要被销毁。Fragment的调销毁过程是：onPause()——&gt;onStop()——&gt;onDestroyView()——&gt;onDestroy()——&gt;onDetach()。2、调用FragmentTransaction的hide()与show()对于Fragment的生命周期没有影响。3、调用FragmentTransaction的replace()方法，并且在次之前没有调用addToBackStack，则之前已创建的Fragment(如果有)将会被解绑；反之，如果在此之前调用了addToBackStack方法，之前已创建的Fragment(如果有)将只会被销毁它的View对象，即调用onDestroyView()方法。之后如果按返回键或者调用getSupportFragmentManager().popBackStack()方法，之前的Fragment将会再次显示，这个过程中依次调用了之前fragment的onCreateView()——&gt;onActivityCreated()——&gt;onStart()——&gt;onResume()方法。 Fragment与Activity如何进行交互由于所有的Fragment都依赖与Activity，因此它们之间实现通信并不复杂，大概可以分为两种：一种是在Activity中访问Fragment，一种是在Frament中访问Activity，具体如下： 在Activity中访问Frament因为可以在Activity中获取Fragment实例（特殊除外），所以可以直接访问Frament中声明的公有方法。 小提示：除了直接通过Fragment的公有方法访问外，我们还可以通过接口回调的方式访问Fragment中相关参数。 在Fragment中访问Activity在Fragment中可以通过getActivity()方法得到当前绑定的Activity的实例，然后进行操作。 如何切换Fragment首先分别获取FragmentMangager与FragmentTransaction的实例，然后创建一个Fragment对象，接下来调用FragmentTransaction对象的replace（）方法和commit方法来完成Fragment的切换。具体代码如下：123456//获取FragmentManager的实例FragmentManager fragmentManager=getFragmentManager();FragmentTransaction transaction=fragmentManager.beginTransaction();ExampleFragment fragment=new ExampleFragment();//创建一个FragmentfragmentTransaction.replace(R.id.content,fragment);//R.id.content对应的控件必须是一个ViewGroupfragmentTransaction.commit(); 理解addToBackStack()官方的解释：Add this transaction to the back stack. This means that the transaction will be remembered after it is committed, and will reverse its operation when later popped off the stack.大白话：在commit之前保存此时的状态，之后如果按返回键，可以再次回到此时的状态。一般我们需要使用addToBackStack的话，直接调用addToBackStack(null)即可。]]></content>
      <categories>
        <category>四大组件</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之Lock]]></title>
    <url>%2F2017%2F01%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BLock%2F</url>
    <content type="text"><![CDATA[相对于Synchronized,我们还可以使用更加人性化的Lock关键字作为线程同步的实现方案。本篇文章将详细介绍Lock的相关用法以及使用它的优势。 使用Lock同步代码块Java提供另外的机制用来同步代码块。它比synchronized关键字更加强大、灵活。它是基于Lock接口和实现它的类（如ReentrantLock）。这种机制有如下优势： 它允许以一种更灵活的方式来构建synchronized块。使用synchronized关键字，你必须以结构化方式得到释放synchronized代码块的控制权。Lock接口允许你获得更复杂的结构来实现你的临界区。 Lock接口比synchronized关键字提供更多额外的功能，新功能之一是它提供的tryLock()方法。这种方法试图获取锁的控制权并且如果它不能获取该锁是由于其他线程在使用这个锁，它将返回false。使用synchronized关键字，当线程A试图执行synchronized代码块，如果线程B正在执行它，那么线程A将阻塞直到线程B执行完synchronized代码块。使用Lock，你可以执行tryLock()方法，这个方法返回一个Boolean值表示是否有其他线程正在运行这个锁所保护的代码。 当有多个读者和一个写者时，Lock接口允许读写操作分离。 Lock接口提供了相比于wait更加灵活的await关键字用于线程通信。 ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。 注意：对于上面第5条优势中的提到的可以被Interrupt的同步是相对于进入同步块前的这个时间段来说的。另外在进入同步块后，如果调用了synchronized概念中的wait()或Lock概念中的await()或者sleep（），那么该线程在等待唤醒的过程中是可以响应打断的（抛出异常后继续执行，而不是线程终止）；如果调用了Lock概念中的awaitUninterruptibly()或耗时业务逻辑导致的延迟操作，则不会响应打断。 在下面的案例中，你将学习如何通过锁来同步代码块和通过Lock接口及其实现者ReentrantLock类来创建临界区，实现一个程序来模拟打印队列。1.创建PrintQueue类，来实现打印队列。1public class PrintQueue &#123; 2.声明一个Lock对象，并且使用ReentrantLock类的一个新对象来初始化它。1private final Lock queueLock=new ReentrantLock(); 3.实现printJob()方法，它将接收Object对象作为参数，并且不会返回任何值。1public void printJob(Object document)&#123; 4.在printJob()方法内部，通过调用lock()方法来获取Lock对象的控制权。1queueLock.lock(); 5.然后，包含以下代码来模拟文档的打印:1234567try &#123;System.out.printf(&quot;%s:print start!!!\n&quot;, Thread.currentThread().getName());Thread.sleep(1000);System.out.printf(&quot;%s:print end!!!\n&quot;, Thread.currentThread().getName());&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125; 6.最后，通过调用unlock()方法来释放Lock对象的控制。123finally &#123;queueLock.unlock();&#125; 7.创建一个Job类，并指定它实现Runnable接口。1public class Job implements Runnable &#123; 8.声明一个PrintQueue类的对象，并通过实现类（Job类）的构造器来初始化这个对象。1234private PrintQueue printQueue;public Job(PrintQueue printQueue)&#123;this.printQueue=printQueue;&#125; 9.实现run()方法，它使用PrintQueue对象来发送一个打印任务。1234@Overridepublic void run() &#123;printQueue.printJob(new Object());&#125; 10.通过创建类名为Main，且包括main（）方法来实现这个示例的主类。12public class Main &#123;public static void main(String[] args) &#123; 11.创建一个共享的PrintQueue对象。1PrintQueue printQueue=new PrintQueue(); 12.创建10个Job对象，并且使用10个线程来运行它们。1234Thread thread[]=new Thread[5];for (int i=0; i&lt;10; i++)&#123;thread[i]=new Thread(new Job(printQueue));&#125; 13.启动这10个线程。123for (int i=0; i&lt;10; i++)&#123;thread[i].start();&#125; 从以下截图，你可以看到执行这个示例的输出：在 printJob()中，queueLock是这个示例的关键所在。当我们通过锁来实现一个临界区并且保证只有一个执行线程能运行一个代码块，我们必须创建一个ReentrantLock对象。在临界区的起始部分，我们必须通过使用lock()方法来获得锁的控制权。当一个线程A调用这个方法时，如果没有其他线程持有这个锁的控制权，那么这个方法就会给线程A分配这个锁的控制权并允许线程A执行这个临界区。否则，如果其他线程B正在执行由这个锁控制的临界区，lock()方法将会使线程A睡眠直到线程B完成这个临界区的执行。在临界区的尾部，我们必须使用unlock()方法来释放锁的控制权，允许其他线程运行这个临界区。如果你在临界区的尾部没有调用unlock()方法，那么其他正在等待该代码块的线程将会永远等待，造成死锁情况。如果你在临界区使用try-catch代码块，别忘了在finally部分的内部包含unlock()方法的代码。 tryLock()Lock接口（和ReentrantLock类，以及后面要讲的ReadWriteLock接口和ReentrantReadWriteLock类）包含其他方法来获取锁的控制权，那就是tryLock()方法。这个方法与lock()方法的最大区别是，如果一个线程调用这个方法不能获取Lock接口的控制权时，将会立即返回并且不会使这个线程进入睡眠。这个方法返回一个boolean值，true表示这个线程获取了锁的控制权，false则表示没有。 小知识:预先考虑到tryLock()方法的结果，并采取相应的措施，这是程序员的责任。如果这个方法返回false值，预计你的程序不会执行这个临界区。如果是这样，你应该针对此错误结果做相应的处理。 ReentrantLock类也允许递归调用（锁的可重入性），当一个线程有锁的控制权并且使用递归调用，它延续了锁的控制权，所以调用lock()方法将会立即返回并且继续递归调用的执行。 lockInterruptibly()lockInterruptibly()是Lock提供的另一个用来获取锁的控制权的方法。它可以立即响应线程的interrupt,不伦当前线程是在等待锁的期间或是在已经获取锁的控制权期间。lock()相比于lockInterruptibly()来说没有那么及时，它要在获取锁的那一刻才能响应线程的interrupt事件。 使用读/写锁同步数据访问锁所提供的最重要的改进之一就是ReadWriteLock接口和唯一一个实现它的ReentrantReadWriteLock类。这个类提供两把锁，一把用于读操作和一把用于写操作。同时可以有多个线程执行读操作，但只有一个线程可以执行写操作。当一个线程正在执行一个写操作，不可能有任何线程执行读操作。在下面的例子中，你将会学习如何使用ReadWriteLock接口实现一个程序，使用它来控制访问一个存储两个产品价格的对象。1.创建PricesInfo类，用它来存储两个产品价格的信息。1public class PricesInfo &#123; 2.声明两个double类型的属性，分别命名为price1和price2。12private double price1;private double price2; 3.声明一个名为lock的ReadWriteLock对象。1private ReadWriteLock lock; 4.实现类的构造器，初始化这三个属性。其中，对于lock属性，我们创建一个新的ReentrantReadWriteLock对象。12345public PricesInfo()&#123;price1=1.0;price2=2.0;lock=new ReentrantReadWriteLock();&#125; 5.实现getPrice1()方法，用它来返回price1属性的值。它使用读锁来控制这个属性值的访问。123456public double getPrice1() &#123;lock.readLock().lock();double value=price1;lock.readLock().unlock();return value;&#125; 6.实现getPrice2()方法，用它来返回price2属性的值。它使用读锁来控制这个属性值的访问。123456public double getPrice2() &#123;lock.readLock().lock();double value=price2;lock.readLock().unlock();return value;&#125; 7.实现setPrices()方法，用来建立这两个属性的值。它使用写锁来控制对它们的访问。123456public void setPrices(double price1, double price2) &#123;lock.writeLock().lock();this.price1=price1;this.price2=price2;lock.writeLock().unlock();&#125; 8.创建Reader类，并指定它实现Runnable接口。这个类实现了PricesInfo类属性值的读者。1public class Reader implements Runnable &#123; 9.声明一个PricesInfo对象，并且实现Reader类的构造器来初始化这个对象。1234private PricesInfo pricesInfo;public Reader (PricesInfo pricesInfo)&#123;this.pricesInfo=pricesInfo;&#125; 10.实现Reader类的run()方法，它读取10次两个价格的值。123456789@Overridepublic void run() &#123;for (int i=0; i&lt;10; i++)&#123;System.out.printf(&quot;%s: Price 1: %f\n&quot;, Thread.currentThread().getName(),pricesInfo.getPrice1());System.out.printf(&quot;%s: Price 2: %f\n&quot;, Thread.currentThread().getName(),pricesInfo.getPrice2());&#125;&#125; 11.创建Writer类，并指定它实现Runnable接口。这个类实现了PricesInfo类属性值的修改者。1public class Writer implements Runnable &#123; 12.声明一个PricesInfo对象，并且实现Writer类的构造器来初始化这个对象。1234private PricesInfo pricesInfo;public Writer(PricesInfo pricesInfo)&#123;this.pricesInfo=pricesInfo;&#125; 13.实现run()方法，它修改了三次两个价格的值，并且在每次修改之后睡眠2秒。1234567891011121314@Overridepublic void run() &#123;for (int i=0; i&lt;3; i++) &#123;System.out.printf(&quot;Writer: Attempt to modify theprices.\n&quot;);pricesInfo.setPrices(Math.random()*10, Math.random()*8);System.out.printf(&quot;Writer: Prices have been modified.\n&quot;);try &#123;Thread.sleep(2);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125; 14.通过创建类名为Main，且包括main（）方法来实现这个示例的主类。12public class Main &#123;public static void main(String[] args) &#123; 15.创建一个PricesInfo对象。1PricesInfo pricesInfo=new PricesInfo(); 16.创建5个Reader对象，并且用5个线程来执行它们。123456Reader readers[]=new Reader[5];Thread threadsReader[]=new Thread[5];for (int i=0; i&lt;5; i++)&#123;readers[i]=new Reader(pricesInfo);threadsReader[i]=new Thread(readers[i]);&#125; 17.创建一个Writer对象，并且用线程来执行它。12Writer writer=new Writer(pricesInfo);Thread threadWriter=new Thread(writer); 18.启动这些线程。1234for (int i=0; i&lt;5; i++)&#123;threadsReader[i].start();&#125;threadWriter.start(); 在以下截图中，你可以看到执行这个例子的一个部分输出: 修改Lock的公平性在ReentrantLock类和ReentrantReadWriteLock类的构造器中，允许一个名为fair的boolean类型参数，它允许你来控制这些类的行为。默认值为 false，这将启用非公平模式。在这个模式中，当有多个线程正在等待一把锁（ReentrantLock或者 ReentrantReadWriteLock），这个锁必须选择它们中间的一个来获得进入临界区，选择任意一个是没有任何标准的。true值将开启公平模式。在这个模式中，当有多个线程正在等待一把锁（ReentrantLock或者ReentrantReadWriteLock），这个锁必须选择它们中间的一个来获得进入临界区，它将选择等待时间最长的线程。由于tryLock()方法并不会使线程进入睡眠，即使Lock接口正在被使用，这个公平属性并不会影响它的功能。更多关于公平模式的介绍，请点击查阅。 参考资料并发编程网-1并发编程网-2]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀资料收集]]></title>
    <url>%2F2016%2F12%2F28%2F%E4%BC%98%E7%A7%80%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[手势检测GestureDetector:http://www.gcssloop.com/customview/gestruedectorScaleGestureDetector:http://www.27house.cn/archives/526 Android事件分发机制ViewRootImpl篇（前传）：https://blog.csdn.net/dongxianfei/article/details/83863888Part01:http://www.gcssloop.com/customview/dispatch-touchevent-theoryPart02:http://www.gcssloop.com/customview/dispatch-touchevent-source UML类图Part01:https://www.cnblogs.com/xrq730/p/5527115.htmlPart02:http://www.cnblogs.com/xrq730/p/5533019.html 设计模式系列https://www.kancloud.cn/digest/xing-designpattern/143717]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之Synchronized]]></title>
    <url>%2F2016%2F12%2F18%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Synchronized%2F</url>
    <content type="text"><![CDATA[介绍在并发编程中发生的最常见的一种情况是超过一个执行线程使用共享资源。在并发应用程序中，多个线程读或写相同的数据或访问同一文件或数据库连接这是正常的。这些共享资源会引发错误或数据不一致的情况，我们必须通过同步机制来避免这些错误。解决这些问题从临界区的概念开始。临界区是访问一个共享资源在同一时间不能被超过一个线程执行的代码块。Java(和几乎所有的编程语言)提供同步机制，帮助程序员实现临界区。当一个线程想要访问一个临界区,它使用其中的一个同步机制来找出是否有任何其他线程执行临界区。如果没有，这个线程就进入临界区。否则，这个线程通过同步机制暂停直到另一个线程执行完临界区。当多个线程正在等待一个线程完成执行的一个临界区，JVM选择其中一个线程执行，其余的线程会等待直到轮到它们。这个系列的文章将逐一介绍Java提供的几个同步机制：Synchronized、Lock、Automic和Volatile。Synchronized可以标记以下四种类型的代码区域： Instance methods（普通方法） Static methods（静态方法） Code blocks inside instance methods（普通方法内的代码快） Code blocks inside static methods（静态方法内的代码快) 普通同步方法下面是一个普通的同步方法。123public synchronized void add(int value)&#123;this.count += value;&#125; 如果此时A线程和B线程同时对同一个对象的add方法访问，那么只能有一个线程（假设是A线程）能够进入方法体内获得锁资源，此时B线程只能等待A线程执行完方法体后（释放锁资源）才能执行add方法体中的代码。总结一下就是，在同一时刻只能有一个线程能对同一个对象的synchronized方法进行访问。如果一个线程A正在执行一个synchronized方法，而线程B想要执行同个实例对象的非静态synchronized方法，它将阻塞，直到线程A执行完。但是如果线程B访问相同类的不同实例对象，它们都不会被阻塞。 再深入一点：CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。 静态同步方法123public static synchronized void add(int value)&#123;count += value;&#125; 与普通同步方法不同，静态同步方法修饰的对象是整个class对象。只有一个执行线程能访问被synchronized关键字声明的静态方法，但另一个线程可以访问该类的一个对象中的其他非静态的方法。你必须非常小心这一点，因为两个线程可以访问两个不同的同步方法，如果其中一个是静态的而另一个不是。如果这两种方法改变相同的数据,你将会有数据不一致的错误。 普通方法中的同步块123456public void log2(String msg1, String msg2)&#123;synchronized(this)&#123;log.writeln(msg1);log.writeln(msg2);&#125;&#125; 这样调用和普通同步方法实现的效果其实是一样的。注意到“this”字段是一个Monitor对象，它和普通同步方法中锁定的对象是一个概念。 小知识：引用维基百科的说法，monitor是一种线程安全的class,object或者module，即monitor允许多个线程同时访问其内的方法或者属性而不会出现二义性。 静态方法中的同步块123456public static void log2(String msg1, String msg2)&#123;synchronized(MyClass.class)&#123;log.writeln(msg1);log.writeln(msg2);&#125;&#125; 锁的分类以上内容就是对Synchronized关键字使用和触发场景的介绍，下面再从宏观上介绍一下关于锁的分类：（*）偏向锁、轻量锁、重量锁。偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。如果在运行过程中，遇到了其他线程抢占锁，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁。偏向锁只能在单线程下起作用,主要解决无竞争下的锁性能问题。 我们看下无竞争下锁存在什么问题:按照之前的HotSpot设计，每次加锁/解锁都会涉及到一些CAS操作（比如对等待队列的CAS操作），CAS操作会延迟本地调用，因此偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。锁演变的流程是这样的：偏向锁-&gt;轻量级锁-&gt;重量级锁。 线程通信（wait、notify、notifyAll）当一个线程进入wait之后，就必须等其他线程notify/notifyall,使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。注意，任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行synchronized中的代码，notifyall只是让处于wait的线程重新拥有锁的争夺权，但是只会有一个获得锁并执行。 注意：wait、notify、notifyAll必须都在同步块中调用，否者会抛出IllegalMonitorStateException异常。 深入了解notify与notifyAll的区别先说两个概念：锁池和等待池。锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中。然后再来说notify和notifyAll的区别。 如果线程调用了对象的wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。 当有线程调用了对象的notifyAll()方法（唤醒所有wait线程或notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。 综上，所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。 如何避免死锁在多线程同步机制中，试想一下会不会出现线程1和线程2互相需要对方所持有的锁的情况呢？答案是肯定的，这就是死锁。我们要避免死锁，需从以下三个方面入手：1.加锁顺序2.加锁时限3.死锁检测 加锁顺序当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。 加锁时限另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行。这种机制存在一个问题，在Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具。 死锁检测死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。那么当检测出死锁时，这些线程该做些什么呢？一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁。一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。 参考资料1.并发编程网2.Java Synchronized Blocks3.java中的notify和notifyAll有什么区别？4.避免死锁]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java正则表达式详解]]></title>
    <url>%2F2016%2F11%2F10%2FJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[为什么要使用正则表达式？节省代码，爱护队友。 在正式介绍之前，先贴一段使用了正则表达式的代码吧。12345String phoneNum = &quot;16510758936&quot;;String patternString = &quot;\\d&#123;11&#125;&quot;;Pattern pattern = Pattern.compile(patternString);Matcher matcher = pattern.matcher(phoneNum);System.out.println(&quot;matches = &quot;+matcher.matches()); 仅这段代码就可以简单判断字符串（代码中的“phoneNum”字符串）是否为手机号格式。是不是很高效呢？事实上正则表达式还可以做很多很酷的事情，所以我们很有必要认真的学一下它。本文将从API、语法两个维度介绍该主题。 API使用类 java.util.regex.Pattern 简称 Pattern, 是Java正则表达式API中的主要入口，无论何时,需要使用正则表达式,从Pattern 类开始 Pattern.matches()这是检测正则表达式的模式是否匹配一段文本的最直接方法，eg：123456String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the pattern.&quot;;String pattern = &quot;.*is.*&quot;;boolean matches = Pattern.matches(pattern, text);System.out.println(&quot;matches = &quot; + matches); “.”表示任意字符，“*”表示0或者多个，“.*”组合表示0或者多个任意字符。显然， “.*is.*“代表一个字符串中包含“is”字段，上面代码返回结果是true。Pattern.matches() 方法适用于检查 一个模式在一个文本中出现一次的情况，或适用于Pattern类的默认设置。如果需要匹配多次出现,甚至输出不同的匹配文本，或者只是需要非默认设置。需要通过Pattern.compile() 方法得到一个Pattern 实例。 Pattern.compile()如果需要匹配一个正则表达式在文本中多次出现，需要通过Pattern.compile() 方法创建一个Pattern对象。示例如下。12345String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the http:// pattern.&quot;;String patternString = &quot;.*http://.*&quot;;Pattern pattern = Pattern.compile(patternString); 可以在Compile 方法中，指定一个特殊标志：Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);Pattern 类包含多个标志(int 类型),这些标志可以控制Pattern 匹配模式的方式。上面代码中的标志使模式匹配是忽略大小写 pattern.matcher()一旦获得了Pattern对象，接着可以获得Matcher对象。Matcher 示例用于匹配文本中的模式.示例如下Matcher matcher = pattern.matcher(text);Matcher类有一个matches()方法，可以检查文本是否匹配模式。以下是关于Matcher的一个完整例子12345678String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the http:// pattern.&quot;;String patternString = &quot;.*http://.*&quot;;Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);Matcher matcher = pattern.matcher(text);boolean matches = matcher.matches();System.out.println(&quot;matches = &quot; + matches); pattern.split()Pattern 类的 split()方法，可以用正则表达式作为分隔符，把文本分割为String类型的数组。示例：12345678String text = &quot;A sep Text sep With sep Many sep Separators&quot;;String patternString = &quot;sep&quot;;Pattern pattern = Pattern.compile(patternString);String[] split = pattern.split(text);System.out.println(&quot;split.length = &quot; + split.length);for(String element : split)&#123;System.out.println(&quot;element = &quot; + element);&#125; 上例中把text 文本分割为一个包含5个字符串的数组。 pattern.pattern()Pattern 类的 pattern 返回用于创建Pattern 对象的正则表达式。 Matcher (java.util.regex.Matcher)java.util.regex.Matcher 类用于匹配一段文本中多次出现一个正则表达式，Matcher 也适用于多文本中匹配同一个正则表达式。 创建Matcher通过Pattern 的matcher() 方法创建一个Matcher。123456String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the http:// pattern.&quot;;String patternString = &quot;.*http://.*&quot;;Pattern pattern = Pattern.compile(patternString);Matcher matcher = pattern.matcher(text); matches()Matcher 类的 matches() 方法用于在文本中匹配正则表达式1boolean matches = matcher.matches(); 如果文本匹配正则表达式，matches() 方法返回true。否则返回false。matches() 方法不能用于查找正则表达式多次出现。如果需要，要使用find(), start() 和 end() 方法。 lookingAt()lookingAt() 与matches() 方法类似，最大的不同是，lookingAt()方法对文本的开头匹配正则表达式；而matches() 对整个文本匹配正则表达式。换句话说，如果正则表达式匹配文本开头而不匹配整个文本,lookingAt() 返回true,而matches() 返回false。 示例：12345678String text =&quot;This is the text to be searched &quot; +&quot;for occurrences of the http:// pattern.&quot;;String patternString = &quot;This is the&quot;;Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);Matcher matcher = pattern.matcher(text);System.out.println(&quot;lookingAt = &quot; + matcher.lookingAt());System.out.println(&quot;matches = &quot; + matcher.matches()); 上面的例子分别对文本开头和整个文本匹配正则表达式 “this is the”, 匹配文本开头的方法(lookingAt()) 返回true。对整个文本匹配正则表达式的方法 (matches()) 返回false，因为整个文本包含多余的字符,而正则表达式要求文本精确匹配”this is the”,前后又不能有额外字符。 find() + start() + end()find() 方法用于在文本中查找出现的正则表达式，文本是创建Matcher时，通过 Pattern.matcher(text) 方法传入的。如果在文本中多次匹配，find() 方法返回第一个，之后每次调用 find() 都会返回下一个。start() 和 end() 返回每次匹配的字串在整个文本中的开始和结束位置。实际上, end() 返回的是字符串末尾的后一位，这样，可以在把 start() 和 end() 的返回值直接用在String.substring() 里。1234567891011String text =&quot;This is the text which is to be searched &quot; +&quot;for occurrences of the word &apos;is&apos;.&quot;;String patternString = &quot;is&quot;;Pattern pattern = Pattern.compile(patternString);Matcher matcher = pattern.matcher(text);int count = 0;while(matcher.find()) &#123;count++;System.out.println(&quot;found: &quot; + count + &quot; : &quot; + matcher.start() + &quot; - &quot; + matcher.end());&#125; 这个例子在文本中找到模式 “is” 4次，输出如下:1234found: 1 : 2 - 4found: 2 : 5 - 7found: 3 : 23 - 25found: 4 : 70 - 72 reset()reset() 方法会重置Matcher 内部的 匹配状态。当find() 方法开始匹配时,Matcher 内部会记录截至当前查找的距离。调用 reset() 会重新从文本开头查找。也可以调用 reset(CharSequence) 方法. 这个方法重置Matcher,同时把一个新的字符串作为参数传入，用于代替创建 Matcher 的原始字符串。 补充：如果在程序中多次使用同一个正则表达式，一定要用Pattern.compile()编译，代替直接使用Pattern.matches()。如果一次次对同一个正则表达式使用Pattern.matches()，例如在循环中，没有编译的正则表达式消耗比较大。因为matches()方法每次都会预编译使用的表达式。另外，记住你可以通过调用reset()方法对不同的输入字符串重复使用Matcher对象。 group()假设想在一个文本中查找URL链接，并且想把找到的链接提取出来。当然可以通过 start()和 end()方法完成。但是用group()方法更容易些。分组在正则表达式中用括号表示，例如:(John)此正则表达式匹配John, 括号不属于要匹配的文本。括号定义了一个分组。当正则表达式匹配到文本后，可以访问分组内的部分。使用group(int groupNo) 方法访问一个分组。一个正则表达式可以有多个分组。每个分组由一对括号标记。想要访问正则表达式中某分组匹配的文本，可以把分组编号传入 group(int groupNo)方法。group(0) 表示整个正则表达式，要获得一个有括号标记的分组，分组编号应该从1开始计算。12345678String text = &quot;John writes about this, and John writes about that,&quot; +&quot; and John writes about everything. &quot; ;String patternString1 = &quot;(John)&quot;;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);while(matcher.find()) &#123;System.out.println(&quot;found: &quot; + matcher.group(1));&#125; 1234以上代码在文本中搜索单词John.从每个匹配文本中，提取分组1，就是由括号标记的部分。输出：found: Johnfound: Johnfound: John 多分组上面提到，一个正则表达式可以有多个分组，例如：(John) (.+?)这个表达式匹配文本”John” 后跟一个空格,然后跟1个或多个字符，最后跟一个空格。你可能看不到最后的空格。这个表达式包括一些字符有特别意义。字符 点 . 表示任意字符。 字符 + 表示出现一个或多个，和. 在一起表示 任何字符,出现一次或多次。字符? 表示 匹配尽可能短的文本。完整代码如下：String text =“John writes about this, and John Doe writes about that,” +“ and John Wayne writes about everything.”;String patternString1 = “(John) (.+?) “;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);while(matcher.find()) {System.out.println(“found: “ + matcher.group(1) +“ “ + matcher.group(2));}1234注意代码中引用分组的方式。代码输出如下:found: John writesfound: John Doefound: John Wayne 嵌套分组在正则表达式中分组可以嵌套分组，例如:((John) (.+?))这是之前的例子，现在放在一个大分组里.(表达式末尾有一个空格)。当遇到嵌套分组时, 分组编号是由左括号的顺序确定的。上例中，分组1 是那个大分组。分组2 是包括John的分组，分组3 是包括 .+? 的分组。当需要通过groups(int groupNo) 引用分组时，了解这些非常重要。以下代码演示如何使用嵌套分组12345678910String text =&quot;John writes about this, and John Doe writes about that,&quot; +&quot; and John Wayne writes about everything.&quot;;String patternString1 = &quot;((John) (.+?)) &quot;;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);while(matcher.find()) &#123;System.out.println(&quot;found: &quot;);&#125; 1234输出如下found:found:found: replaceAll() + replaceFirst()replaceAll() 和 replaceFirst() 方法可以用于替换Matcher搜索字符串中的一部分。replaceAll() 方法替换全部匹配的正则表达式，replaceFirst() 只替换第一个匹配的。在处理之前，Matcher 会先重置。所以这里的匹配表达式从文本开头开始计算。示例如下1234567891011String text =&quot;John writes about this, and John Doe writes about that,&quot; +&quot; and John Wayne writes about everything.&quot;;String patternString1 = &quot;((John) (.+?)) &quot;;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);String replaceAll = matcher.replaceAll(&quot;Joe Blocks &quot;);System.out.println(&quot;replaceAll = &quot; + replaceAll);String replaceFirst = matcher.replaceFirst(&quot;Joe Blocks &quot;);System.out.println(&quot;replaceFirst = &quot; + replaceFirst); 输出如下1234replaceAll = Joe Blocks about this, and Joe Blocks writes about that,and Joe Blocks writes about everything.replaceFirst = Joe Blocks about this, and John Doe writes about that,and John Wayne writes about everything. appendReplacement() + appendTail()appendReplacement() 和 appendTail() 方法用于替换输入文本中的字符串短语，同时把替换后的字符串附加到一个 StringBuffer 中。当find() 方法找到一个匹配项时，可以调用 appendReplacement() 方法，这会导致输入字符串被增加到StringBuffer 中，而且匹配文本被替换。 从上一个匹配文本结尾处开始，直到本次匹配文本会被拷贝。appendReplacement() 会记录拷贝StringBuffer 中的内容，可以持续调用find(),直到没有匹配项。直到最后一个匹配项目，输入文本中剩余一部分没有拷贝到 StringBuffer. 这部分文本是从最后一个匹配项结尾，到文本末尾部分。通过调用 appendTail() 方法，可以把这部分内容拷贝到 StringBuffer 中.1234567891011121314String text =&quot;John writes about this, and John Doe writes about that,&quot; +&quot; and John Wayne writes about everything.&quot;;String patternString1 = &quot;((John) (.+?)) &quot;;Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);StringBuffer stringBuffer = new StringBuffer();while(matcher.find())&#123;matcher.appendReplacement(stringBuffer, &quot;Joe Blocks &quot;);System.out.println(stringBuffer.toString());&#125;matcher.appendTail(stringBuffer);System.out.println(stringBuffer.toString()); 注意我们在while循环中调用appendReplacement() 方法。在循环完毕后调用appendTail()。代码输出如下:12345Joe BlocksJoe Blocks about this, and Joe BlocksJoe Blocks about this, and Joe Blocks writes about that, and Joe BlocksJoe Blocks about this, and Joe Blocks writes about that, and Joe Blockswrites about everything. Java 正则表达式语法为了更有效的使用正则表达式，需要了解正则表达式语法。正则表达式语法很复杂，可以写出非常高级的表达式。只有通过大量的练习才能掌握这些语法规则。 基本语法在介绍高级功能前，我们先快速浏览下正则表达式的基本语法。 字符是正则表达式中最经常使用的的一个表达式，作用是简单的匹配一个确定的字符。例如：John这个简单的表达式将会在一个输入文本中匹配John文本。可以在表达式中使用任意英文字符。也可以使用字符对于的8进制，16进制或unicode编码表示。例如：101\x41\u0041以上3个表达式 都表示大写字符A。第一个是8进制编码(101),第2个是16进制编码(41),第3个是unicode编码(0041). 字符分类字符分类是一种结构，可以针对多个字符匹配而不只是一个字符。换句话说，一个字符分类匹配输入文本中的一个字符，对应字符分类中多个允许字符。例如，你想匹配字符 a,b 或c，表达式如下：[abc]用一对方括号[] 表示字符分类。方括号本身并不是要匹配的一部分。可以用字符分类完成很多事。例如想要匹配单词John，首字母可以为大写和小写J.[Jj]ohn字符分类[Jj] 匹配J或j，剩余的 ohn 会准确匹配字符ohn. 预定义字符分类正则表达式中有一些预定义的字符分类可以使用。例如, \d 表示任意数字, \s 表示任意空白字符,\w 表示任意单词字符。预定义字符分类不需要括在方括号里，当然也可以组合使用\d[\d\s]第1个匹配任意数字，第2个匹配任意数字或空白符。完整的预定义字符分类列表，在本文最后列出。 边界匹配正则表达式支持匹配边界，例如单词边界，文本的开头或末尾。例如，\w 匹配一个单词，^匹配行首,$ 匹配行尾。^This is a single line$上面的表达式匹配一行文本，只有文本 This is a single line。注意其中的行首和行尾标志，表示不能有任何文本在文本的前面后后面，只能是行首和行尾。完整的匹配边界列表，在本文最后列出。 量词匹配量词可以匹配一个表达式多次出现。例如下列表达式匹配字母A 出现0次或多次。A*量词 * 表示0次或多次。+ 表示1次或多次。? 表示0次或1次。还有些其他量词，参见本文后面的列表。量词匹配分为：饥饿模式,贪婪模式,独占模式。饥饿模式 匹配尽可能少的文本。贪婪模式匹配尽可能多的文本。独占模式匹配尽可能多的文本，甚至导致剩余表达式匹配失败。以下演示饥饿模式,贪婪模式,独占模式区别。假设以下文本：John went for a walk, and John fell down, and John hurt his knee.饥饿模式下 表达式：John.*?这个表达式匹配John 后跟0个或多个字符。 . 表示任意字符。* 表示0或多次。? 跟在 * 后面，表示 * 采用饥饿模式。饥饿模式下，量词只会匹配尽可能少的字符，即0个字符。上例中的表达式将会匹配单词John,在输入文本中出现3次。如果改为贪婪模式，表达式如下：John.*贪婪模式下，量词会匹配尽可能多的字符。现在表达式会匹配第一个出现的John，以及在贪婪模式下 匹配剩余的所有字符。这样，只有一个匹配项。最后，我们改为独占模式：John.*+hurt*后跟+ 表示独占模式量词。这个表达式在输入文本中没有匹配项，尽管文本中包括 John 和 hurt. 为什么会这样? 因为 .*+ 是独占模式。与贪婪模式下，尽可能多的匹配文本，以使整个表达式匹配不同。独占模式会尽可能的多的匹配，但不考虑表达式剩余部分是否能匹配上。.*+ 将会匹配第一个John之后的所有字符，这会导致表达式中剩余的 hurt 没有匹配项。如果改为贪婪模式，会有一个匹配项。表达式如下：John.*hurt 逻辑操作符正则表达式支持少量的逻辑运算(与，或，非)。与操作是默认的，表达式 John ,意味着J 与 o与h与n。或操作需要显示指定，用 | 表示。例如表达式 John|hurt 意味着John 或 hurt 。 ?!特殊操作 ?!帮我们解决了字符串“不包含”匹配的问题，例如表达式 ^(?!.*went).*$ 意味着匹配的字符串中不能包含“went”字符串。 字符 Type Description . 除换行以外的任意字符 \\ 反斜杠, 单独的反斜杠做为转义字符,与其他特殊字符一起使用。如果想匹配反斜杠本身,需要转义。两个反斜杠实际匹配一个反斜杠。 nn 字符的8进制表示.n 在0至7之间取值 mnn 字符的8进制表示. m 在0至3之间取值, n 在0至7之间取值 \xhh 字符的16进制表示. \uhhhh 字符的16进制表示 0xhhhh. 对应unicode 编码字符 \t 缩进符. \n 换行符 (unicode: ‘\u000A’) \r 回车符 (unicode: ‘\u000D’) \f 制表符 (unicode: ‘\u000C’) \a 警报（铃声）字符 (unicode: ‘\u0007’) \e 转义符 (unicode: ‘\u001B’) \cx 控制符 x 字符分类 Type Description [abc] 匹配 a, 或 b 或 c [^abc] 匹配不是a,b,c 的字符，是否定匹配 [a-zA-Z] 匹配a 到 z ，A到Z 直接的字符，是范围匹配 [a-d[m-p]] 匹配a到d之间字符或 m到p之间字符，是并集匹配 [a-z&amp;&amp;[def]] 匹配 d, e, 或 f. 是交集匹配 (这里是在范围 a-z和字符def之间取交集). [a-z&amp;&amp;[^bc]] 匹配a-z 之间所有字符，排除bc的字符。是减法匹配 [a-z&amp;&amp;[^m-p]] 匹配a-z 之间所有字符,排除m-p之间的字符是减法匹配 内置字符分类 Type Description . 匹配任意一个字符,根据创建Pattern是传入的标志,可能匹配行结尾符 \d 匹配任意数字 [0-9] \D 匹配任意非数字 [^0-9] \s 匹配任意空白符 (空格, 缩进, 换行,回车) \S 匹配任意非空白符 \w 匹配任意单词 \W 匹配任意非单词 边界匹配 Type Description ^ 匹配行首 $ 匹配行尾 \b 匹配单词边界 \B 匹配非单词边界 \A 匹配文本开头 \G 匹配前一匹配项结尾【不知其用法和用意。】 \Z 输入的结束，但是对于最终终止符，如果有的话 \z 输入的结束 量词 贪婪模式 饥饿模式 独占模式 X? X?? X?+ 匹配0或1次 X* X*? X*+ 匹配0或多次 X+ X+? X++ 匹配1或多次 X{n} X{n}? X{n}+ 匹配n次 X{n,} X{n,}? X{n,}+ 匹配最少n次 X{n, m} X{n, m}? X{n, m}+ 匹配最少n次，最多m次 参考资料1.Java正则表达式2.Java 正则表达式 StackOverflowError 问题及其优化]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AutoCache高性能缓存框架使用教程]]></title>
    <url>%2F2016%2F10%2F23%2FAutoCache%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[读者可能会问在下： 为什么要使用AutoCache？简洁、高性能。 现在市面上有那么多缓存的框架，像piccso等都很优秀，那笔者是不是在重复造车？AutoCache是为那些追求轻量级缓存的APP而生的。目的是让开发者既能快速完成APP缓存功能的开发，又能保证上线后性能的稳定。 AutoCache 能够让你高效地编写app缓存代码 ，保证你的数据流被安全、准确地存储到SDcard私有目录。参考下列核心调用代码来开始你的 AutoCache 之旅：1234567891011121314151617181920212223AutoCache.MediaCache.getInstance(context).asyncCache(&quot;url&quot;, new CallBack() &#123;@Overridepublic void onStart() &#123;//Run in UI thread.&#125;@Overridepublic void save2DataBase(String cachePath) &#123;//Run in io thread,//You can sava the cachPath to database or sharepreference.&#125;@Overridepublic void onSuccess(byte[] bytes) &#123;//Run in UI thread.&#125;@Overridepublic void onErro(Throwable e) &#123;//Run in UI thread.&#125;&#125;, FILE_TYPE, &quot;filename&quot;); 集成方法在Module的build.gradle文件中添加如下依赖即可。1compile &apos;com.txm.topcodes.autocache:autocache:0.1.2&apos; 调用方式为方便开发者，AutoCache提供统一调用入口，调用方式十分简洁。下面先给大家看一张思维导图，该图罗列了框架的主体功能及其构成。 从结构图不难看出，AutoCache类就是调用框架的入口类。当我们需要从本地获取流文件时，调用方式是这样的1AutoCache.Media.get…(); 缓存网络文件时，调用方式是这样的1AutoCache.MediaCache.getInstance(context).asyncCache(); 缓存内存文件时，调用方式是这样的1AutoCache.MediaCache.getInstance(context).cache(); 当需要指定文件文件类型时，使用方式是这样的1AutoCache.DIRECTORY_PICTURES 「如需获取详细信息，请在 GitHub 的 auto-cache页面查看源代码.」 文件类型AutoCache支持缓存以下泛媒体类型：Podcasts,Pictures,Movies,Music,Documents,Download。其中Download比较特殊，用它可以指定未知的文件类型。 使用场景当我们的APP从网络获取文件流时，往往会有这样的需求「也可能是其中之一」： 网络请求时，要可以自动将文件保存到APP本地。 网络请求时，将网络图片的本地路径存储到SQLite或其它数据持久化中，以方便逻辑处理。 网络请求时，直接使用从网络获取到文件流。 网络请求时，方便添加进度条功能。 网络请求时，全局捕获异常。 本次请求之后，根据文件名、文件类型从本地获取文件流。 对于需求1。AutoCache完全是在后台IO线程中完成的，不需要调用者主动去操作。 IO线程：I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io线程比Thread线程更有效率。 对于需求2。save2DataBase(String cachePath)回调方法自动就被指定在IO线程中运行。「所以，save2DataBase既是一个非阻塞的方法，又具备IO线程的高效性。」 对于需求3。onSuccess(byte[] bytes)回调方法被指定自动运行在UI线程中。 对于需求4。AutoCache提供了onstart()回调方法作为调用开始的标志，onSuccess(byte[] bytes)或onErro(Throwable e)作为调用结束点。 对于需求5。全局捕获异常指的是：onErro(Throwable e)不仅可以捕获网络异常、本地缓存媒体时发生的异常，而且还可以捕获发生在onStart、save2DataBase、onSuccess中的异常。 对于需求6。AutoCache.Media类提供了4种同步方式来获取本地的媒体流。 最佳实践 ####防止OOMAutoCache.Media类中提供了getSoftBmp(~)，getWeakBmp(~)，getBmp(~)，getFile(~)四种方式来获取流。如果是图片文件，笔者建议使用前两种方式，具体可参考善于利用软引用和弱引用。 ####定制回调方法AutoCache框架提供了CallBackAdapter接口用于替换CallBack接口。可以通过它实现自由定制自己需要的回调方法。「这样是为了代码看上去简洁。」1234567891011AutoCache.MediaCache.getInstance(context).asyncCache(&quot;url&quot;, new CallBackAdapter() &#123;@Overridepublic void save2DataBase(String cachePath) &#123;&#125;@Overridepublic void onSuccess(byte[] bytes) &#123;&#125;//you can add other callback function here.&#125;,FILE_TYPE,&quot;filename&quot;); FAQ 我发现AutoCache还存在BUG？AutoCache是一个完全开源的框架，如果您在使用过程中发现问题，请在GitHub创建一个问题。 我是Eclipse用户，可以使用AutoCache么？不可以。 AutoCache用到了哪些第三方框架？是的。AutoCache是在RXjava+Okhttp基础之上封装的一个轻量级缓存框架。 AutoCache提供缓存文件路径到SQLite数据库的方法了吗？没有。AutoCache缓存的重心是将流文件缓存到本地目录。如果需要将文件路径缓存到SQLite或其他持久化数据层中，开发者需要自行在save2DataBase(cachePath)回调方法中实现逻辑。 我在android studio中链接AutoCache库失败了？确保您的工程使用的远程仓库为jcenter。12345allprojects &#123;repositories &#123;jcenter()&#125;&#125;]]></content>
      <categories>
        <category>我的Android框架</category>
      </categories>
      <tags>
        <tag>Cache</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio NDK开发全攻略]]></title>
    <url>%2F2016%2F08%2F14%2FNDK%E5%BC%80%E5%8F%91%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[读完本章，你可以： 在Android Studio上轻松搭建NDK开发环境。 掌握最快捷的JNI开发方式。 掌握使用.so文件开发Android程序的技巧。 一、 NDK环境搭建 开发工具准备要进行Android NDK开发，首先要下载Android NDK开发工具。可以在AndroidStudio上面下载，也可以自己下载好了，然后将NDK的路径设置为自己下载的Android NDK开发工具的路径。 Gradle的相关配置1) 我们来配置Project的build.gradle。1234/*gradle插件不支持NDK，我们需要使用gradle-experimental插件。 */dependencies &#123;classpath &apos;com.android.tools.build:gradle-experimental:0.7.0&apos;&#125; 2) 我们来配置Module的build.gradle。12345678910111213141516171819202122232425262728293031323334apply plugin: &apos;com.android.model.application&apos;model &#123;android &#123;compileSdkVersion = 23buildToolsVersion = &quot;23.0.2&quot;defaultConfig &#123;applicationId &quot;com.lavor.ndklearning&quot;minSdkVersion.apiLevel 15targetSdkVersion.apiLevel 23versionCode 4versionName &quot;1.0.1&quot;&#125;&#125;android.ndk &#123;moduleName &quot;lavor&quot;ldLibs.addAll([&apos;log&apos;])cppFlags.add(&quot;-std=c++11&quot;)cppFlags.add(&quot;-fexceptions&quot;)platformVersion 15stl &apos;gnustl_shared&apos;&#125;android.buildTypes &#123;release &#123;minifyEnabled = falseproguardFiles.add(file(&quot;proguard-rules.txt&quot;))&#125;&#125;&#125;dependencies &#123;compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])compile &apos;com.android.support:appcompat-v7:23.1.1&apos;compile &apos;com.android.support:recyclerview-v7:23.1.1&apos;compile &apos;com.android.support:design:23.1.1&apos;&#125; 小提示 首先，在apply的时候我们引入的插件名称由’com.android.application’变成了’com.android.model.application’。 其次，在原来android的外层加入了一个model层次。 再次，原来在android的里面的块，除了defaultConfig外，全部移除android块放入model块中与android并列，并且前面的名字加上android.。 然后，compileSdkVersion 23与 buildToolsVersion “23.0.2”改成 compileSdkVersion = 23和 buildToolsVersion = “23.0.2”，中间加上了=。 其次，添加上android.ndk块，块中的moduleName表示C/C++代码打包成so文件的名字。 再次，android.buildTypes块中的proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’改成proguardFiles.add(file(“proguard-rules.txt”))。 最后，注意dependencies块依然在最外层，它不在model块中。 二、 使用NDK开发第一个JNI程序 在Android程序中新建一个包含native（本地）方法的NDKTest类。12345678package com.lavor.ndklearning;public class NDKTest &#123;static &#123;//加载.so库文件System.loadLibrary(&quot;lavor&quot;);&#125;public native String getString();&#125; 小知识 程序中static{}称为静态代码块，它在类初始化的时候执行。不懂请猛击&gt;&gt; 将鼠标移动到方法名getString上，然后按下Alt+Enter快捷键，弹出一些解决的方法建议，点击第一个Create Function… 此时会自动建立一个与java目录同级的jni目录，在jni目录自动建立一个c文件，在c文件中实现了刚才的native方法。 然后，稍稍修改一下.c文件中实现的native方法。12345JNIEXPORT jstring JNICALLJava_com_lavor_ndklearning_NDKTest_getString(JNIEnv *env, jobject instance) &#123;// TODOreturn (*env)-&gt;NewStringUTF(env, &quot;AndroidStudio NDK开发最佳入门实践&quot;);&#125; 补充说明 仔细观察可以看到c文件的方法名是遵循“Java_包名类名本地方法名”来组织的（了解到这些后，我们就可以脱离编译器的帮助，直接去写.c文件啦）。 最后在Android程序中调用JNI接口。1234567891011public class MainActivity extends Activity &#123;private android.widget.TextView text;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);this.text = (TextView) findViewById(R.id.text);NDKTest NDK=new NDKTest();text.setText(NDK.getString());&#125;&#125; 运行程序后界面如下： 深度总结 讲道理，我们在正式开发时，不会像这样子去开发。因为这样的话就会把我们的c代码也暴露了出来。这明显与JNI的安全保密机制相违背，所以，正式开发的时候，我们会使用.so文件进行全保密式的开发。 三、 使用.so文件开发Android程序不知道大家有没有记得上一章说过，使用JNI有个好处就是安全性高，JNI部分的代码很难被反编译。这其实是要归功于.so文件。下图为.so文件的生成位置。具体的使用步骤是怎样的呢？ 新建一个Android工程，命名为：AndroidApplication。（工程名、包名、组织名任意） 导入.so文件至app/libs中。 为了能够调用libs文件夹下的.so资源，需在app的build.gradle的android节点下设置。 12345sourceSets&#123;main&#123;jniLibs.srcDirs = [&apos;libs&apos;]&#125;&#125; 新建相关类结构。 12345678package com.lavor.ndklearning;public class NDKTest &#123;static &#123;//加载.so库文件System.loadLibrary(&quot;lavor&quot;);&#125;public native String getString();&#125; 补充说明 Android端声明native code的代码需要严格按照JNI接口来组织。（也就是说，包名、类名都要和.so文件中JNI名称一致）不懂就点击这里吧&gt;&gt; 函数调用。12345678public class DemoActivity extends AppCompatActivity &#123;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_demo);Log.d(&quot;NDK&quot;,new NDKTest().getString());&#125;&#125; 运行结果如下： 注意啦！此文并非原创，算是对一波优秀文章的总结吧。笔者希望通过这种方式激励自己学习，也期待可以帮到正在学习NDK的你。欢迎指出本文的BUG，共勉！！！！！ 参考资料 AndroidStudio NDK开发最佳入门实践 如何在Android中使用编译好的.so库]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七夕前，我认识了NDK]]></title>
    <url>%2F2016%2F08%2F06%2F%E4%B8%83%E5%A4%95%E5%89%8D%EF%BC%8C%E6%88%91%E8%AE%A4%E8%AF%86%E4%BA%86NDK%2F</url>
    <content type="text"><![CDATA[看前必读 读完本章，你可以掌握NDK、JNI的概念及其开发流程。 阅读时，不必纠结于读不懂的代码结构，后面的教程 都会讲到的。 一、为何要学习NDK？ 代码的保护。Android APK的Java层代码很容易被反编译，但C/C++库反编译难度较大。 可以方便地使用现存的开源库。大部分现存的开源库都是用C/C++代码编写的。 提高程序的执行效率。将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。 便于移植。用C/C++写的库可以方便在其他的嵌入式平台上再次使用。 二、先知道什么是JNIJNI（Java Native Interface）是Java语言提供的Java和C/C++互相沟通的机制，可以实现： java调用本地的C/C++代码 本地的C/C++代码也可以调用java代码 三、开发JNI程序的简化流程 编写Java Code，如下例子： 12345678910111213/*** 加载lavor本地共享库到内存中*/static &#123;System.loadLibrary(&quot;lavor&quot;);&#125;/*** 定义本地方法对应的Java方法** @return*/public native String getString(); 编写C/C++，如下例子： 123456#include &lt;jni.h&gt;JNIEXPORT jstring JNICALLJava_com_lavor_ndklearning_MainActivity_getString(JNIEnv *env, jobject instance) &#123;return (*env)-&gt;NewStringUTF(env, &quot;这是我的c程序代码&quot;);&#125; 编译 C/C++ Code，成功并得到本地共享库。 小知识 本地共享库是Linux下的叫法，文件扩展名是.so，windows下叫动态链接库，文件扩展名是.dll。 C /C++的跨平台性是以牺牲编译时间以及编译难度为代价的。（这里的编译难度是指为适应不同平台而做的编译过程的调整） Java的一次编译到处运行，是以牺牲运行效率为代价的。 编译并打包Java。把本地共享库（.so文件）放置到Java项目的指定目录，一般是libs文件夹。然后编译Java代码即可打包运行。 小知识 Android项目中，.so文件存放地址为libs/armeabi。(armeabi是对应的平台，下一章将会详细介绍) 四、NDK概述NDK(Native Development Kit)是Google为Android进行本地开发而放出的一个本地开发工具， 包括Android的Native API、公共库以及编译工具。其实说白就是Google为方便Android程序猿开发JNI程序，而提供的便捷工具。 补充两点 NDK处在JNI开发流程中的编译环节（第三、四步）。针对不同的平台，NDK可以全自动编译出对应可运行的本地共享库，并可将对应的.so文件和应用程序一起打包成apk发布。（这时，跨平台编译C/C++的难度指数降为0。不明白请猛击） NDK需要Android 1.5版本以上的支持。 五、开发NDK程序的流程这个开发流程大致与JNI的开发流程差不多： SDK开发。编写Java代码，调用各种Android的API实现功能，编写含有native关键字的代码开始JNI。 JNI开发。按照 JNI编码规范，编写与Java交互的本地代码（一般就是数据类型的转换，把 C/C++的数据类转换成Java能识别的，或反过来）。 C/C++开发。编码实现业务逻辑，或调用NDK提供的本地API或库，完成Android平台上特定功能的开发、封装。 NDK编译，编写.mk文件，编译调试，最后修改.mk文件，针对特定的平台（ARM/x86）做编译结果的优化。 最后就是SDK编译、打包，上真机调试了… 注意啦！此文并非原创，算是对一波优秀文章的总结吧。笔者希望通过这种方式激励自己学习，也期待可以帮到正在学习NDK的你。欢迎指出本文的BUG，共勉！！！！！ 参考资料Android之NDK开发]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
