<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[GlobalDialog框架使用教程]]></title>
    <url>%2F2017%2F06%2F10%2FGlobalDialog%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[GlobalDialog是由ITalk应用开源的一款全局对话框库。相比于Android原生对话框的繁琐配置，GlobalDialog的优势在于能够快速实现全局对话框的功能（通知账号下线、通知账号异常等）。进一步了解，请访问笔者的Github。 #集成方法在Module的build.gradle文件中添加如下依赖即可。1compile &apos;com.txm.topcodes.globaldialog:globaldialog:0.1.6&apos; #调用方式常规方式：1234567891011new GlobalDialog.Builder().setContext(context) .setDescription(&quot;hello world&quot;) //弹出框的提示信息。.setStyle(GlobalDialog.Style.SingleAlert) //弹窗的样式。有DoubleAlert、SingleAlert两种，默认为后者。.setForce(ture) //设置弹框销毁的策略。默认为true。.setDialogClickListener(new OnDialogClickListener() &#123; //设置回调，也可以不设置。@Overridepublic void onSure() &#123;super.onSure();&#125;&#125;).build().show(); 精简方式：1234new GlobalDialog.Builder().setContext(context) .setDescription(&quot;hello world&quot;) .build().show(); #FAQ 我发现GlobalDialog还存在BUG？GlobalDialog是一个完全开源的框架，如果您在使用过程中发现问题，欢迎在笔者的GitHub创建一个Issue。 我是Eclipse用户，可以使用GlobalDialog么？不可以。 我在Android studio中链接GlobalDialog库失败了？确保您的工程使用的远程仓库为jcenter。12345allprojects &#123;repositories &#123;jcenter()&#125;&#125;]]></content>
      <categories>
        <category>我的Android框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AutoCache高性能缓存框架使用教程]]></title>
    <url>%2F2016%2F10%2F23%2FAutoCache%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[读者可能会问在下： 为什么要使用AutoCache？简洁、高性能。 现在市面上有那么多缓存的框架，像piccso等都很优秀，那笔者是不是在重复造车？AutoCache是为那些追求轻量级缓存的APP而生的。目的是让开发者既能快速完成APP缓存功能的开发，又能保证上线后性能的稳定。 AutoCache 能够让你高效地编写app缓存代码 ，保证你的数据流被安全、准确地存储到SDcard私有目录。参考下列核心调用代码来开始你的 AutoCache 之旅：1234567891011121314151617181920212223AutoCache.MediaCache.getInstance(context).asyncCache(&quot;url&quot;, new CallBack() &#123;@Overridepublic void onStart() &#123;//Run in UI thread.&#125;@Overridepublic void save2DataBase(String cachePath) &#123;//Run in io thread,//You can sava the cachPath to database or sharepreference.&#125;@Overridepublic void onSuccess(byte[] bytes) &#123;//Run in UI thread.&#125;@Overridepublic void onErro(Throwable e) &#123;//Run in UI thread.&#125;&#125;, FILE_TYPE, &quot;filename&quot;); #集成方法在Module的build.gradle文件中添加如下依赖即可。1compile &apos;com.txm.topcodes.autocache:autocache:0.1.2&apos; #调用方式为方便开发者，AutoCache提供统一调用入口，调用方式十分简洁。下面先给大家看一张思维导图，该图罗列了框架的主体功能及其构成。 从结构图不难看出，AutoCache类就是调用框架的入口类。当我们需要从本地获取流文件时，调用方式是这样的1AutoCache.Media.get…(); 缓存网络文件时，调用方式是这样的1AutoCache.MediaCache.getInstance(context).asyncCache(); 缓存内存文件时，调用方式是这样的1AutoCache.MediaCache.getInstance(context).cache(); 当需要指定文件文件类型时，使用方式是这样的1AutoCache.DIRECTORY_PICTURES 「如需获取详细信息，请在 GitHub 的 auto-cache页面查看源代码.」 #文件类型AutoCache支持缓存以下泛媒体类型：Podcasts,Pictures,Movies,Music,Documents,Download。其中Download比较特殊，用它可以指定未知的文件类型。 #使用场景当我们的APP从网络获取文件流时，往往会有这样的需求「也可能是其中之一」： 网络请求时，要可以自动将文件保存到APP本地。 网络请求时，将网络图片的本地路径存储到SQLite或其它数据持久化中，以方便逻辑处理。 网络请求时，直接使用从网络获取到文件流。 网络请求时，方便添加进度条功能。 网络请求时，全局捕获异常。 本次请求之后，根据文件名、文件类型从本地获取文件流。 对于需求1。AutoCache完全是在后台IO线程中完成的，不需要调用者主动去操作。 IO线程：I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io线程比Thread线程更有效率。 对于需求2。save2DataBase(String cachePath)回调方法自动就被指定在IO线程中运行。「所以，save2DataBase既是一个非阻塞的方法，又具备IO线程的高效性。」 对于需求3。onSuccess(byte[] bytes)回调方法被指定自动运行在UI线程中。 对于需求4。AutoCache提供了onstart()回调方法作为调用开始的标志，onSuccess(byte[] bytes)或onErro(Throwable e)作为调用结束点。 对于需求5。全局捕获异常指的是：onErro(Throwable e)不仅可以捕获网络异常、本地缓存媒体时发生的异常，而且还可以捕获发生在onStart、save2DataBase、onSuccess中的异常。 对于需求6。AutoCache.Media类提供了4种同步方式来获取本地的媒体流。 #最佳实践 ####防止OOMAutoCache.Media类中提供了getSoftBmp(~)，getWeakBmp(~)，getBmp(~)，getFile(~)四种方式来获取流。如果是图片文件，笔者建议使用前两种方式，具体可参考善于利用软引用和弱引用。 ####定制回调方法AutoCache框架提供了CallBackAdapter接口用于替换CallBack接口。可以通过它实现自由定制自己需要的回调方法。「这样是为了代码看上去简洁。」1234567891011AutoCache.MediaCache.getInstance(context).asyncCache(&quot;url&quot;, new CallBackAdapter() &#123;@Overridepublic void save2DataBase(String cachePath) &#123;&#125;@Overridepublic void onSuccess(byte[] bytes) &#123;&#125;//you can add other callback function here.&#125;,FILE_TYPE,&quot;filename&quot;); #FAQ 我发现AutoCache还存在BUG？AutoCache是一个完全开源的框架，如果您在使用过程中发现问题，请在GitHub创建一个问题。 我是Eclipse用户，可以使用AutoCache么？不可以。 AutoCache用到了哪些第三方框架？是的。AutoCache是在RXjava+Okhttp基础之上封装的一个轻量级缓存框架。 AutoCache提供缓存文件路径到SQLite数据库的方法了吗？没有。AutoCache缓存的重心是将流文件缓存到本地目录。如果需要将文件路径缓存到SQLite或其他持久化数据层中，开发者需要自行在save2DataBase(cachePath)回调方法中实现逻辑。 我在android studio中链接AutoCache库失败了？确保您的工程使用的远程仓库为jcenter。12345allprojects &#123;repositories &#123;jcenter()&#125;&#125; ————–我是一条萌萌哒的分割线，表示教程结束—————-]]></content>
      <categories>
        <category>我的Android框架</category>
      </categories>
      <tags>
        <tag>Cache</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio NDK开发全攻略]]></title>
    <url>%2F2016%2F08%2F14%2FNDK%E5%BC%80%E5%8F%91%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[读完本章，你可以： 在Android Studio上轻松搭建NDK开发环境。 掌握最快捷的JNI开发方式。 掌握使用.so文件开发Android程序的技巧。 一、 NDK环境搭建 开发工具准备要进行Android NDK开发，首先要下载Android NDK开发工具。可以在AndroidStudio上面下载，也可以自己下载好了，然后将NDK的路径设置为自己下载的Android NDK开发工具的路径。 Gradle的相关配置1) 我们来配置Project的build.gradle。1234/*gradle插件不支持NDK，我们需要使用gradle-experimental插件。 */dependencies &#123;classpath &apos;com.android.tools.build:gradle-experimental:0.7.0&apos;&#125; 2) 我们来配置Module的build.gradle。12345678910111213141516171819202122232425262728293031323334apply plugin: &apos;com.android.model.application&apos;model &#123;android &#123;compileSdkVersion = 23buildToolsVersion = &quot;23.0.2&quot;defaultConfig &#123;applicationId &quot;com.lavor.ndklearning&quot;minSdkVersion.apiLevel 15targetSdkVersion.apiLevel 23versionCode 4versionName &quot;1.0.1&quot;&#125;&#125;android.ndk &#123;moduleName &quot;lavor&quot;ldLibs.addAll([&apos;log&apos;])cppFlags.add(&quot;-std=c++11&quot;)cppFlags.add(&quot;-fexceptions&quot;)platformVersion 15stl &apos;gnustl_shared&apos;&#125;android.buildTypes &#123;release &#123;minifyEnabled = falseproguardFiles.add(file(&quot;proguard-rules.txt&quot;))&#125;&#125;&#125;dependencies &#123;compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])compile &apos;com.android.support:appcompat-v7:23.1.1&apos;compile &apos;com.android.support:recyclerview-v7:23.1.1&apos;compile &apos;com.android.support:design:23.1.1&apos;&#125; 小提示 首先，在apply的时候我们引入的插件名称由’com.android.application’变成了’com.android.model.application’。 其次，在原来android的外层加入了一个model层次。 再次，原来在android的里面的块，除了defaultConfig外，全部移除android块放入model块中与android并列，并且前面的名字加上android.。 然后，compileSdkVersion 23与 buildToolsVersion “23.0.2”改成 compileSdkVersion = 23和 buildToolsVersion = “23.0.2”，中间加上了=。 其次，添加上android.ndk块，块中的moduleName表示C/C++代码打包成so文件的名字。 再次，android.buildTypes块中的proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’改成proguardFiles.add(file(“proguard-rules.txt”))。 最后，注意dependencies块依然在最外层，它不在model块中。 二、 使用NDK开发第一个JNI程序 在Android程序中新建一个包含native（本地）方法的NDKTest类。12345678package com.lavor.ndklearning;public class NDKTest &#123;static &#123;//加载.so库文件System.loadLibrary(&quot;lavor&quot;);&#125;public native String getString();&#125; 小知识 程序中static{}称为静态代码块，它在类初始化的时候执行。不懂请猛击&gt;&gt; 将鼠标移动到方法名getString上，然后按下Alt+Enter快捷键，弹出一些解决的方法建议，点击第一个Create Function… 此时会自动建立一个与java目录同级的jni目录，在jni目录自动建立一个c文件，在c文件中实现了刚才的native方法。 然后，稍稍修改一下.c文件中实现的native方法。12345JNIEXPORT jstring JNICALLJava_com_lavor_ndklearning_NDKTest_getString(JNIEnv *env, jobject instance) &#123;// TODOreturn (*env)-&gt;NewStringUTF(env, &quot;AndroidStudio NDK开发最佳入门实践&quot;);&#125; 补充说明 仔细观察可以看到c文件的方法名是遵循“Java_包名类名本地方法名”来组织的（了解到这些后，我们就可以脱离编译器的帮助，直接去写.c文件啦）。 最后在Android程序中调用JNI接口。1234567891011public class MainActivity extends Activity &#123;private android.widget.TextView text;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);this.text = (TextView) findViewById(R.id.text);NDKTest NDK=new NDKTest();text.setText(NDK.getString());&#125;&#125; 运行程序后界面如下： 深度总结 讲道理，我们在正式开发时，不会像这样子去开发。因为这样的话就会把我们的c代码也暴露了出来。这明显与JNI的安全保密机制相违背，所以，正式开发的时候，我们会使用.so文件进行全保密式的开发。 三、 使用.so文件开发Android程序不知道大家有没有记得上一章说过，使用JNI有个好处就是安全性高，JNI部分的代码很难被反编译。这其实是要归功于.so文件。下图为.so文件的生成位置。具体的使用步骤是怎样的呢？ 新建一个Android工程，命名为：AndroidApplication。（工程名、包名、组织名任意） 导入.so文件至app/libs中。 为了能够调用libs文件夹下的.so资源，需在app的build.gradle的android节点下设置。 12345sourceSets&#123;main&#123;jniLibs.srcDirs = [&apos;libs&apos;]&#125;&#125; 新建相关类结构。 12345678package com.lavor.ndklearning;public class NDKTest &#123;static &#123;//加载.so库文件System.loadLibrary(&quot;lavor&quot;);&#125;public native String getString();&#125; 补充说明 Android端声明native code的代码需要严格按照JNI接口来组织。（也就是说，包名、类名都要和.so文件中JNI名称一致）不懂就点击这里吧&gt;&gt; 函数调用。12345678public class DemoActivity extends AppCompatActivity &#123;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_demo);Log.d(&quot;NDK&quot;,new NDKTest().getString());&#125;&#125; 运行结果如下： 注意啦！此文并非原创，算是对一波优秀文章的总结吧。笔者希望通过这种方式激励自己学习，也期待可以帮到正在学习NDK的你。欢迎指出本文的BUG，共勉！！！！！ 参考资料 AndroidStudio NDK开发最佳入门实践 如何在Android中使用编译好的.so库 Android Studio NDK及so文件开发]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七夕前，我认识了NDK]]></title>
    <url>%2F2016%2F08%2F06%2F%E4%B8%83%E5%A4%95%E5%89%8D%EF%BC%8C%E6%88%91%E8%AE%A4%E8%AF%86%E4%BA%86NDK%2F</url>
    <content type="text"><![CDATA[看前必读 读完本章，你可以掌握NDK、JNI的概念及其开发流程。 阅读时，不必纠结于读不懂的代码结构，后面的教程 都会讲到的。 一、为何要学习NDK？ 代码的保护。Android APK的Java层代码很容易被反编译，但C/C++库反编译难度较大。 可以方便地使用现存的开源库。大部分现存的开源库都是用C/C++代码编写的。 提高程序的执行效率。将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。 便于移植。用C/C++写的库可以方便在其他的嵌入式平台上再次使用。 二、先知道什么是JNIJNI（Java Native Interface）是Java语言提供的Java和C/C++互相沟通的机制，可以实现： java调用本地的C/C++代码 本地的C/C++代码也可以调用java代码 三、开发JNI程序的简化流程 编写Java Code，如下例子： 12345678910111213/*** 加载lavor本地共享库到内存中*/static &#123;System.loadLibrary(&quot;lavor&quot;);&#125;/*** 定义本地方法对应的Java方法** @return*/public native String getString(); 编写C/C++，如下例子： 123456#include &lt;jni.h&gt;JNIEXPORT jstring JNICALLJava_com_lavor_ndklearning_MainActivity_getString(JNIEnv *env, jobject instance) &#123;return (*env)-&gt;NewStringUTF(env, &quot;这是我的c程序代码&quot;);&#125; 编译 C/C++ Code，成功并得到本地共享库。 小知识 本地共享库是Linux下的叫法，文件扩展名是.so，windows下叫动态链接库，文件扩展名是.dll。 C /C++的跨平台性是以牺牲编译时间以及编译难度为代价的。（这里的编译难度是指为适应不同平台而做的编译过程的调整） Java的一次编译到处运行，是以牺牲运行效率为代价的。 编译并打包Java。把本地共享库（.so文件）放置到Java项目的指定目录，一般是libs文件夹。然后编译Java代码即可打包运行。 小知识 Android项目中，.so文件存放地址为libs/armeabi。(armeabi是对应的平台，下一章将会详细介绍) 四、NDK概述NDK(Native Development Kit)是Google为Android进行本地开发而放出的一个本地开发工具， 包括Android的Native API、公共库以及编译工具。其实说白就是Google为方便Android程序猿开发JNI程序，而提供的便捷工具。 补充两点 NDK处在JNI开发流程中的编译环节（第三、四步）。针对不同的平台，NDK可以全自动编译出对应可运行的本地共享库，并可将对应的.so文件和应用程序一起打包成apk发布。（这时，跨平台编译C/C++的难度指数降为0。不明白请猛击） NDK需要Android 1.5版本以上的支持。 五、开发NDK程序的流程这个开发流程大致与JNI的开发流程差不多： SDK开发。编写Java代码，调用各种Android的API实现功能，编写含有native关键字的代码开始JNI。 JNI开发。按照 JNI编码规范，编写与Java交互的本地代码（一般就是数据类型的转换，把 C/C++的数据类转换成Java能识别的，或反过来）。 C/C++开发。编码实现业务逻辑，或调用NDK提供的本地API或库，完成Android平台上特定功能的开发、封装。 NDK编译，编写.mk文件，编译调试，最后修改.mk文件，针对特定的平台（ARM/x86）做编译结果的优化。 最后就是SDK编译、打包，上真机调试了… 注意啦！此文并非原创，算是对一波优秀文章的总结吧。笔者希望通过这种方式激励自己学习，也期待可以帮到正在学习NDK的你。欢迎指出本文的BUG，共勉！！！！！ 参考资料 NDK和SDK以及JNI有什么关系？ Android之NDK开发 Android NDK官方文档]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
