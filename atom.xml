<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唐先明de博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-20T14:21:23.773Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>TXM</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RecycleView探究（一）：添加头尾布局</title>
    <link href="http://yoursite.com/2018/05/20/RecycleView%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%A4%B4%E5%B0%BE%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/05/20/RecycleView探究（一）：添加头尾布局/</id>
    <published>2018-05-20T13:27:13.000Z</published>
    <updated>2018-05-20T14:21:23.773Z</updated>
    
    <content type="html"><![CDATA[<p>笔者使用RecycleView也有一段时间了，每次遇到需要为RecycleView添加头尾布局的时候，都会是一阵头疼。之前我的做法是直接给依赖的实体集合添加头尾类型的Item Data。打脸的说，这是在赶需求的一种无赖做法。得益于最近项目不是很紧张，所以抽个周末的时间好好研究一下这一块的知识。<a id="more"></a><br>言归正传，本篇文章我要实现的效果是<span style="border-bottom:1px dashed black;">简洁高效地为RecycleView无限增加头尾布局。<span></span></span></p><h3 id="具体思路如下"><a href="#具体思路如下" class="headerlink" title="具体思路如下"></a>具体思路如下</h3><p>1、新建一个<code>HeaderFooterWrapAdapter</code>装饰类，它继承于RecycleView.Adapter，负责拓展普通RecycleView.Adapter对象（被装饰对象）的功能。<br>2、在<code>onCreateViewHolder</code>、<code>onBindViewHolder</code>、<code>getItemViewType</code>、<code>getItemCount</code>这几个方法区分有无头尾布局。如果没有头尾布局，一律按照被装饰对象的逻辑处理。<br>3、在<code>onAttachedToRecyclerView</code>方法内，做好GridView的适配。</p><h3 id="下面我们就把以上的思路转化成可爱的代码吧。"><a href="#下面我们就把以上的思路转化成可爱的代码吧。" class="headerlink" title="下面我们就把以上的思路转化成可爱的代码吧。"></a>下面我们就把以上的思路转化成可爱的代码吧。</h3><p><strong>一、我们应该让HeaderFooterWrapAdapter继承自RecycleView.Adapter,并且定义好需要的成员对象。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HeaderFooterWrapAdapter extends RecyclerView.Adapter &#123;</span><br><span class="line">RecyclerView.Adapter adapter;//被装饰对象</span><br><span class="line">private List&lt;View&gt; headerViews = new ArrayList&lt;&gt;();</span><br><span class="line">private List&lt;View&gt; footerViews = new ArrayList&lt;&gt;();</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 二、重写RecyclerView.Adapter中几个重要的方法。 </strong><br>1、判断item个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int getItemCount() &#123;</span><br><span class="line">if (headerViews.size() != 0 &amp;&amp; footerViews.size() != 0)//同时加了头部和尾部</span><br><span class="line">&#123;</span><br><span class="line">return adapter.getItemCount() + headerViews.size() + footerViews.size();</span><br><span class="line">&#125; else if (headerViews.size() != 0) &#123; //只有头部</span><br><span class="line">return adapter.getItemCount() + headerViews.size();</span><br><span class="line">&#125; else if (footerViews.size() != 0) //只有尾部</span><br><span class="line">&#123;</span><br><span class="line">return adapter.getItemCount() + footerViews.size();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return adapter.getItemCount();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、区分Item类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int getItemViewType(int position) &#123;</span><br><span class="line">if (headerViews.size() != 0) &#123;</span><br><span class="line">if (position &gt;= 0 &amp;&amp; position &lt; headerViews.size()) &#123;</span><br><span class="line">return headerViews.get(position).hashCode();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (footerViews.size() != 0) &#123;</span><br><span class="line">int i = position - headerViews.size() - adapter.getItemCount();</span><br><span class="line">if (i &gt;= 0)</span><br><span class="line">return footerViews.get(i).hashCode();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、创建Item。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;</span><br><span class="line">for (View headerView : headerViews) &#123;</span><br><span class="line">if (headerView.hashCode() == viewType) &#123;</span><br><span class="line">return new HeaderViewHolder(headerView);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (View footerview : footerViews) &#123;</span><br><span class="line">if (footerview.hashCode() == viewType) &#123;</span><br><span class="line">return new FooterViewHolder(footerview);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return adapter.onCreateViewHolder(parent, viewType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、绑定数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) &#123;</span><br><span class="line">if (headerViews.size() != 0 &amp;&amp; footerViews.size() != 0)//同时加了头部和尾部</span><br><span class="line">&#123;</span><br><span class="line">if (position &gt;= headerViews.size() &amp;&amp; position &lt; headerViews.size() + adapter.getItemCount()) &#123;</span><br><span class="line">adapter.onBindViewHolder(holder, position - headerViews.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (headerViews.size() != 0) &#123; //只有头部</span><br><span class="line">if (position &gt;= headerViews.size()) &#123;</span><br><span class="line">adapter.onBindViewHolder(holder, position - headerViews.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (footerViews.size() != 0) //只有尾部</span><br><span class="line">&#123;</span><br><span class="line">if (position &gt;= 0 &amp;&amp; position &lt; adapter.getItemCount()) &#123;</span><br><span class="line">adapter.onBindViewHolder(holder, position);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">adapter.onBindViewHolder(holder, position);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 三、接下来适配GridView，这里主要是通过GridLayoutManager的<code>setSpanSizeLookup</code>方法动态处理头尾布局。 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onAttachedToRecyclerView(@NonNull RecyclerView recyclerView) &#123;</span><br><span class="line">super.onAttachedToRecyclerView(recyclerView);</span><br><span class="line">final RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();</span><br><span class="line">if (layoutManager instanceof GridLayoutManager) &#123;</span><br><span class="line">((GridLayoutManager) layoutManager).setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123;</span><br><span class="line">@Override</span><br><span class="line">public int getSpanSize(int position) &#123;</span><br><span class="line">if (headerViews.size() != 0 &amp;&amp; footerViews.size() != 0) &#123;</span><br><span class="line">if (position &gt;= 0 &amp;&amp; position &lt; headerViews.size()) &#123;</span><br><span class="line">return ((GridLayoutManager) layoutManager).getSpanCount();</span><br><span class="line">&#125; else if (position &gt;= getItemCount() - footerViews.size() &amp;&amp; position &lt; getItemCount()) &#123;</span><br><span class="line">return ((GridLayoutManager) layoutManager).getSpanCount();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (headerViews.size() != 0) &#123;</span><br><span class="line">if (position &gt;= 0 &amp;&amp; position &lt; headerViews.size()) &#123;</span><br><span class="line">return ((GridLayoutManager) layoutManager).getSpanCount();</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125; else if (footerViews.size() != 0) &#123;</span><br><span class="line">if (position &gt;= getItemCount() - footerViews.size() &amp;&amp; position &lt; getItemCount()) &#123;</span><br><span class="line">return ((GridLayoutManager) layoutManager).getSpanCount();</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 四、定义添加头部和尾部布局的公开方法。 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//添加头布局</span><br><span class="line">public void addHeaderView(View headerView) &#123;</span><br><span class="line">this.headerViews.add(headerView);</span><br><span class="line">notifyItemInserted(headerViews.size() - 1);</span><br><span class="line">&#125;</span><br><span class="line">//添加尾布局</span><br><span class="line">public void addFooterView(View footerView) &#123;</span><br><span class="line">this.footerViews.add(footerView);</span><br><span class="line">notifyItemInserted(headerViews.size() + adapter.getItemCount() + footerViews.size() - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了，以上就是为RecycleView添加头尾布局的核心代码。调用方式也很简单，伪代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyAdapter myAdapter=....;</span><br><span class="line">....</span><br><span class="line">HeaderFooterWrapAdapter headerFooterWrapAdapter=new HeaderFooterWrapAdapter(myAdapter);</span><br><span class="line">headerFooterWrapAdapter.addFooterView(footerView01);</span><br><span class="line">headerFooterWrapAdapter.addFooterView(footerView02);</span><br><span class="line">headerFooterWrapAdapter.addFooterView(footerView03);</span><br><span class="line">headerFooterWrapAdapter.addHeaderView(headerView01);</span><br><span class="line">headerFooterWrapAdapter.addHeaderView(headerView02);</span><br><span class="line">headerFooterWrapAdapter.addHeaderView(headerView03);</span><br><span class="line">.......</span><br></pre></td></tr></table></figure></p><p>这里有一点需要注意就是Inflate创建headerView或者footerView时，parent需要传入recyclerView对象才能时布局的顶层属性起效果,例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View footerView = LayoutInflater.from(this).inflate(R.layout.footerview, rcv, false);</span><br></pre></td></tr></table></figure></p><p>关于inflate的使用技巧，可以参考一下<a href="https://www.zhihu.com/question/42782662" target="_blank" rel="noopener">这篇文章</a>。最后，再贴一张实现的效果图片吧～<br><img src="/2018/05/20/RecycleView探究（一）：添加头尾布局/ezgif-4-059e8e8823.gif"></p><hr><p><strong>参考资料</strong><br><a href="https://juejin.im/entry/5975a4ac5188256e2c58e1f4" target="_blank" rel="noopener">学会自己给RecyclerView添加Header、Footer和加载更多回调</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者使用RecycleView也有一段时间了，每次遇到需要为RecycleView添加头尾布局的时候，都会是一阵头疼。之前我的做法是直接给依赖的实体集合添加头尾类型的Item Data。打脸的说，这是在赶需求的一种无赖做法。得益于最近项目不是很紧张，所以抽个周末的时间好好研究一下这一块的知识。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="RecycleView" scheme="http://yoursite.com/tags/RecycleView/"/>
    
  </entry>
  
  <entry>
    <title>PopupWindow使用教程</title>
    <link href="http://yoursite.com/2018/04/29/PopupWindow%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/04/29/PopupWindow使用教程/</id>
    <published>2018-04-29T01:43:34.000Z</published>
    <updated>2018-04-29T04:07:09.612Z</updated>
    
    <content type="html"><![CDATA[<p>PopupWindow是<code>android.widget</code>中一个弹框控件，与普通dialog相比，它的优势在于可以任意改变其在界面中的位置。本篇我们就来好好研究一下它的用法吧。<br><a id="more"></a></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>PopupWindow有两种创建方式：<br>1、通过视图创建，这是最常用的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PopupWindow ()// 创建一个空的PopupWindow</span><br><span class="line"></span><br><span class="line">PopupWindow (View contentView)</span><br><span class="line"></span><br><span class="line">PopupWindow (int width, int height)</span><br><span class="line"></span><br><span class="line">PopupWindow (View contentView, // PopupWindow的内容View, 相当于setContentView</span><br><span class="line">int width, // 宽, 相当于setwidth()</span><br><span class="line">int height,// 高, 相当于setHeight</span><br><span class="line">boolean focusable)//是否可获取焦点, 相当于setFocusable()</span><br></pre></td></tr></table></figure></p><p>2、通过上下文创建，一般不使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PopupWindow (Context context)</span><br><span class="line"></span><br><span class="line">PopupWindow (Context context, </span><br><span class="line">AttributeSet attrs)</span><br><span class="line"></span><br><span class="line">PopupWindow (Context context, </span><br><span class="line">AttributeSet attrs, </span><br><span class="line">int defStyleAttr)</span><br><span class="line"></span><br><span class="line">PopupWindow (Context context, </span><br><span class="line">AttributeSet attrs, </span><br><span class="line">int defStyleAttr, </span><br><span class="line">int defStyleRes)</span><br></pre></td></tr></table></figure></p><p>创建PopuWindow必要的三个条件:<br>void setHeight (int height) // 因为PopupWindow没有默认布局所以必须指定宽高<br>void setWidth (int width)<br>void setContentView (View contentView) // 需要显示的内容</p><blockquote><p><strong>注意</strong><br>PopupWindow指定宽高时用LayoutParams.WRAP_CONTENT包裹布局， 这时并不总是布局多大就显示多大，估计是BUG吧。所以遇到这种情况，具体的PopupWindow大小我们还是需要手动计算。</p></blockquote><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><p>显示PopupWindow可以分为两种方式:</p><h4 id="1、附着某个控件showAsDropDown。"><a href="#1、附着某个控件showAsDropDown。" class="headerlink" title="1、附着某个控件showAsDropDown。"></a>1、附着某个控件showAsDropDown。</h4><p>默认是PopupWindow的左上角对其控件的左下角,或者设置<code>Gravity.RIGHT</code>, PopupWindow的右上角对齐控件的右下角。不存在Gravity.TOP或Gravity.BOTTOM效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void showAsDropDown (View anchor) //弹窗显示在anchor控件左下方</span><br><span class="line"></span><br><span class="line">void showAsDropDown (View anchor, int xoff, int yoff)//以控件左下角为原点的偏移坐标</span><br><span class="line"></span><br><span class="line">void showAsDropDown (View anchor,int xoff,int yoff,int gravity) //弹窗显示在控件的左下方还是右下方, 参数Gravity.RIGHT/Gravity.LEFT. 默认是左下方</span><br></pre></td></tr></table></figure></p><h4 id="2、设置屏幕坐标showAtLocation。"><a href="#2、设置屏幕坐标showAtLocation。" class="headerlink" title="2、设置屏幕坐标showAtLocation。"></a>2、设置屏幕坐标showAtLocation。</h4><p>当前窗口的任意位置(setClippingEnabled设置为ture时，不包括状态栏。)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void showAtLocation (</span><br><span class="line">View parent, //只要是屏幕上任意控件对象即可</span><br><span class="line">int gravity, //屏幕位置</span><br><span class="line">int x,       //偏移坐标</span><br><span class="line">int y)</span><br></pre></td></tr></table></figure></p><p>parent:该属性只要是当前任意控件对象即可(View和ViewGroup都行), 官方文档介绍该对象参数主要是为了得到该对象的<code>getWindowToken()</code>方法。<br>需要注意的是多次调用show方法只会执行第一句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mPopupWindow.showAtLocation(popupwindow, Gravity.TOP, 100, 0); // 只有该行生效</span><br><span class="line">mPopupWindow.showAtLocation(popupwindow, Gravity.LEFT, 100, 0);</span><br><span class="line">mPopupWindow.showAtLocation(popupwindow, Gravity.RIGHT, 100, 0);</span><br><span class="line">mPopupWindow.showAtLocation(popupwindow, Gravity.BOTTOM, 100, 0);</span><br></pre></td></tr></table></figure></p><h4 id="隐藏PopupWindow"><a href="#隐藏PopupWindow" class="headerlink" title="隐藏PopupWindow"></a>隐藏PopupWindow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void dismiss ()</span><br></pre></td></tr></table></figure><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><h4 id="外部被点击取消"><a href="#外部被点击取消" class="headerlink" title="外部被点击取消"></a>外部被点击取消</h4><p>如果为true点击PopupWindow外部区域可以取消PopupWindow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setOutsideTouchable (boolean touchable) // 设置外部是否可被点击</span><br></pre></td></tr></table></figure></p><p>但是在android6.0以下还是无法点击外部取消Popupwindow. 可以通过设置背景来解决这个Bug。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPopupWindow.setBackgroundDrawable(new BitmapDrawable());</span><br></pre></td></tr></table></figure></p><h4 id="解决NavigationBar重叠"><a href="#解决NavigationBar重叠" class="headerlink" title="解决NavigationBar重叠"></a>解决NavigationBar重叠</h4><p>这是Android5.0(API22)后添加的方法, 默认为true，为true时将不会与导航栏重叠。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setAttachedInDecor (boolean enabled)</span><br></pre></td></tr></table></figure></p><h4 id="可获取焦点"><a href="#可获取焦点" class="headerlink" title="可获取焦点"></a>可获取焦点</h4><p>一般控件都不需要焦点，但是输入框EditText需要先获取焦点才能输入。 最重要的是当PopupWindow可获取焦点时按下手机返回键将不会销毁当前Activity而是关闭当前PopupWindow。所以我们一般还是设置为true， 更加符合用户操作逻辑。该方法为true时同时拥有setOutsideTouchable(true)的作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setFocusable (boolean focusable)</span><br></pre></td></tr></table></figure></p><h4 id="遮盖附着View"><a href="#遮盖附着View" class="headerlink" title="遮盖附着View"></a>遮盖附着View</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setOverlapAnchor (boolean overlapAnchor)</span><br></pre></td></tr></table></figure><p>PopupWindow对齐方式从View anchor的左下角变成了左上角了。</p><h4 id="窗口裁剪"><a href="#窗口裁剪" class="headerlink" title="窗口裁剪"></a>窗口裁剪</h4><p>PopupWindow默认是不会超出屏幕边界的. 但是如果该方法为false时会采用精准位置, 能超出屏幕范围.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setClippingEnabled (boolean enabled)</span><br></pre></td></tr></table></figure></p><h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><h4 id="设置动画"><a href="#设置动画" class="headerlink" title="设置动画"></a>设置动画</h4><p>可以设置popupWindow的显示和隐藏动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setAnimationStyle (int animationStyle)</span><br></pre></td></tr></table></figure></p><p>可以看到方法是传入一个Style的样式id，示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;popupwindow_anim_style&quot;&gt;</span><br><span class="line">&lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/dialog_bottom_enter&lt;/item&gt;</span><br><span class="line">&lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/dialog_bottom_exit&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>分别由两个属性组成. 两个属性各代表一个anim动画文件.</p><h4 id="进入和退出动画"><a href="#进入和退出动画" class="headerlink" title="进入和退出动画"></a>进入和退出动画</h4><p>这是在Android6.0(API 23)后加入的方法. 配合Material Design的转场动画使用.<br>进入动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setEnterTransition (Transition enterTransition)</span><br></pre></td></tr></table></figure></p><p>退出动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setExitTransition (Transition exitTransition)</span><br></pre></td></tr></table></figure></p><h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>针对PopupWindow中包含EditText控件.</p><h4 id="输入模式-1"><a href="#输入模式-1" class="headerlink" title="输入模式"></a>输入模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setInputMethodMode (int mode)</span><br></pre></td></tr></table></figure><p>支持三种模式：<br>1、INPUT_METHOD_FROM_FOCUSABLE 根据可否获取焦点判断是否可输入<br>2、INPUT_METHOD_NEEDED 允许输入<br>3、INPUT_METHOD_NOT_NEEDED 不允许输入</p><h4 id="软键盘模式"><a href="#软键盘模式" class="headerlink" title="软键盘模式"></a>软键盘模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setSoftInputMode (int mode) // mode为WindowManager.LayoutParams的softInputMode常量</span><br></pre></td></tr></table></figure><p>softInputMode包含九种取值, 可组合使用,分为两类:<br>显示状态模式</p><ol><li>SOFT_INPUT_STATE_UNSPECIFIED 默认模式</li><li>SOFT_INPUT_STATE_HIDDEN</li><li>SOFT_INPUT_STATE_ALWAYS_HIDDEN 总是隐藏</li><li>SOFT_INPUT_STATE_UNCHANGED</li><li>SOFT_INPUT_STATE_VISIBLE</li><li>SOFT_INPUT_STATE_ALWAYS_VISIBLE 自动弹出软键盘</li></ol><p>调整模式</p><ol><li>SOFT_INPUT_ADJUST_UNSPECIFIED 默认模式</li><li>SOFT_INPUT_ADJUST_RESIZE 软键盘弹出后PopupWindow会自动调整坐标,不被遮挡</li><li>SOFT_INPUT_ADJUST_PAN</li></ol><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><h4 id="隐藏事件监听"><a href="#隐藏事件监听" class="headerlink" title="隐藏事件监听"></a>隐藏事件监听</h4><p>即PopupWindow执行<code>dismiss()</code>后回调的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setOnDismissListener (PopupWindow.OnDismissListener onDismissListener)</span><br></pre></td></tr></table></figure></p><h4 id="触摸事件拦截"><a href="#触摸事件拦截" class="headerlink" title="触摸事件拦截"></a>触摸事件拦截</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setTouchInterceptor (View.OnTouchListener l)</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>以下的更新PopupWindow都必须在PopupWindow处于以及被显示的状态下才行，且PopupWindow的宽高设置都必须大于等于0， 如果想忽略PopupWindow的宽高设置就设为-1。</p><h4 id="更新状态"><a href="#更新状态" class="headerlink" title="更新状态"></a>更新状态</h4><p>该方法不能更新PopupWindow的宽高, 只能更新PopupWindow的状态. 例如更新Focusable和OutsideTouchable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void update ()</span><br></pre></td></tr></table></figure></p><h4 id="更新尺寸"><a href="#更新尺寸" class="headerlink" title="更新尺寸"></a>更新尺寸</h4><p>上面说过update()不能更新PopupWindow的宽高, 但是提供更新宽高的update方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void update (int width, // 更新PopupWindow的宽高</span><br><span class="line">int height)</span><br></pre></td></tr></table></figure></p><h4 id="更新显示位置"><a href="#更新显示位置" class="headerlink" title="更新显示位置"></a>更新显示位置</h4><p>该方法是相当于重新showAsDropDown, 所以这是<strong>相对于控件</strong>的位置更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void update (View anchor, // 更新显示控件的位置</span><br><span class="line">int width, </span><br><span class="line">int height)</span><br><span class="line"></span><br><span class="line">void update (View anchor, </span><br><span class="line">int xoff, // 相对于控件的偏移值</span><br><span class="line">int yoff, </span><br><span class="line">int width, </span><br><span class="line">int height)</span><br></pre></td></tr></table></figure></p><h4 id="相对位置更新"><a href="#相对位置更新" class="headerlink" title="相对位置更新"></a>相对位置更新</h4><p>相对于当前的位置进行偏移， 不同的显示位置对于的相对原点也不同。<br>showAsDropDown的相对原点是整个屏幕左上角, 包括状态栏。所以由于包括状态栏所以坐标偏移的时候一定要y轴偏移大于60超出状态栏的高度。 否则因为遮挡状态栏导致PopupWindow无法显示.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPopupWindow.update(50, 60, -1,-1); // x轴偏移50</span><br></pre></td></tr></table></figure></p><p>showAtLocation的相对原点是<strong>自身位置</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void update (int x, // 坐标偏移</span><br><span class="line">int y, </span><br><span class="line">int width, // PopupWindow宽高</span><br><span class="line">int height)</span><br><span class="line"></span><br><span class="line">void update (int x, </span><br><span class="line">int y, </span><br><span class="line">int width, </span><br><span class="line">int height, </span><br><span class="line">boolean force) // 可获取焦点</span><br></pre></td></tr></table></figure></p><h2 id="背景变灰"><a href="#背景变灰" class="headerlink" title="背景变灰"></a>背景变灰</h2><p>当我们弹出PopupWindow时，有时希望背景能够变成灰色，那我们可以通过以下方式实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 设置添加屏幕的背景透明度</span><br><span class="line">* </span><br><span class="line">* @param bgAlpha 屏幕透明度0.0-1.0 1表示完全不透明</span><br><span class="line">*            </span><br><span class="line">*/</span><br><span class="line">public void setBackgroundAlpha(float bgAlpha) &#123;</span><br><span class="line">WindowManager.LayoutParams lp = ((Activity) mContext).getWindow().getAttributes();</span><br><span class="line">lp.alpha = bgAlpha;</span><br><span class="line">((Activity) mContext).getWindow().setAttributes(lp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考资料</strong><br><a href="https://juejin.im/post/58ed82c3a22b9d0063469e98" target="_blank" rel="noopener">PopupWindow最全使用说明</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PopupWindow是&lt;code&gt;android.widget&lt;/code&gt;中一个弹框控件，与普通dialog相比，它的优势在于可以任意改变其在界面中的位置。本篇我们就来好好研究一下它的用法吧。&lt;br&gt;
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="PopupWindow" scheme="http://yoursite.com/tags/PopupWindow/"/>
    
  </entry>
  
  <entry>
    <title>Java枚举用法总结</title>
    <link href="http://yoursite.com/2018/03/24/Java%E6%9E%9A%E4%B8%BE%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/24/Java枚举用法总结/</id>
    <published>2018-03-24T12:35:09.000Z</published>
    <updated>2018-03-24T12:39:28.600Z</updated>
    
    <content type="html"><![CDATA[<p>枚举是JDK1.5引入的新类型，可以说是一个小功能，但是它却给我们的程序开发带来了极大的便捷，本文就对它的用法做一个小结。<a id="more"></a></p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>在JDK 1.5之前，我们定义常量都是public final static ……，这种定义方式有一个很大的弊端就是代码紊乱，需要大量的注释。有了枚举类型，事情就好办了。比如我们要定义一组颜色常量，可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Color&#123;</span><br><span class="line">WHITE,BLACK,RED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是很清晰了呢，除了会使代码结构清晰之外，枚举还提供了许多便捷的操作……</p><h4 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enum Signal &#123;  </span><br><span class="line">GREEN, YELLOW, RED  </span><br><span class="line">&#125;  </span><br><span class="line">public class TrafficLight &#123;  </span><br><span class="line">Signal color = Signal.RED;  </span><br><span class="line">public void change() &#123;  </span><br><span class="line">switch (color) &#123;  </span><br><span class="line">case RED:  </span><br><span class="line">color = Signal.GREEN;  </span><br><span class="line">break;  </span><br><span class="line">case YELLOW:  </span><br><span class="line">color = Signal.RED;  </span><br><span class="line">break;  </span><br><span class="line">case GREEN:  </span><br><span class="line">color = Signal.YELLOW;  </span><br><span class="line">break;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向枚举中添加新方法"><a href="#向枚举中添加新方法" class="headerlink" title="向枚举中添加新方法"></a>向枚举中添加新方法</h4><p>枚举中可以自定义方法，但是必须保证先定义枚举的实例，并且在最后一个实例后面用分号结尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public enum Color &#123;  </span><br><span class="line">RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  </span><br><span class="line">// 成员变量  </span><br><span class="line">private String name;  </span><br><span class="line">private int index;  </span><br><span class="line">// 构造方法  </span><br><span class="line">private Color(String name, int index) &#123;  </span><br><span class="line">this.name = name;  </span><br><span class="line">this.index = index;  </span><br><span class="line">&#125;  </span><br><span class="line">// 普通方法  </span><br><span class="line">public static String getName(int index) &#123;  </span><br><span class="line">for (Color c : Color.values()) &#123;  </span><br><span class="line">if (c.getIndex() == index) &#123;  </span><br><span class="line">return c.name;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">return null;  </span><br><span class="line">&#125;  </span><br><span class="line">// get set 方法  </span><br><span class="line">public String getName() &#123;  </span><br><span class="line">return name;  </span><br><span class="line">&#125;  </span><br><span class="line">public void setName(String name) &#123;  </span><br><span class="line">this.name = name;  </span><br><span class="line">&#125;  </span><br><span class="line">public int getIndex() &#123;  </span><br><span class="line">return index;  </span><br><span class="line">&#125;  </span><br><span class="line">public void setIndex(int index) &#123;  </span><br><span class="line">this.index = index;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>补充</strong><br>枚举有两个默认的方法，<code>name()</code>、<code>ordinal()</code>方法。前者可以理解为是枚举实例的名称。后者理解为枚举的编号，从0递增。</p></blockquote><h4 id="覆盖枚举的方法"><a href="#覆盖枚举的方法" class="headerlink" title="覆盖枚举的方法"></a>覆盖枚举的方法</h4><p>下面给出覆盖<code>toString()</code>方法的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public enum Color &#123;  </span><br><span class="line">RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  </span><br><span class="line">// 成员变量  </span><br><span class="line">private String name;  </span><br><span class="line">private int index;  </span><br><span class="line">// 构造方法  </span><br><span class="line">private Color(String name, int index) &#123;  </span><br><span class="line">this.name = name;  </span><br><span class="line">this.index = index;  </span><br><span class="line">&#125;  </span><br><span class="line">//覆盖方法  </span><br><span class="line">@Override </span><br><span class="line">public String toString() &#123;  </span><br><span class="line">return this.index+&quot;_&quot;+this.name;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p>所有枚举都自动继承自java.lang.Enum类。由于Java不支持多继承，所以我们不能将枚举类继承其它的类，但是枚举类可以实现多个接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface Behaviour &#123;  </span><br><span class="line">void print();  </span><br><span class="line">String getInfo();  </span><br><span class="line">&#125;  </span><br><span class="line">public enum Color implements Behaviour&#123;  </span><br><span class="line">RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  </span><br><span class="line">// 成员变量  </span><br><span class="line">private String name;  </span><br><span class="line">private int index;  </span><br><span class="line">// 构造方法  </span><br><span class="line">private Color(String name, int index) &#123;  </span><br><span class="line">this.name = name;  </span><br><span class="line">this.index = index;  </span><br><span class="line">&#125;  </span><br><span class="line">//接口方法  </span><br><span class="line">@Override  </span><br><span class="line">public String getInfo() &#123;  </span><br><span class="line">return this.name;  </span><br><span class="line">&#125;  </span><br><span class="line">//接口方法  </span><br><span class="line">@Override  </span><br><span class="line">public void print() &#123;  </span><br><span class="line">System.out.println(this.index+&quot;:&quot;+this.name);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用接口组织枚举"><a href="#使用接口组织枚举" class="headerlink" title="使用接口组织枚举"></a>使用接口组织枚举</h4><p>有时候我们需要在一个文件中统一管理常量话，可以使用接口组织枚举。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Food &#123;  </span><br><span class="line">enum Coffee implements Food&#123;  </span><br><span class="line">BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO  </span><br><span class="line">&#125;  </span><br><span class="line">enum Dessert implements Food&#123;  </span><br><span class="line">FRUIT, CAKE, GELATO  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考资料</strong><br><a href="https://blog.csdn.net/qq_27093465/article/details/52180865" target="_blank" rel="noopener">Java 枚举(enum) 详解7种常见的用法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;枚举是JDK1.5引入的新类型，可以说是一个小功能，但是它却给我们的程序开发带来了极大的便捷，本文就对它的用法做一个小结。
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="枚举" scheme="http://yoursite.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池</title>
    <link href="http://yoursite.com/2018/03/13/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/03/13/Java线程池/</id>
    <published>2018-03-13T14:44:03.000Z</published>
    <updated>2018-05-20T07:31:43.236Z</updated>
    
    <content type="html"><![CDATA[<p>在面向对象编程中，创建和销毁对象是很耗时间和资源的，因此，在多线程编程过程中如果能减少线程的创建和销毁操作，那么对于程序的性能将得到很大的提高。Java线程池的出现，解决了这个问题。不仅如此，线程池还可以控制线程的创建数量，避免内存消耗过多。<a id="more"></a><br>学习线程池，需要用到以下几个关键类。<br>1、Executor<br>2、Executors<br>3、ExecutorSevice<br>4、ThreadPoolExecutor<br>在分别介绍它们之前，让我们先捋清一下它们之间的关系。<br><img src="/2018/03/13/Java线程池/Jietu20180512-192205@2x.jpg"><br>图中的AbstractExecutorService类可以不用理会，我们不讲它。另外，Excutors类不好在<a href="http://www.cnblogs.com/xrq730/p/5527115.html" target="_blank" rel="noopener">UML类图</a>中将其涵盖进去，等会我们再介绍。</p><h1 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h1><p>查看Executor的API，有这么一段话：</p><blockquote><p>The Executor implementations provided in this package implement ExecutorService, which is a more extensive interface. The ThreadPoolExecutor class provides an extensible thread pool implementation. The Executors class provides convenient factory methods for these Executors.</p></blockquote><p>大概意思是，ExecutorService接口在Executor接口的基础上又拓展了一些功能；而ThreadPoolExecutor类提供了一个可拓展的线程池实现；Executors类是一个工厂类，它为Executor类的实现提供了便捷的通道。<br>这里我们注意到了之前提到的<code>Executors</code>类，它是一个工厂方法，用来产生Executor对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Executor excutor = Executors.newFixedThreadPool(10);  </span><br><span class="line">excutor.execute(new Runnable() &#123;  </span><br><span class="line">public void run() &#123;  </span><br><span class="line">System.out.println(&quot;Asynchronous task&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>注意以上是一个异步任务。同时，除了可以使用<code>newFixedThreadPool</code>创建Executor对象之外还可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Executors.newSingleThreadExecutor();  </span><br><span class="line">Executors.newScheduledThreadPool(size);</span><br></pre></td></tr></table></figure></p><p>生产Executor对象，具体用法之后会介绍。</p><h1 id="ExecutorSevice"><a href="#ExecutorSevice" class="headerlink" title="ExecutorSevice"></a>ExecutorSevice</h1><p>如上所提，ExecutorSevice实际上只是比Executor多了一些方法而已，它同样可以通过<code>Executors</code>提供的工厂方法创造出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorSevice executorService = Executors.newFixedThreadPool(10);</span><br></pre></td></tr></table></figure></p><p>除了<code>execute()</code>，ExecutorSevice提供了允许返回任务执行结果的<code>submit()</code>，返回结果的方式有两种：<br>1、传入Runnable对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future=executor.submit(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;Asynchronous task&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>2、传入Callable对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future = executor.submit(new Callable&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public String call() throws Exception &#123;</span><br><span class="line">System.out.println(&quot;Asynchronous task&quot;);</span><br><span class="line">return &quot;result&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个两种方式都可以通过<code>future.get（）</code>获得返回的结果，并且<code>future.get（）</code>是一个阻塞方法。不同的是，Runnable方式的返回值始终为null，Callable方式的返回值将取决于用户的设定。<br>特别地，ExecutorSevice还提供了可以处理Callable集合的方法invokeAny和invokeAll,具体用法可以参考<a href="https://blog.csdn.net/suifeng3051/article/details/49443835" target="_blank" rel="noopener">这一篇文章</a>。<br>将<code>invokeAll</code>运用在需要并行运行的场景，可以减少比较多的方法执行时间。比如：方法A和方法B分别都执行了一些耗时操作，而我们最后的值依赖于这两个方法的执行结果。那么第一种方法是让A、B串行执行，第二种方法是将A、B逻辑分别设置为callable对象，之后通过invokeAll并行执行它俩，实验结果是第二种方法优于第一种方法的实现。</p><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>ThreadPoolExecutor支持通过调整构造参数来配置不同的处理策略，下面主要介绍一下常用的策略配置方法以及应用场景。</p><h4 id="ThreadPoolExecutor-的处理逻辑"><a href="#ThreadPoolExecutor-的处理逻辑" class="headerlink" title="ThreadPoolExecutor 的处理逻辑"></a>ThreadPoolExecutor 的处理逻辑</h4><p>首先看一下 ThreadPoolExecutor 构造函数的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,  //线程池核心线程数量</span><br><span class="line">int maximumPoolSize,                  //线程池最大线程数量</span><br><span class="line">long keepAliveTime,                   //线程KeepAlive时间，当线程池数量超过核心线程数量以后，idle时间超过这个值的线程会被终止</span><br><span class="line">TimeUnit unit,                        //线程KeepAlive时间单位</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,    //任务队列</span><br><span class="line">ThreadFactory threadFactory,          //创建线程的工厂对象</span><br><span class="line">RejectedExecutionHandler handler)     //任务被拒绝后调用的handler</span><br></pre></td></tr></table></figure></p><p>ThreadPoolExecutor 对线程池和队列的使用方式如下：<br>1、从线程池中获取可用线程执行任务，如果没有可用线程则使用ThreadFactory创建新的线程，直到线程数达到corePoolSize限制；<br>2、线程池线程数达到corePoolSize以后，新的任务将被放入队列，直到队列不能再容纳更多的任务；<br>3、当队列不能再容纳更多的任务以后，会创建新的线程，直到线程数达到maxinumPoolSize限制；<br>4、线程数达到maxinumPoolSize限制以后新任务会被拒绝执行，调用 RejectedExecutionHandler 进行处理。</p><h4 id="三种常用的-ThreadPoolExecutor"><a href="#三种常用的-ThreadPoolExecutor" class="headerlink" title="三种常用的 ThreadPoolExecutor"></a>三种常用的 ThreadPoolExecutor</h4><p>Executors 是提供了一组工厂方法用于创建常用的 ExecutorService ，分别是 FixedThreadPool，CachedThreadPool 以及 SingleThreadExecutor。这三种ThreadPoolExecutor都是调用 ThreadPoolExecutor 构造函数进行创建，区别在于参数不同。<br><strong>1、FixedThreadPool - 线程池大小固定，任务队列无界。</strong><br>下面是 Executors 类 newFixedThreadPool 方法的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">0L, TimeUnit.MILLISECONDS,</span><br><span class="line">new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到 corePoolSize 和 maximumPoolSize 设置成了相同的值，此时不存在线程数量大于核心线程数量的情况，所以KeepAlive时间设置不会生效。任务队列使用的是不限制大小的 LinkedBlockingQueue ，由于是无界队列所以容纳的任务数量没有上限。<br>因此，FixedThreadPool的行为如下：<br>1、从线程池中获取可用线程执行任务，如果没有可用线程则使用ThreadFactory创建新的线程，直到线程数达到nThreads；<br>2、线程池线程数达到nThreads以后，新的任务将被放入队列。<br>FixedThreadPool的优点是能够保证所有的任务都被执行，永远不会拒绝新的任务；同时缺点是队列数量没有限制，在任务执行时间无限延长的这种极端情况下会造成内存问题。<br><strong>2、SingleThreadExecutor - 线程池大小固定为1，任务队列无界</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">return new FinalizableDelegatedExecutorService</span><br><span class="line">(new ThreadPoolExecutor(1, 1,</span><br><span class="line">0L, TimeUnit.MILLISECONDS,</span><br><span class="line">new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个工厂方法中使用无界LinkedBlockingQueue，并的将线程数设置成1。虽然是单线程处理，一旦线程因为处理异常等原因终止的时候，ThreadPoolExecutor会自动创建一个新的线程继续进行工作。<br>SingleThreadExecutor 适用于在逻辑上需要单线程处理任务的场景，同时无界的LinkedBlockingQueue保证新任务都能够放入队列，不会被拒绝；缺点和FixedThreadPool相同，当处理任务无限等待的时候会造成内存问题。<br><strong>3、CachedThreadPool - 线程池无限大（MAX INT），等待队列长度为1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">60L, TimeUnit.SECONDS,</span><br><span class="line">new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SynchronousQueue是一个只有1个元素的队列，入队的任务需要一直等待直到队列中的元素被移出。核心线程数是0，意味着所有任务会先入队列；最大线程数是Integer.MAX_VALUE，可以认为线程数量是没有限制的。KeepAlive时间被设置成60秒，意味着在没有任务的时候超过核心线程数的线程等待60秒以后退出。CachedThreadPool对任务的处理策略是提交的任务会立即分配一个线程进行执行，线程池中线程数量会随着任务数的变化自动扩张和缩减，在任务执行时间无限延长的极端情况下会创建过多的线程。</p><blockquote><p><strong>说明：</strong><br>实验证明，当超过核心线程数后，线程池的机制是尽量重用还在KeepAlive时间内的线程。</p></blockquote><hr><p><strong>参考资料</strong><br><a href="https://segmentfault.com/a/1190000008394155" target="_blank" rel="noopener">ThreadPoolExecutor策略配置以及应用场景</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面向对象编程中，创建和销毁对象是很耗时间和资源的，因此，在多线程编程过程中如果能减少线程的创建和销毁操作，那么对于程序的性能将得到很大的提高。Java线程池的出现，解决了这个问题。不仅如此，线程池还可以控制线程的创建数量，避免内存消耗过多。
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="并发编程" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android图片压缩方略</title>
    <link href="http://yoursite.com/2018/02/22/Android%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E6%96%B9%E7%95%A5/"/>
    <id>http://yoursite.com/2018/02/22/Android图片压缩方略/</id>
    <published>2018-02-22T02:50:42.000Z</published>
    <updated>2018-03-07T09:19:57.780Z</updated>
    
    <content type="html"><![CDATA[<p>我们通常采用多种方式结合的方法实现图片压缩需求，这些方式包括质量压缩、尺寸压缩。本章将分别介绍这两种方式，并且最后将结合这两种方式实现图片压缩的最优解决方案。<a id="more"></a></p><h1 id="质量压缩"><a href="#质量压缩" class="headerlink" title="质量压缩"></a>质量压缩</h1><p>设置bitmap options属性，降低图片的质量，但像素不会减少，options 属性的值为0-100，来实现压缩。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void compressImageToFile(Bitmap bmp,File file) &#123;</span><br><span class="line">// 0-100 100为不压缩</span><br><span class="line">int options = 100; </span><br><span class="line">ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">// 把压缩后的数据存放到baos中</span><br><span class="line">bmp.compress(Bitmap.CompressFormat.JPEG, options, baos);</span><br><span class="line">try &#123;  </span><br><span class="line">FileOutputStream fos = new FileOutputStream(file);  </span><br><span class="line">fos.write(baos.toByteArray());  </span><br><span class="line">fos.flush();  </span><br><span class="line">fos.close();  </span><br><span class="line">&#125; catch (Exception e) &#123;  </span><br><span class="line">e.printStackTrace();  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="尺寸压缩"><a href="#尺寸压缩" class="headerlink" title="尺寸压缩"></a>尺寸压缩</h1><p>通过缩放图片像素来减少图片所占内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void compressBitmapToFile(Bitmap bmp, File file)&#123;</span><br><span class="line">// 尺寸压缩倍数,值越大，图片尺寸越小</span><br><span class="line">int ratio = 2;</span><br><span class="line">// 压缩Bitmap到对应尺寸</span><br><span class="line">Bitmap result = Bitmap.createBitmap(bmp.getWidth() / ratio, bmp.getHeight() / ratio, Config.ARGB_8888);</span><br><span class="line">Canvas canvas = new Canvas(result);</span><br><span class="line">Rect rect = new Rect(0, 0, bmp.getWidth() / ratio, bmp.getHeight() / ratio);</span><br><span class="line">canvas.drawBitmap(bmp, null, rect, null);</span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">// 把压缩后的数据存放到baos中</span><br><span class="line">result.compress(Bitmap.CompressFormat.JPEG, 100 ,baos);</span><br><span class="line">try &#123;  </span><br><span class="line">FileOutputStream fos = new FileOutputStream(file);  </span><br><span class="line">fos.write(baos.toByteArray());  </span><br><span class="line">fos.flush();  </span><br><span class="line">fos.close();  </span><br><span class="line">&#125; catch (Exception e) &#123;  </span><br><span class="line">e.printStackTrace();  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设置图片采样率，减少图片像素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void compressBitmap(String filePath, File file)&#123;</span><br><span class="line">// 数值越高，图片像素越低</span><br><span class="line">int inSampleSize = 2;</span><br><span class="line">BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">//采样率</span><br><span class="line">options.inSampleSize = inSampleSize;</span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeFile(filePath, options);  </span><br><span class="line">ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">// 把压缩后的数据存放到baos中</span><br><span class="line">bitmap.compress(Bitmap.CompressFormat.JPEG, 100 ,baos);</span><br><span class="line">try &#123;  </span><br><span class="line">FileOutputStream fos = new FileOutputStream(file);  </span><br><span class="line">fos.write(baos.toByteArray());  </span><br><span class="line">fos.flush();  </span><br><span class="line">fos.close();  </span><br><span class="line">&#125; catch (Exception e) &#123;  </span><br><span class="line">e.printStackTrace();  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>小知识</strong><br>1、文件大小换算公式：<br>1Byte=8bit<br>1KB=1024Byte(字节)=8*1024bit<br>1MB=1024KB<br>1GB=1024MB<br>1TB=1024GB<br>2、图像占用内存空间的大小：分辨率 * 位深 ／ 8<br>分辨率：宽 * 高<br>位深度：指定图像中的每个像素可以使用的颜色信息数量。<br>每个像素使用的信息位数越多，可用的颜色就越多，颜色表现就更逼真。<br>例如：<br>一幅图像分辨率：1024*768,24位，则其大小计算如下：<br>大小 = 1024 * 768 * 24 / 8 = 2359296 byte = 2304 KB</p></blockquote><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>实际使用过程中，首先是将图片的尺寸压缩到一定大小，然后降低图片的质量到特定的内存要求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Bitmap obtainBitmap() &#123;</span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.imag);</span><br><span class="line">Bitmap bg = Bitmap.createBitmap(bitmap.getWidth() / 2, bitmap.getHeight() / 2, Bitmap.Config.ARGB_8888);</span><br><span class="line">Canvas canvas = new Canvas(bg);</span><br><span class="line">Rect rect = new Rect(0, 0, bitmap.getWidth() / 2, bitmap.getHeight() / 2);</span><br><span class="line">canvas.drawBitmap(bitmap, null, rect, null);</span><br><span class="line">ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</span><br><span class="line">int quality = 100;</span><br><span class="line">//直到图片的大小小于100kb</span><br><span class="line">do &#123;</span><br><span class="line">outputStream.reset();</span><br><span class="line">bg.compress(Bitmap.CompressFormat.JPEG, quality, outputStream);</span><br><span class="line">quality = quality - 3;</span><br><span class="line">&#125; while (outputStream.toByteArray().length / 1024 &gt;= 100 &amp;&amp; quality &gt; 0);</span><br><span class="line">Bitmap result = BitmapFactory.decodeByteArray(outputStream.toByteArray(), 0, outputStream.size());</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考资料</strong><br><a href="https://www.jianshu.com/p/e9e1db845c21" target="_blank" rel="noopener">Android 图片压缩之多种压缩方式结合使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们通常采用多种方式结合的方法实现图片压缩需求，这些方式包括质量压缩、尺寸压缩。本章将分别介绍这两种方式，并且最后将结合这两种方式实现图片压缩的最优解决方案。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="Bitmap" scheme="http://yoursite.com/tags/Bitmap/"/>
    
  </entry>
  
  <entry>
    <title>Coordinatorlayout使用全攻略</title>
    <link href="http://yoursite.com/2018/01/20/Coordinatorlayout%E4%BD%BF%E7%94%A8%E5%85%A8%E6%94%BB%E7%95%A5/"/>
    <id>http://yoursite.com/2018/01/20/Coordinatorlayout使用全攻略/</id>
    <published>2018-01-20T15:21:56.000Z</published>
    <updated>2018-05-12T11:41:13.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-自定义Behavior"><a href="#1-自定义Behavior" class="headerlink" title="1.自定义Behavior"></a>1.自定义Behavior</h2><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>其实Behavior就是一个应用于View的观察者模式，一个View跟随者另一个View的变化而变化，或者说一个View监听另一个View。<br>在Behavior中，被观察View也就是事件源被称为denpendcy，而观察View，则被称为child。<a id="more"></a><br><strong>Button与TextView的爱恨情仇</strong><br>首先在布局文件中跟布局设置为CoordinatorLayout，里面放一个Button和一个TextView。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;</span><br><span class="line">xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">&gt;</span><br><span class="line">&lt;TextView     </span><br><span class="line">app:layout_behavior=&quot;.EasyBehavior&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:text=&quot;观察者View child&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;Button     </span><br><span class="line">android:id=&quot;@+id/btn&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:layout_gravity=&quot;center&quot;</span><br><span class="line">android:text=&quot;被观察View dependency&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;/android.support.design.widget.CoordinatorLayout&gt;</span><br></pre></td></tr></table></figure></p><p>这里我们在Activity中做一些手脚，让Button动起来(不要在意坐标这些细节)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_easy_behavior);</span><br><span class="line">findViewById(R.id.btn).setOnTouchListener(new View.OnTouchListener() &#123;</span><br><span class="line">@Override public boolean onTouch(View v, MotionEvent event) &#123;        switch (event.getAction())&#123;          case MotionEvent.ACTION_MOVE:</span><br><span class="line">v.setX(event.getRawX()-v.getWidth()/2);</span><br><span class="line">v.setY(event.getRawY()-v.getHeight()/2);            break;</span><br><span class="line">&#125;        return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时，Button已经可以跟随手指移动了。<br>现在去自定义一个Behavior让TextView跟随Button一起动！<br>创建一个EasyBehavior类，继承于Behavior<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class EasyBehavior extends CoordinatorLayout.Behavior&lt;TextView&gt; &#123;//这里的泛型是child的类型，也就是观察者View</span><br><span class="line">public EasyBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class="line">super(context, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override  public boolean layoutDependsOn(CoordinatorLayout parent, TextView child, View dependency) &#123;    //告知监听的dependency是Button</span><br><span class="line">return dependency instanceof Button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override  //当 dependency(Button)变化的时候，可以对child(TextView)进行操作</span><br><span class="line">public boolean onDependentViewChanged(CoordinatorLayout parent, TextView child, View dependency) &#123;</span><br><span class="line">child.setX(dependency.getX()+200);</span><br><span class="line">child.setY(dependency.getY()+200);</span><br><span class="line">child.setText(dependency.getX()+&quot;,&quot;+dependency.getY());    return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意两个方法<br>layoutDependsOn() 代表寻找被观察View<br>onDependentViewChanged() 被观察View变化的时候回调用的方法<br>在onDependentViewChanged中，我们让TextView跟随Button的移动而移动。代码比较简单，一看就懂。<br><strong>Tip</strong><br>必须重写带双参的构造器，因为从xml反射需要调用。<br>接下来，在xml中，给TextView设置我们的Behavior。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView      </span><br><span class="line">app:layout_behavior=&quot;.EasyBehavior&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:text=&quot;观察者View child&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><p>运行效果如下：<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/1.gif"></p><h2 id="2-CoordinatorLayout使用"><a href="#2-CoordinatorLayout使用" class="headerlink" title="2.CoordinatorLayout使用"></a>2.CoordinatorLayout使用</h2><p>CoordinatorLayout是谷歌提供的Material Design许多功能的基础，使用它你可以轻松地实现许多动画效果。这些效果包括：<br>1.滑动Floating Action Button为SnackBar的弹起提供空间。<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/2.gif"><br>2.展开或者收起Toolbar为屏幕的主内容提供空间。<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/3.gif"><br>3.控制某个应该被收起或展开的View以一定地视差效果完成动作，包括parallax scrolling effects 动画。<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/4.gif"></p><h4 id="Floating-Action-Buttons-和-Snackbars"><a href="#Floating-Action-Buttons-和-Snackbars" class="headerlink" title="Floating Action Buttons 和 Snackbars"></a>Floating Action Buttons 和 Snackbars</h4><p><code>FloatingActionButton</code>可以通过layout_anchor和layout_anchorGravity来控制显示的位置。当我们将其显示到屏幕的底端时，它会自动响应SnackBar的弹起或收起：SnackBar弹起后FloatingActionButton也弹起SnackBar的高度，收起后FloatingActionButton也收起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.CoordinatorLayout</span><br><span class="line">android:id=&quot;@+id/main_content&quot;</span><br><span class="line">xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.v7.widget.RecyclerView</span><br><span class="line">android:id=&quot;@+id/rvToDoList&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.design.widget.FloatingActionButton</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:layout_gravity=&quot;bottom|right&quot;</span><br><span class="line">android:layout_margin=&quot;16dp&quot;</span><br><span class="line">android:src=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">app:layout_anchor=&quot;@id/rvToDoList&quot;</span><br><span class="line">app:layout_anchorGravity=&quot;bottom|right|end&quot;/&gt;</span><br><span class="line">&lt;/android.support.design.widget.CoordinatorLayout&gt;</span><br></pre></td></tr></table></figure></p><h4 id="Expanding-和-Collapsing-Toolbars"><a href="#Expanding-和-Collapsing-Toolbars" class="headerlink" title="Expanding 和 Collapsing Toolbars"></a>Expanding 和 Collapsing Toolbars</h4><p>1.确保CoordinatorLayout是主容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">android:id=&quot;@+id/main_content&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;</span><br><span class="line">android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.v7.widget.Toolbar</span><br><span class="line">android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.CoordinatorLayout&gt;</span><br></pre></td></tr></table></figure></p><p>2.为了响应滑动事件，我们必须使用AppBarLayout:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.AppBarLayout</span><br><span class="line">android:id=&quot;@+id/appbar&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;@dimen/detail_backdrop_height&quot;</span><br><span class="line">android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span><br><span class="line">android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.v7.widget.Toolbar</span><br><span class="line">android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure></p><p>为了让滑动的View始终在AppBarLayout的下面，需要为滑动的View定义<code>layout_behavior</code>为@string/appbar_scrolling_view_behavior。我们还可以通过<code>app:layout_scrollFlags</code>控制AppBarLayout中的子View响应RecycleView的滑动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.AppBarLayout</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:fitsSystemWindows=&quot;true&quot;</span><br><span class="line">android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.v7.widget.Toolbar</span><br><span class="line">android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">app:layout_scrollFlags=&quot;scroll|enterAlways&quot;/&gt;</span><br><span class="line">&lt;android.support.v7.widget.RecyclerView</span><br><span class="line">android:id=&quot;@+id/rvToDoList&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;</span><br><span class="line">app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;/&gt;</span><br><span class="line">&lt;/android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure></p><p>关于layout_scrollFlags的值这里解释一下：</p><ol><li>scroll - 想滚动就必须设置这个。</li><li>enterAlways - 实现quick return效果, 当向下移动时，立即显示View（比如Toolbar)。</li><li>exitUntilCollapsed - 向上滚动时收缩View，但可以固定Toolbar一直在上面(可通过minHeight设置)。</li><li>enterAlwaysCollapsed - 当你的View已经设置minHeight属性又使用此标志时，你的View只能以最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。</li><li>snap - 如果头部滑动操作超过50%的距离，则自动关闭。如果头部滑动操作不超过50%的距离，则不关闭。</li></ol><h4 id="创建折叠效果"><a href="#创建折叠效果" class="headerlink" title="创建折叠效果"></a>创建折叠效果</h4><p>CollapsingToolbarLayout作用是提供了一个可以折叠的Toolbar，它继承至FrameLayout，给它设置layout_scrollFlags，它可以控制包含在CollapsingToolbarLayout中的控件(如：ImageView、Toolbar)在响应layout_behavior事件时作出相应的scrollFlags滚动事件(移除屏幕或固定在屏幕顶端)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.AppBarLayout  </span><br><span class="line">android:layout_width=&quot;match_parent&quot;  </span><br><span class="line">android:layout_height=&quot;256dp&quot;  </span><br><span class="line">android:fitsSystemWindows=&quot;true&quot;&gt;  </span><br><span class="line">&lt;android.support.design.widget.CollapsingToolbarLayout  </span><br><span class="line">android:id=&quot;@+id/collapsing_toolbar_layout&quot;  </span><br><span class="line">android:layout_width=&quot;match_parent&quot;  </span><br><span class="line">android:layout_height=&quot;match_parent&quot;  </span><br><span class="line">app:contentScrim=&quot;#30469b&quot;  </span><br><span class="line">app:expandedTitleMarginStart=&quot;48dp&quot;  </span><br><span class="line">app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;  </span><br><span class="line"></span><br><span class="line">&lt;ImageView  </span><br><span class="line">android:layout_width=&quot;match_parent&quot;  </span><br><span class="line">android:layout_height=&quot;match_parent&quot;  </span><br><span class="line">android:scaleType=&quot;centerCrop&quot;  </span><br><span class="line">android:src=&quot;@mipmap/bg&quot;  </span><br><span class="line">app:layout_collapseMode=&quot;parallax&quot;  </span><br><span class="line">app:layout_collapseParallaxMultiplier=&quot;0.7&quot;  /&gt;  </span><br><span class="line"></span><br><span class="line">&lt;android.support.v7.widget.Toolbar  </span><br><span class="line">android:id=&quot;@+id/toolbar&quot;  </span><br><span class="line">android:layout_width=&quot;match_parent&quot;  </span><br><span class="line">android:layout_height=&quot;?attr/actionBarSize&quot;  </span><br><span class="line">app:layout_collapseMode=&quot;pin&quot; /&gt;  </span><br><span class="line">&lt;/android.support.design.widget.CollapsingToolbarLayout&gt;  </span><br><span class="line">&lt;android.support.v7.widget.RecyclerView  </span><br><span class="line">android:id=&quot;@+id/recyclerView&quot;  </span><br><span class="line">android:layout_width=&quot;match_parent&quot;  </span><br><span class="line">android:layout_height=&quot;match_parent&quot;</span><br><span class="line">app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</span><br><span class="line">android:scrollbars=&quot;none&quot; /&gt;  </span><br><span class="line">&lt;/android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure></p><p>1、在CollapsingToolbarLayout中设置了一个ImageView和一个Toolbar。并把这个CollapsingToolbarLayout放到AppBarLayout中作为一个整体。<br>在CollapsingToolbarLayout中，我们除了设置layout_scrollFlags，还可以设置一些其它的属性，简要说明一下：</p><ul><li>contentScrim - 设置当完全CollapsingToolbarLayout折叠(收缩)后的背景颜色。</li><li>expandedTitleMarginStart - 设置扩张时候(还没有收缩时)title向左填充的距离。</li></ul><p>没扩张时候如图：<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/5.png"><br>2、在ImageView控件中：<br>我们设置了layout_collapseMode (折叠模式) - 有两个值:</p><ul><li>pin -  设置为这个模式时，当CollapsingToolbarLayout完全收缩后，Toolbar还可以保留在屏幕上。</li><li>parallax - 设置为这个模式时，在内容滚动时，CollapsingToolbarLayout中的View（比如ImageView)也可以同时滚动，实现视差滚动效果，通常和layout_collapseParallaxMultiplier(设置视差因子)搭配使用。</li><li>layout_collapseParallaxMultiplier(视差因子) - 设置视差滚动因子，值为：0~1。</li></ul><p>3、在Toolbar控件中，我们设置了layout_collapseMode(折叠模式)为pin。<br>效果如图:<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/6.gif"><br>综上分析：当设置了layout_behavior的控件响应起了CollapsingToolbarLayout中的layout_scrollFlags事件时，ImageView会有视差效果的向上滚动移除屏幕，当开始折叠时CollapsingToolbarLayout的背景色(也就是Toolbar的背景色)就会变为我们设置好的背景色，Toolbar也一直会固定在最顶端。</p><blockquote><p><strong>注意：</strong><br>使用CollapsingToolbarLayout时必须把title设置到CollapsingToolbarLayout上，设置到Toolbar上不会显示。即：mCollapsingToolbarLayout.setTitle(“ “);</p></blockquote><h4 id="Bottom-Sheet"><a href="#Bottom-Sheet" class="headerlink" title="Bottom Sheet"></a>Bottom Sheet</h4><p>有两种类型的<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0327/7729.html" target="_blank" rel="noopener">Bottom Sheet</a>：<br>1.<strong>Persistent bottom sheet :</strong>通常用于显示主界面之外的额外信息，它是主界面的一部分，只不过默认被隐藏了，其深度（elevation）跟主界面处于同一级别；还有一个重要特点是在Persistent bottom sheet打开的时候，主界面仍然是可以操作的。ps：Persistent bottom sheet该如何翻译呢？我觉得翻译为普通bottom sheet就好了，还看到有人翻译为“常驻bottom sheet”，可能更接近于英语的字面意思，可是反而不易理解。<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/7.png"><br>2.<strong>模态bottom sheet :</strong>顾名思义，模态的bottom sheet在打开的时候会阻止和主界面的交互，并且在视觉上会在bottom sheet背后加一层半透明的阴影，使得看上去深度（elevation）更深。<br>总结起来这两种Bottom Sheet的区别主要在于视觉和交互上，当然使用方法也是不一样的。<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/8.png"></p><hr><p><strong>参考资料</strong><br><a href="https://guides.codepath.com/android/Handling-Scrolls-with-CoordinatorLayout#troubleshooting-coordinated-layouts" target="_blank" rel="noopener">CoordinatorLayout介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-自定义Behavior&quot;&gt;&lt;a href=&quot;#1-自定义Behavior&quot; class=&quot;headerlink&quot; title=&quot;1.自定义Behavior&quot;&gt;&lt;/a&gt;1.自定义Behavior&lt;/h2&gt;&lt;h4 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h4&gt;&lt;p&gt;其实Behavior就是一个应用于View的观察者模式，一个View跟随者另一个View的变化而变化，或者说一个View监听另一个View。&lt;br&gt;在Behavior中，被观察View也就是事件源被称为denpendcy，而观察View，则被称为child。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="Coordinatorlayout" scheme="http://yoursite.com/tags/Coordinatorlayout/"/>
    
  </entry>
  
  <entry>
    <title>MD5加密算法</title>
    <link href="http://yoursite.com/2017/12/20/MD5%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/12/20/MD5加密算法/</id>
    <published>2017-12-20T09:19:02.000Z</published>
    <updated>2018-03-07T09:25:59.223Z</updated>
    
    <content type="html"><![CDATA[<p>MD5(Message-Digest Algorithm 5,信息-摘要算法5)用于确保信息传输完整一致，是计算机广泛使用的杂凑算法之一（又译摘要算法，哈希算法）。MD5算法将数据（如汉字）运算成另一固定长度值，MD5的前生有MD2，MD3和MD4。<a id="more"></a><br>MD5算法具有如下特征：<br>1、压缩性：任意长度的数据算出的MD5值是固定的，即128 位固定长度的散列值。<br>2、容易计算：从原数据很容易算出MD5值。<br>3、抗修改性：对原数据任何一个细微的改动，所得到的MD5值都会有很大的不同。<br>4、强抗碰撞：MD5 使用的是散列函数（也称哈希函数），一定概率上也存在哈希冲突（也称哈希碰撞），即多个不同的原数据对应一个相同的 MD5 值。不过，经过 MD4、MD3 等几代算法的优化，MD5 已经充分利用散列的分散性高度避免碰撞的发生。</p><p>可以看出，MD5 是一种不可逆的算法，也就说，你无法通过得到的 MD5 值逆向算出原数据内容。正是凭借这些特点，MD5 被广泛使用。</p><h1 id="MD5的使用场景"><a href="#MD5的使用场景" class="headerlink" title="MD5的使用场景"></a>MD5的使用场景</h1><h4 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h4><p>客户端与服务器的 HTTP 通信，通信双方可以将报文内容做一个 MD5 计算，并将计算所得 MD5 值一并传递给彼此，这样，接收方可以通过对报文内容再次做 MD5 计算得到一个 MD5 值，与传递报文中的 MD5 值做比较，验证数据是否完整，或者是否中途被拦截篡改过。</p><h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4><p>网络云盘中的文件秒传功能也运用到 MD5 算法。服务器存储文件的时候，同时记录每一个文件的 MD5 值，不同文件对应着不同的 MD5 值。这样，遇到用户上传文件时，将上传文件的 MD5 值与服务器上所有存储的 MD5 值做比较，如果相同，则说明用户上传的文件已经在服务器存有。这样，只需要在数据库表中添加一个记录，映射到对应的文件，而不用重复上传，实现所谓秒传的功能。</p><blockquote><p>注意：严格意义上来讲，MD5  并不属于加密算法，也不属于签名算法，而是一种摘要算法，用于数据完整性校验等。</p></blockquote><h1 id="Java-语言中计算-MD5-值的实现方式"><a href="#Java-语言中计算-MD5-值的实现方式" class="headerlink" title="Java 语言中计算 MD5 值的实现方式"></a>Java 语言中计算 MD5 值的实现方式</h1><p><strong>第一步</strong>，获取 MessageDigest 对象，参数为 MD5 字符串，表示这是一个 MD5 算法（其他还有 SHA1 算法等）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</span><br></pre></td></tr></table></figure></p><p><strong>第二步</strong>，输入原数据，参数类型为 byte[] ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5.update(buffer);</span><br></pre></td></tr></table></figure></p><p>注意：update() 方法有点类似 StringBuilder 对象的 append() 方法，采用的是追加模式，属于一个累计更改的过程，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">md5.update(new byte[]&#123;&apos;a&apos;, &apos;b&apos;&#125;);</span><br><span class="line">md5.update(new byte[]&#123;&apos;c&apos;, &apos;d&apos;&#125;);</span><br></pre></td></tr></table></figure></p><p>与<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5.update(new byte[]&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;, &apos;d&apos;&#125;);</span><br></pre></td></tr></table></figure></p><p>是等效的。<br><strong>第三步</strong>，计算 MD5 值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String resultArray = md5.digest();</span><br></pre></td></tr></table></figure></p><p>注意：digest() 方法被调用后，MessageDigest 对象就被重置，也就是说你不能紧接着再次调用该方法计算原数据的 MD5 值。当然，你可以手动调用 reset() 方法重置输入源。<br>digest() 方法返回值是一个字节数组类型的 16 位长度的哈希值，通常，我们会转化为十六进制的 32 位长度的字符串来使用，可以利用 <a href="https://www.jianshu.com/p/8b89ab19db84" target="_blank" rel="noopener">BigInteger</a> 类来做这个转化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bigInt = new BigInteger(1, resultArray);</span><br><span class="line">String resultStr = bigInt.toString(16);</span><br></pre></td></tr></table></figure></p><p>通过这层转换，得到的 MD5 值便是一个长度为 32 位的十六进制字符串，方便使用，类似这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15aa7ec97a6288e46ae865a7211eb4eb</span><br></pre></td></tr></table></figure></p><p>有了上面的基础我们再来看如何将一个文件通过MD5加密转化成32位的十六进制字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static String fileToMD5(String filePath) &#123;</span><br><span class="line">String md5 = null;</span><br><span class="line">MessageDigest digest = null;</span><br><span class="line">try &#123;</span><br><span class="line">digest = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">FileInputStream inputStream = new FileInputStream(filePath);</span><br><span class="line">byte[] b = new byte[1024];</span><br><span class="line">int len = -1;</span><br><span class="line">while ((len = inputStream.read(b)) != -1) &#123;</span><br><span class="line">digest.update(b, 0, len);</span><br><span class="line">&#125;</span><br><span class="line">byte[] bytes = digest.digest();</span><br><span class="line">BigInteger bigInteger = new BigInteger(1, bytes);</span><br><span class="line">md5 = bigInteger.toString(16);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return md5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：文件的大小直接影响字节流的读取速度，间接影响这里 MD5 的计算时长。Java 语言提供有多种方式读取文件，除了上面用到的 FileInputStream 这种顺序读取的 API 类，还有采用随机读取方式的 RandomAccessFile 类等。对于文件读取的效率问题，研究之后再作介绍。</p><hr><p><strong>参考资料</strong><br><a href="http://yifeng.studio/2017/06/13/md5-profile-and-implementation-in-java/" target="_blank" rel="noopener">MD5 简介，及其在 Java 中的实现方式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MD5(Message-Digest Algorithm 5,信息-摘要算法5)用于确保信息传输完整一致，是计算机广泛使用的杂凑算法之一（又译摘要算法，哈希算法）。MD5算法将数据（如汉字）运算成另一固定长度值，MD5的前生有MD2，MD3和MD4。
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="MD5" scheme="http://yoursite.com/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>Git使用规则补充</title>
    <link href="http://yoursite.com/2017/12/16/Git%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2017/12/16/Git使用规则补充/</id>
    <published>2017-12-16T01:57:26.000Z</published>
    <updated>2018-05-12T11:45:22.305Z</updated>
    
    <content type="html"><![CDATA[<p>学习的git的同学想必看过了<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰老师的Git教程</a>，笔者在学习过程中也深受这篇文章的启发。但是在学习或使用过程中，笔者也遇到了一些比较实际的但是廖老师没有提到或者只是一笔带过的问题。这篇文章就把这些问题的解决办法记录一下吧～<a id="more"></a><br><strong>1.如何方便的使用一台机器向不同的远端仓库（如：github）提交代码?</strong><br>我们知道在往github的某一个仓库提交代码时，需要在本地生成一个SSH Key，然后将其添加到github中，如下。<br><img src="/2017/12/16/Git使用规则补充/Jietu20180512-194316.jpg"><br>但是现在需要为github中的另外一个库添加SSH key，理所当然地，我们要再次在本地生成一个SSH key，命令如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@yourcompany.com&quot;</span><br></pre></td></tr></table></figure></p><p>若一路回车（密码可以不写），这样会覆盖~/.ssh/ 目录下生成 id_rsa 和 id_rsa.pub 两个文件。为了区分，我们在第一个回车后设置路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa):~/.ssh/文件名</span><br></pre></td></tr></table></figure></p><p>由此我们分别为github中的两个库（A库和B库）生成对应的公钥和私钥，完成后的目录：<br>id_rsa<br>id_rsa.pub<br>id_sub<br>id_sub.pub<br>之后我们将新生成的SSH key设置给B库，此时，理所当然地我们开始往B库中提交代码，但是事实没有那么美好，<strong>提示：没有权限。</strong>如何解决呢？<br>1、 首先查看代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -l</span><br></pre></td></tr></table></figure></p><p>若提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></table></figure></p><p>则系统代理里没有任何key，执行如下操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec ssh-agent bash</span><br></pre></td></tr></table></figure></p><p>若系统已经有ssh-key 代理 ,可以删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -D</span><br></pre></td></tr></table></figure></p><p>2.添加私钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa  </span><br><span class="line">ssh-add ~/.ssh/id_sub</span><br></pre></td></tr></table></figure></p><p>3.添加公钥<br>在github对应的管理页面，添加对应的公钥（.pub 文件内容），保存到代码管理服务器。<br>4.添加和编辑配置文件config<br>在 ~/.ssh 目录下新建一个config文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ~/.ssh/config</span><br></pre></td></tr></table></figure></p><p>添加内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># github  </span><br><span class="line">Host github.com  </span><br><span class="line">HostName github.com  </span><br><span class="line">PreferredAuthentications publickey  </span><br><span class="line"># IdentityFile ~/.ssh/id_sub</span><br><span class="line">IdentityFile ~/.ssh/id_rsa  </span><br><span class="line">user git</span><br></pre></td></tr></table></figure></p><p>注意到第五、六行,如果我们需要往对应的远端版本库中提交代码，那么定义相应的IdentityFile行即可。但是，同一个时间只能配置一个IdentityFile，切换的时候只需更换IdentityFile即可。<br><strong>2.如何修改commit的备注？</strong><br>试想你在调用<code>git commit -m &quot;备注&quot;</code>后，如果突然反悔了，想重新修改commit的备注语，可以调用<code>git commit —amend</code>,之后可以在vi编辑器中重新编辑我们的备注了。<br><strong>3.Git忽略规则及.gitignore规则不生效的解决办法</strong><br>在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"></span><br><span class="line">*.a       # 忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a    # 但 lib.a 除外</span><br><span class="line">/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">build/    # 忽略 build/ 目录下的所有文件</span><br><span class="line">doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure></p><p>规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;update .gitignore&apos;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习的git的同学想必看过了&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;廖雪峰老师的Git教程&lt;/a&gt;，笔者在学习过程中也深受这篇文章的启发。但是在学习或使用过程中，笔者也遇到了一些比较实际的但是廖老师没有提到或者只是一笔带过的问题。这篇文章就把这些问题的解决办法记录一下吧～
    
    </summary>
    
      <category term="Git使用" scheme="http://yoursite.com/categories/Git%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Android获取系统图片的研究</title>
    <link href="http://yoursite.com/2017/11/13/Android%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%9B%BE%E7%89%87%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2017/11/13/Android获取系统图片的研究/</id>
    <published>2017-11-13T11:42:08.000Z</published>
    <updated>2018-03-01T09:01:26.490Z</updated>
    
    <content type="html"><![CDATA[<p>在Android开发过程中，我们经常会遇到从相册中获取图片、拍照获取图片、相册多选的需求，那么今天就从这三点出发来研究一下Android获取系统的图片的方法吧～<a id="more"></a></p><h1 id="1-相册获取图片（单张）"><a href="#1-相册获取图片（单张）" class="headerlink" title="1.相册获取图片（单张）"></a>1.相册获取图片（单张）</h1><p>从相册获取单张图片的方式主要有两个，一种是直接获取，另外一种是在进入内容（图片）选择界面之前弹出一个类别选择窗。</p><h4 id="直接获取"><a href="#直接获取" class="headerlink" title="直接获取"></a>直接获取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void getImageFromAlbum() &#123;  </span><br><span class="line">Intent intent = new Intent(Intent.ACTION_PICK);  </span><br><span class="line">intent.setType(&quot;image/*&quot;);//相片类型  </span><br><span class="line">startActivityForResult(intent, REQUEST_CODE_PICK_IMAGE);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进行内容类别选择之后，才进入具体的内容界面"><a href="#进行内容类别选择之后，才进入具体的内容界面" class="headerlink" title="进行内容类别选择之后，才进入具体的内容界面"></a>进行内容类别选择之后，才进入具体的内容界面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void getContent() &#123;</span><br><span class="line">Intent intent = new Intent();</span><br><span class="line">intent.setType(&quot;image/*&quot;);</span><br><span class="line">intent.setAction(Intent.ACTION_GET_CONTENT);</span><br><span class="line">startActivityForResult(Intent.createChooser(intent, &quot;Select Picture&quot;), 1);//定义弹窗的标题。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-从照相机获取照片"><a href="#2-从照相机获取照片" class="headerlink" title="2.从照相机获取照片"></a>2.从照相机获取照片</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void getImageFromCamera() &#123;  </span><br><span class="line">String state = Environment.getExternalStorageState();  </span><br><span class="line">if (state.equals(Environment.MEDIA_MOUNTED)) &#123;  </span><br><span class="line">Intent intent = new Intent();</span><br><span class="line">intent.setAction(&quot;android.media.action.IMAGE_CAPTURE&quot;);</span><br><span class="line">startActivityForResult(intent, 2); </span><br><span class="line">&#125;  </span><br><span class="line">else &#123;  </span><br><span class="line">Toast.makeText(getApplicationContext(), &quot;请确认已经插入SD卡&quot;, Toast.LENGTH_LONG).show();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当图片的信息返回后，我们要在<code>onActivityResult</code>方法中获取返回的图片信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;  </span><br><span class="line">if (requestCode == 1) &#123;             </span><br><span class="line">Uri uri = data.getData();  </span><br><span class="line">//to do find the path of pic  </span><br><span class="line"></span><br><span class="line">&#125; else if (requestCode == 2 ) &#123;             </span><br><span class="line">Uri uri = data.getData();  </span><br><span class="line">//to do find the path of pic  </span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure></p><p>不同的机器获得相片的方式不太一样，可能有的相机能够通过  inten.getData()获取到uri然后再根据uri获取数据的路径，在封装成bitmap，但有时候有的相机获取到的是null的，这时候我们该怎么办呢？<br>其实这时候我们就应该从bundle中获取数据，通过(Bitmap) bundle.get(“data”)直接获取到相机图片的bitmap数据。为了能够同时适应上述两种情况，我们这时候就应该在获取图片时做判断了。我们可以在响应的时候做一个判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;  </span><br><span class="line">if (requestCode == 1) &#123;             </span><br><span class="line">Uri uri = data.getData();  </span><br><span class="line">//to do find the path of pic by uri  </span><br><span class="line"></span><br><span class="line">&#125; else if (requestCode == 2 ) &#123;             </span><br><span class="line">Uri uri = data.getData();  </span><br><span class="line">if(uri == null)&#123;  </span><br><span class="line">//use bundle to get data  </span><br><span class="line">Bundle bundle = data.getExtras();    </span><br><span class="line">if (bundle != null) &#123;                 </span><br><span class="line">Bitmap  photo = (Bitmap) bundle.get(&quot;data&quot;);                //get bitmap  </span><br><span class="line">//spath :生成图片取个名字和路径包含类型        </span><br><span class="line">saveImage(Bitmap photo, String spath);  </span><br><span class="line">&#125; else &#123;           </span><br><span class="line">Toast.makeText(getApplicationContext(), &quot;err****&quot;, Toast.LENGTH_LONG).show();           </span><br><span class="line">return;        </span><br><span class="line">&#125;    </span><br><span class="line">&#125;else&#123;  </span><br><span class="line">//to do find the path of pic by uri  </span><br><span class="line">&#125;   </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后面的过程就需要通过bitmap转化成相应的图片文件了。不过得到<strong>最终的图片是被压缩了的</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void saveImage(Bitmap photo, String spath) &#123;  </span><br><span class="line">try &#123;  </span><br><span class="line">BufferedOutputStream bos = new BufferedOutputStream(  </span><br><span class="line">new FileOutputStream(spath, false));  </span><br><span class="line">photo.compress(Bitmap.CompressFormat.JPEG, 100, bos);  </span><br><span class="line">bos.flush();  </span><br><span class="line">bos.close();  </span><br><span class="line">&#125; catch (Exception e) &#123;  </span><br><span class="line">e.printStackTrace();  </span><br><span class="line">return false;  </span><br><span class="line">&#125;  </span><br><span class="line">return true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-实现相册多选功能"><a href="#3-实现相册多选功能" class="headerlink" title="3.实现相册多选功能"></a>3.实现相册多选功能</h1><p>Android自身没有实现相册多选功能，如果想要实现的话，还是有办法的。通过<code>getContentResolver().query()</code>遍历整个相册即可获取所有的本地图片，然后利用GridView或者其它的方式将这些图片展示即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver contentResolver = getContentResolver();</span><br><span class="line">Cursor cursor = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, null, null, null, null);</span><br><span class="line">if (cursor.moveToFirst()) &#123;</span><br><span class="line">do &#123;</span><br><span class="line">String uriStr = cursor.getString(cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA));</span><br><span class="line">//这里可以先将uriStr保存到内存，之后再加载到Adapter中。</span><br><span class="line">Log.d(&quot;TAG&quot;, &quot;query: &quot; + column);</span><br><span class="line">&#125; while (cursor.moveToNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4.最佳实践"></a>4.最佳实践</h1><h4 id="获取权限"><a href="#获取权限" class="headerlink" title="获取权限"></a>获取权限</h4><p>不要忘记了，Android在读取外部存储空间时需要获取<code>android.permission.READ_EXTERNAL_STORAGE</code>权限。但是6.0以上的Android系统有了动态获取权限的概念，具体请查看<a href="https://developer.android.com/training/permissions/requesting.html?hl=zh-cn" target="_blank" rel="noopener">官方文档</a>。<br>上面提到读取外部存储空间时需要读取权限，其实所有需要访问外部存储空间的操作都是需要访问权限的。但是对于内部存储空间的访问则不需要权限的申请。关于内部存储空间与外部存储空间的区别，具体请查看<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0923/1557.html" target="_blank" rel="noopener">这篇文章</a>。</p><hr><p><strong>参考资料</strong><br><a href="http://www.cnblogs.com/kobe8/p/4031226.html" target="_blank" rel="noopener">Android开发之获取相册照片和获取拍照照片</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android开发过程中，我们经常会遇到从相册中获取图片、拍照获取图片、相册多选的需求，那么今天就从这三点出发来研究一下Android获取系统的图片的方法吧～
    
    </summary>
    
      <category term="Android多媒体操作" scheme="http://yoursite.com/categories/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="获取拍照或相册图片" scheme="http://yoursite.com/tags/%E8%8E%B7%E5%8F%96%E6%8B%8D%E7%85%A7%E6%88%96%E7%9B%B8%E5%86%8C%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>Android自定义View详细教程</title>
    <link href="http://yoursite.com/2017/10/09/Android%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/10/09/Android自定义View详细教程/</id>
    <published>2017-10-09T08:22:18.000Z</published>
    <updated>2018-05-12T12:08:02.082Z</updated>
    
    <content type="html"><![CDATA[<p>自定义View一直都是Android开发的一个重要模块，在实际开发过程中我们也无法避免地会用到它。那么今天就来详细的梳理一下这一块的知识点吧。<a id="more"></a></p><h1 id="1-自定义View"><a href="#1-自定义View" class="headerlink" title="1.自定义View"></a>1.自定义View</h1><p>首先我们要明白，为什么要自定义View？主要是Android系统内置的View无法实现我们的需求，我们需要针对我们的业务需求定制我们想要的View。自定义View我们大部分时候只需重写两个函数：onMeasure()、onDraw()。onMeasure负责对当前View的尺寸进行测量，onDraw负责把当前这个View绘制出来。</p><h4 id="从构造方法讲起"><a href="#从构造方法讲起" class="headerlink" title="从构造方法讲起"></a>从构造方法讲起</h4><p>View有四种形式的构造方法，其中四个参数的构造方法是API 21才出现，所以一般我们只需要重写其他三个构造方法即可。它们的参数不一样分别对应不同的创建方式，比如只有一个Context参数的构造方法通常是通过代码初始化控件时使用；而两个参数的构造方法通常对应布局文件中控件被映射成对象时调用（需要解析属性）；通常我们让这两个构造方法最终调用三个参数的构造方法，然后在第三个构造方法中进行一些初始化操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public MyTextView(Context context) &#123;</span><br><span class="line">this(context, null);</span><br><span class="line">&#125;</span><br><span class="line">public MyTextView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">this(context, attrs, 0);</span><br><span class="line">&#125;</span><br><span class="line">public MyTextView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">super(context, attrs, defStyleAttr);</span><br><span class="line">//初始化操作</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h4><p>在学习Android的时候，我们就知道，在xml布局文件中，我们的layout_width和layout_height参数可以不用写具体的尺寸，而是wrap_content或者是match_parent。其意思我们都知道，就是将尺寸设置为“包住内容”和“填充父布局给我们的所有空间”。这两个设置并没有指定真正的大小，可是我们绘制到屏幕上的View必须是要有具体的宽高的，正是因为这个原因，我们必须自己去处理和设置尺寸。当然了，View类给了默认的处理，但是如果View类的默认处理不满足我们的要求，我们就得重写onMeasure函数啦。这里举个例子，比如我们希望我们的View是个正方形，如果在xml中指定宽高为<code>wrap_content</code>，如果使用View类提供的measure处理方式，显然无法满足我们的需求。<br>先看看onMeasure函数原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)</span><br></pre></td></tr></table></figure></p><p>参数中的widthMeasureSpec和heightMeasureSpec是个什么鬼？看起来很像width和height，没错，这两个参数就是包含宽和高的信息。什么？包含？难道还要其他信息？是的！它还包含测量模式，也就是说，一个int整数，里面放了测量模式和尺寸大小。那么一个数怎么放两个信息呢？我们知道，我们在设置宽高时有3个选择：wrap_content、match_parent以及指定固定尺寸，而测量模式也有3种：UNSPECIFIED，EXACTLY，AT_MOST，当然，他们并不是一一对应关系哈，这三种模式后面我会详细介绍，但测量模式无非就是这3种情况，而如果使用二进制，我们只需要使用2个bit就可以做到，因为2个bit取值范围是[0,3]里面可以存放4个数足够我们用了。那么Google是怎么把一个int同时放测量模式和尺寸信息呢？我们知道int型数据占用32个bit，而google实现的是，将int数据的前面2个bit用于区分不同的布局模式，后面30个bit存放的是尺寸的数据。<br>那我们怎么从int数据中提取测量模式和尺寸呢？放心，不用你每次都要写一次移位&lt;&lt;和取且&amp;操作，Android内置类MeasureSpec帮我们写好啦~，我们只需按照下面方法就可以拿到啦：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">int widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br></pre></td></tr></table></figure></p><p>爱思考的你肯定会问，既然我们能通过widthMeasureSpec拿到宽度尺寸大小，那我们还要测量模式干嘛？测量模式会不会是多余的？请注意：这里的的尺寸大小并不是最终我们的View的尺寸大小，而是父View提供的参考大小。我们看看测量模式，测量模式是干啥用的呢？</p><table><thead><tr><th>测量模式</th><th style="text-align:left">表示意思</th></tr></thead><tbody><tr><td>UNSPECIFIED</td><td style="text-align:left">父容器没有对当前View有任何限制，当前View可以任意取尺寸</td></tr><tr><td>EXACTLY</td><td style="text-align:left">当前的尺寸就是当前View应该取的尺寸</td></tr><tr><td>AT_MOST</td><td style="text-align:left">当前尺寸是当前View能取的最大尺寸</td></tr></tbody></table><p>而上面的测量模式跟我们的布局时的wrap_content、match_parent以及写成固定的尺寸有什么对应关系呢？<br>1、match_parent—&gt;EXACTLY。怎么理解呢？match_parent就是要利用父View给我们提供的所有剩余空间，而父View剩余空间是确定的，也就是这个测量模式的整数里面存放的尺寸。<br>2、wrap_content—&gt;AT_MOST。怎么理解：就是我们想要将大小设置为包裹我们的view内容，那么尺寸大小就是父View给我们作为参考的尺寸，只要不超过这个尺寸就可以啦，具体尺寸就根据我们的需求去设定。<br>3、固定尺寸（如100dp）—&gt;EXACTLY。用户自己指定了尺寸大小，我们就不用再去干涉了，当然是以指定的大小为主啦。</p><h4 id="动手重写onMeasure函数"><a href="#动手重写onMeasure函数" class="headerlink" title="动手重写onMeasure函数"></a>动手重写onMeasure函数</h4><p>上面讲了太多理论，我们实际操作一下吧，感受一下onMeasure的使用，假设我们要实现这样一个效果：将当前的View以正方形的形式显示，即要宽高相等，并且默认的宽高值为100像素。就可以这些编写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private int getMySize(int defaultSize, int measureSpec) &#123;</span><br><span class="line">int mySize = defaultSize;</span><br><span class="line"></span><br><span class="line">int mode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">int size = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">switch (mode) &#123;</span><br><span class="line">case MeasureSpec.UNSPECIFIED: &#123;//如果没有指定大小，就设置为默认大小</span><br><span class="line">mySize = defaultSize;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case MeasureSpec.AT_MOST: &#123;//如果测量模式是最大取值为size</span><br><span class="line">//我们将大小取最大值,你也可以取其他值</span><br><span class="line">mySize = size;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case MeasureSpec.EXACTLY: &#123;//如果是固定的大小，那就不要去改变它</span><br><span class="line">mySize = size;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return mySize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">int width = getMySize(100, widthMeasureSpec);</span><br><span class="line">int height = getMySize(100, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">if (width &lt; height) &#123;</span><br><span class="line">height = width;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">width = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setMeasuredDimension(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们设置一下布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.hc.studyview.MyView</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;100dp&quot;</span><br><span class="line">android:background=&quot;#ff0000&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>看看使用了我们自己定义的onMeasure函数后的效果：<br><img src="/2017/10/09/Android自定义View详细教程/1.jpg"><br>而如果我们不重写onMeasure，效果则是如下：<br><img src="/2017/10/09/Android自定义View详细教程/2.jpg"></p><blockquote><p><strong>注意：</strong><br>实际使用过程中可能会遇到当<code>MyView</code>的父View是<code>RelativeLayout</code>时，无法通过重写onMeasure定义方形View的情况，解决方案<a href="https://stackoverflow.com/questions/17228741/why-is-my-android-custom-view-not-square/17465228#17465228" target="_blank" rel="noopener">请看这里</a>。</p></blockquote><h4 id="重写onDraw"><a href="#重写onDraw" class="headerlink" title="重写onDraw"></a>重写onDraw</h4><p>上面我们学会了自定义尺寸大小，那么尺寸我们会设定了，接下来就是把我们想要的效果画出来吧~绘制我们想要的效果很简单，直接在画板Canvas对象上绘制就好啦，为了简单，我们以一个简单的例子去学习：在我们的View上显示一个圆形。我们在上面已经实现了宽高尺寸相等的基础上，继续往下做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">int r = getMeasuredWidth() / 2;//也可以是getMeasuredHeight()/2,本例中我们已经将宽高设置相等了</span><br><span class="line">//圆心的横坐标为当前的View的半径值（注意是将当前View坐上角的第一个点视为原点。）</span><br><span class="line">int centerX = r;</span><br><span class="line">//圆心的纵坐标为当前的View的半径值</span><br><span class="line">int centerY =r;</span><br><span class="line"></span><br><span class="line">Paint paint = new Paint();</span><br><span class="line">paint.setColor(Color.GREEN);</span><br><span class="line">//开始绘制</span><br><span class="line">canvas.drawCircle(centerX, centerY, r, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2017/10/09/Android自定义View详细教程/3.jpg"><blockquote><p><strong>注意：</strong><br>因为onDraw()可能会被调用多次（任何invalidate()的调用都会触发onDraw方法），所以要特别注意onDraw中变量值的管理。</p></blockquote><h4 id="自定义布局属性"><a href="#自定义布局属性" class="headerlink" title="自定义布局属性"></a>自定义布局属性</h4><p>如果有些属性我们希望由用户指定，只有当用户不指定的时候才用我们硬编码的值，比如上面的默认尺寸，我们想要由用户自己在布局文件里面指定该怎么做呢？那当然是通过自定义属性，让用户用我们定义的属性啦~<br>首先我们需要在res/values/styles.xml文件（如果没有请自己新建）里面声明一个我们自定义的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;!--name为声明的&quot;属性集合&quot;名，可以随便取，但是最好是设置为跟我们的View一样的名称--&gt;</span><br><span class="line">&lt;declare-styleable name=&quot;MyView&quot;&gt;</span><br><span class="line">&lt;!--声明我们的属性，名称为default_size,取值类型为尺寸类型（dp,px等）--&gt;</span><br><span class="line">&lt;attr name=&quot;default_size&quot; format=&quot;dimension&quot; /&gt;</span><br><span class="line">&lt;/declare-styleable&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>接下来就是在布局文件用上我们的自定义的属性啦~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">xmlns:hc=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;com.hc.studyview.MyView</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;100dp&quot;</span><br><span class="line">hc:default_size=&quot;100dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>注意：如果是我们的自定义属性，就需要在根标签（LinearLayout）里面设定命名空间。命名空间的一种写法是xmlns:hc=”<a href="http://schemas.android.com/apk/res-auto&quot;，res-auto表示自动查找，还有一种写法是xmlns:hc=&quot;http://schemas.android.com/apk/com.hc.studyview.MyView&quot;，`com.hc.studyview.MyView`为我们的应用程序包名。而命名空间的名称可以随意取，如上就是`hc`。" target="_blank" rel="noopener">http://schemas.android.com/apk/res-auto&quot;，res-auto表示自动查找，还有一种写法是xmlns:hc=&quot;http://schemas.android.com/apk/com.hc.studyview.MyView&quot;，`com.hc.studyview.MyView`为我们的应用程序包名。而命名空间的名称可以随意取，如上就是`hc`。</a><br>最后就是在我们的自定义的View里面把我们自定义的属性的值取出来，在构造函数中，还记得有个AttributeSet属性吗？就是靠它帮我们把布局里面的属性取出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private int defalutSize;</span><br><span class="line">public MyView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">super(context, attrs);</span><br><span class="line">//第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签</span><br><span class="line">//即属性集合的标签，在R文件中名称为R.styleable+name</span><br><span class="line">TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyView);</span><br><span class="line">//第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称</span><br><span class="line">//第二个参数为默认值</span><br><span class="line">defalutSize = a.getDimensionPixelSize(R.styleable.MyView_default_size, 100);</span><br><span class="line"></span><br><span class="line">//最后记得将TypedArray对象回收</span><br><span class="line">a.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，把MyView的完整代码附上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">package com.hc.studyview;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.res.TypedArray;</span><br><span class="line">import android.graphics.Canvas;</span><br><span class="line">import android.graphics.Color;</span><br><span class="line">import android.graphics.Paint;</span><br><span class="line">import android.util.AttributeSet;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.MotionEvent;</span><br><span class="line">import android.view.View;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Package com.hc.studyview</span><br><span class="line">* Created by HuaChao on 2016/6/3.</span><br><span class="line">*/</span><br><span class="line">public class MyView extends View &#123;</span><br><span class="line"></span><br><span class="line">private int defalutSize;</span><br><span class="line"></span><br><span class="line">public MyView(Context context) &#123;</span><br><span class="line">super(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public MyView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">super(context, attrs);</span><br><span class="line">//第二个参数就是我们在styles.xml文件中的&lt;declare-styleable&gt;标签</span><br><span class="line">//即属性集合的标签，在R文件中名称为R.styleable+name</span><br><span class="line">TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyView);</span><br><span class="line">//第一个参数为属性集合里面的属性，R文件名称：R.styleable+属性集合名称+下划线+属性名称</span><br><span class="line">//第二个参数为，如果没有设置这个属性，则设置的默认的值</span><br><span class="line">defalutSize = a.getDimensionPixelSize(R.styleable.MyView_default_size, 100);</span><br><span class="line">//最后记得将TypedArray对象回收</span><br><span class="line">a.recycle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private int getMySize(int defaultSize, int measureSpec) &#123;</span><br><span class="line">int mySize = defaultSize;</span><br><span class="line"></span><br><span class="line">int mode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">int size = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">switch (mode) &#123;</span><br><span class="line">case MeasureSpec.UNSPECIFIED: &#123;//如果没有指定大小，就设置为默认大小</span><br><span class="line">mySize = defaultSize;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case MeasureSpec.AT_MOST: &#123;//如果测量模式是最大取值为size</span><br><span class="line">//我们将大小取最大值,你也可以取其他值</span><br><span class="line">mySize = size;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case MeasureSpec.EXACTLY: &#123;//如果是固定的大小，那就不要去改变它</span><br><span class="line">mySize = size;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return mySize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">int width = getMySize(defalutSize, widthMeasureSpec);</span><br><span class="line">int height = getMySize(defalutSize, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">if (width &lt; height) &#123;</span><br><span class="line">height = width;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">width = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setMeasuredDimension(width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">int r = getMeasuredWidth() / 2;//也可以是getMeasuredHeight()/2,本例中我们已经将宽高设置相等了</span><br><span class="line">int centerX = r;</span><br><span class="line">int centerY = r;</span><br><span class="line">Paint paint = new Paint();</span><br><span class="line">paint.setColor(Color.GREEN);</span><br><span class="line">//开始绘制</span><br><span class="line">canvas.drawCircle(centerX, centerY, r, paint);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-自定义ViewGroup"><a href="#2-自定义ViewGroup" class="headerlink" title="2.自定义ViewGroup"></a>2.自定义ViewGroup</h1><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><p>自定义View的过程很简单，就那几步，可自定义ViewGroup可就没那么简单啦~，因为它不仅要管好自己的，还要兼顾它的子View。我们都知道ViewGroup是个View容器，它装纳child View并且负责把child View放入指定的位置。我们假象一下，如果是让你负责设计ViewGroup，你会怎么去设计呢？<br>1、首先，我们得知道各个子View的大小吧，只有先知道子View的大小，我们才知道当前的ViewGroup该设置为多大去容纳它们。<br>2、根据子View的大小，以及我们的ViewGroup要实现的功能，决定出ViewGroup的大小。<br>3、ViewGroup和子View的大小算出来了之后，接下来就是去摆放了吧，具体怎么去摆放呢？这得根据你定制的需求去摆放了，比如，你想让子View按照垂直顺序一个挨着一个放，或者是按照先后顺序一个叠一个去放，这是你自己决定的。<br>4、已经知道怎么去摆放还不行啊，决定了怎么摆放就是相当于把已有的空间”分割”成大大小小的空间，每个空间对应一个子View，我们接下来就是把子View对号入座了，把它们放进它们该放的地方去。<br>现在就完成了ViewGroup的设计了，我们来个具体的案例：将子View按从上到下垂直顺序一个挨着一个摆放，即模仿实现LinearLayout的垂直布局。<br>首先重写onMeasure，实现测量子View大小以及设定ViewGroup的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">//将所有的子View进行测量，这会触发每个子View的onMeasure函数</span><br><span class="line">//注意要与measureChild区分，measureChild是对单个view进行测量</span><br><span class="line">measureChildren(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">int widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">int heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">int childCount = getChildCount();</span><br><span class="line"></span><br><span class="line">if (childCount == 0) &#123;//如果没有子View,当前ViewGroup没有存在的意义，不用占用空间</span><br><span class="line">setMeasuredDimension(0, 0);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//如果宽高都是包裹内容</span><br><span class="line">if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">//我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度</span><br><span class="line">int height = getTotleHeight();</span><br><span class="line">int width = getMaxChildWidth();</span><br><span class="line">setMeasuredDimension(width, height);</span><br><span class="line">&#125; else if (heightMode == MeasureSpec.AT_MOST) &#123;//如果只有高度是包裹内容</span><br><span class="line">//宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和</span><br><span class="line">setMeasuredDimension(widthSize, getTotleHeight());</span><br><span class="line">&#125; else if (widthMode == MeasureSpec.AT_MOST) &#123;//如果只有宽度是包裹内容</span><br><span class="line">//宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值</span><br><span class="line">setMeasuredDimension(getMaxChildWidth(), heightSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/***</span><br><span class="line">* 获取子View中宽度最大的值</span><br><span class="line">*/</span><br><span class="line">private int getMaxChildWidth() &#123;</span><br><span class="line">int childCount = getChildCount();</span><br><span class="line">int maxWidth = 0;</span><br><span class="line">for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">View childView = getChildAt(i);</span><br><span class="line">if (childView.getMeasuredWidth() &gt; maxWidth)</span><br><span class="line">maxWidth = childView.getMeasuredWidth();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return maxWidth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/***</span><br><span class="line">* 将所有子View的高度相加</span><br><span class="line">**/</span><br><span class="line">private int getTotleHeight() &#123;</span><br><span class="line">int childCount = getChildCount();</span><br><span class="line">int height = 0;</span><br><span class="line">for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">View childView = getChildAt(i);</span><br><span class="line">height += childView.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码中的注释我已经写得很详细，不再对每一行代码进行讲解。上面的onMeasure将子View测量好了，以及把自己的尺寸也设置好了，接下来我们去摆放子View吧~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">int count = getChildCount();</span><br><span class="line">//记录当前的高度位置</span><br><span class="line">int curHeight = t;</span><br><span class="line">//将子View逐个摆放</span><br><span class="line">for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">View child = getChildAt(i);</span><br><span class="line">int height = child.getMeasuredHeight();</span><br><span class="line">int width = child.getMeasuredWidth();</span><br><span class="line">//摆放子View，参数分别是子View矩形区域的左、上、右、下边</span><br><span class="line">child.layout(l, curHeight, l + width, curHeight + height);</span><br><span class="line">curHeight += height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们测试一下，将我们自定义的ViewGroup里面放3个Button ,将这3个Button的宽度设置不一样，把我们的ViewGroup的宽高都设置为包裹内容wrap_content，为了看的效果明显，我们给ViewGroup加个背景：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;com.hc.studyview.MyViewGroup</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:background=&quot;#ff9900&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:layout_width=&quot;100dp&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:text=&quot;btn&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:layout_width=&quot;200dp&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:text=&quot;btn&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:layout_width=&quot;50dp&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:text=&quot;btn&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/com.hc.studyview.MyViewGroup&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>看看最后的效果吧~<br><img src="/2017/10/09/Android自定义View详细教程/4.jpg"><br>是不是很激动我们自己也可以实现LinearLayout的效果啦~~~</p><blockquote><p><strong>注意：</strong><br>getMeasureWidth()/getMeasureHeight()需要在调用setMeasuredDimension()之后使用；getWidth()/getHeight()需要在调用layout()函数之后使用。一般情况，我们使用getMeasureWidth()/getMeasureHeight()获取宽高即可。</p></blockquote><h4 id="自定义LayoutParams"><a href="#自定义LayoutParams" class="headerlink" title="自定义LayoutParams"></a>自定义LayoutParams</h4><p>ViewGroup中有两个内部类ViewGroup.LayoutParams和ViewGroup.MarginLayoutParams，MarginLayoutParams继承自LayoutParams，这两个内部类就是ViewGroup的布局参数类，比如我们在LinearLayout等布局中使用的layout_width\layout<em>height等以“layout</em> ”开头的属性都是布局属性。</p><blockquote><p><strong>为什么LayoutParams 类要定义在ViewGroup中？</strong><br>大家都知道ViewGroup是所有容器的基类，一个控件需要被包裹在一个容器中，这个容器必须提供一种规则控制子控件的摆放，比如你的宽高是多少，距离那个位置多远等。所以ViewGroup有义务提供一个布局属性类，用于控制子控件的布局属性。</p></blockquote><p>在View中有一个mLayoutParams的变量用来保存这个View的所有布局属性。ViewGroup.LayoutParams有两个属性layout_width和layout_height，因为所有的容器都需要设置子控件的宽高，所以这个LayoutParams是所有布局参数的基类，如果需要扩展其他属性，都应该继承自它。比如RelativeLayout中就提供了它自己的布局参数类RelativeLayout.LayoutParams，并扩展了很多布局参数，我们平时在RelativeLayout中使用的布局属性都来自它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;declare-styleable name= &quot;RelativeLayout_Layout&quot;&gt;</span><br><span class="line">&lt;attr name =&quot;layout_toLeftOf&quot; format= &quot;reference&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_toRightOf&quot; format= &quot;reference&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_above&quot; format=&quot;reference&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_below&quot; format=&quot;reference&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_alignBaseline&quot; format= &quot;reference&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_alignLeft&quot; format= &quot;reference&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_alignTop&quot; format= &quot;reference&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_alignRight&quot; format= &quot;reference&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_alignBottom&quot; format= &quot;reference&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_alignParentLeft&quot; format= &quot;boolean&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_alignParentTop&quot; format= &quot;boolean&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_alignParentRight&quot; format= &quot;boolean&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_alignParentBottom&quot; format= &quot;boolean&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_centerInParent&quot; format= &quot;boolean&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_centerVertical&quot; format= &quot;boolean&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_alignWithParentIfMissing&quot; format= &quot;boolean&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_toStartOf&quot; format= &quot;reference&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_toEndOf&quot; format=&quot;reference&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_alignStart&quot; format= &quot;reference&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_alignEnd&quot; format= &quot;reference&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_alignParentStart&quot; format= &quot;boolean&quot; /&gt;</span><br><span class="line">&lt;attr name =&quot;layout_alignParentEnd&quot; format= &quot;boolean&quot; /&gt;</span><br><span class="line">&lt;/declare-styleable &gt;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>为什么View中会有一个mLayoutParams变量？</strong><br>我们在之前学习自定义控件的时候学过自定义属性，我们在构造方法中，初始化布局文件中的属性值，我们姑且把属性分为两种。一种是本View的绘制属性，比如TextView的文本、文字颜色、背景等，这些属性是跟View的绘制相关的。另一种就是以“layout_”打头的叫做布局属性，这些属性是父控件对子控件的大小及位置的一些描述属性，这些属性在父控件摆放它的时候会使用到，所以先保存起来，而这些属性都是ViewGroup.LayoutParams定义的，所以用一个变量保存着。</p></blockquote><p>看了上面的介绍，我们大概知道怎么为我们的布局容器定义自己的布局属性了吧，就不绕弯子了，按照下面的步骤做： </p><h5 id="①-大致明确布局容器的需求，初步定义布局属性"><a href="#①-大致明确布局容器的需求，初步定义布局属性" class="headerlink" title="①. 大致明确布局容器的需求，初步定义布局属性"></a>①. 大致明确布局容器的需求，初步定义布局属性</h5><p>在定义属性之前要弄清楚，我们自定义的布局容器需要满足那些需求，需要哪些属性，比如，我们现在要实现像相对布局一样，为子控件设置一个位置属性layout_position=”“，来控制子控件在布局中显示的位置。暂定位置有五种：左上、左下、右上、右下、居中。有了需求，我们就在attr.xml定义自己的布局属性（和之前讲的自定义属性一样的操作)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding= &quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt; </span><br><span class="line">&lt;declare-styleable name =&quot;CustomLayout&quot;&gt;</span><br><span class="line">&lt;attr name =&quot;layout_position&quot;&gt;</span><br><span class="line">&lt;enum name =&quot;center&quot; value=&quot;0&quot; /&gt;</span><br><span class="line">&lt;enum name =&quot;left&quot; value=&quot;1&quot; /&gt;</span><br><span class="line">&lt;enum name =&quot;right&quot; value=&quot;2&quot; /&gt;</span><br><span class="line">&lt;enum name =&quot;bottom&quot; value=&quot;3&quot; /&gt;</span><br><span class="line">&lt;enum name =&quot;rightAndBottom&quot; value=&quot;4&quot; /&gt;</span><br><span class="line">&lt;/attr &gt;</span><br><span class="line">&lt;/declare-styleable&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>left就代表是左上（按常理默认就是左上方开始，就不用写leftTop了，简洁一点），bottom左下，right 右上，rightAndBottom右下，center居中。属性类型是枚举，同时只能设置一个值。 </p><h5 id="②-继承LayoutParams，定义布局参数类"><a href="#②-继承LayoutParams，定义布局参数类" class="headerlink" title="②. 继承LayoutParams，定义布局参数类"></a>②. 继承LayoutParams，定义布局参数类</h5><p>我们可以选择继承ViewGroup.LayoutParams，这样的话我们的布局只是简单的支持layout_width和layout_height；也可以继承MarginLayoutParams，就能使用layout_marginxxx属性了。因为后面我们还要用到margin属性，所以这里方便起见就直接继承MarginLayoutParams了。<br>覆盖构造方法，然后在有AttributeSet参数的构造方法中初始化参数值，这个构造方法才是布局文件被映射为对象的时候被调用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static class CustomLayoutParams extends MarginLayoutParams &#123;</span><br><span class="line">public static final int POSITION_MIDDLE = 0; // 中间</span><br><span class="line">public static final int POSITION_LEFT = 1; // 左上方</span><br><span class="line">public static final int POSITION_RIGHT = 2; // 右上方</span><br><span class="line">public static final int POSITION_BOTTOM = 3; // 左下角</span><br><span class="line">public static final int POSITION_RIGHTANDBOTTOM = 4; // 右下角</span><br><span class="line"></span><br><span class="line">public int position = POSITION_LEFT;  // 默认我们的位置就是左上角</span><br><span class="line"></span><br><span class="line">public CustomLayoutParams(Context c, AttributeSet attrs) &#123;</span><br><span class="line">super(c, attrs);</span><br><span class="line">TypedArray a = c.obtainStyledAttributes(attrs,R.styleable.CustomLayout );</span><br><span class="line">//获取设置在子控件上的位置属性</span><br><span class="line">position = a.getInt(R.styleable.CustomLayout_layout_position ,position );</span><br><span class="line"></span><br><span class="line">a.recycle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public CustomLayoutParams( int width, int height) &#123;</span><br><span class="line">super(width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public CustomLayoutParams(ViewGroup.LayoutParams source) &#123;</span><br><span class="line">super(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="③-重写generateLayoutParams"><a href="#③-重写generateLayoutParams" class="headerlink" title="③. 重写generateLayoutParams()"></a>③. 重写generateLayoutParams()</h5><p>在ViewGroup中有下面几个关于LayoutParams的方法，generateLayoutParams (AttributeSet attrs)是在布局文件被填充为对象的时候调用的，这个方法是下面几个方法中最重要的，如果不重写它，我么布局文件中设置的布局参数都不能拿到。其他几个方法我们最好也能重写一下，将里面的LayoutParams换成我们自定义的CustomLayoutParams类，避免以后会遇到布局参数类型转换异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public LayoutParams generateLayoutParams(AttributeSet attrs) &#123;</span><br><span class="line">return new CustomLayoutParams(getContext(), attrs);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) &#123;</span><br><span class="line">return new CustomLayoutParams (p);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected LayoutParams generateDefaultLayoutParams() &#123;</span><br><span class="line">return new CustomLayoutParams (LayoutParams.MATCH_PARENT , LayoutParams.MATCH_PARENT);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected boolean checkLayoutParams(ViewGroup.LayoutParams p) &#123;</span><br><span class="line">return p instanceof CustomLayoutParams ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="④-在布局文件中使用布局属性"><a href="#④-在布局文件中使用布局属性" class="headerlink" title="④. 在布局文件中使用布局属性"></a>④. 在布局文件中使用布局属性</h5><p>注意引入命名空间xmlns:openxu= “<a href="http://schemas.android.com/apk/res/包名" target="_blank" rel="noopener">http://schemas.android.com/apk/res/包名</a>“<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding= &quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;com.openxu.costomlayout.CustomLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">xmlns:openxu= &quot;http://schemas.android.com/apk/res/com.openxu.costomlayout&quot;</span><br><span class="line">android:background=&quot;#33000000&quot;</span><br><span class="line">android:layout_width= &quot;match_parent &quot;</span><br><span class="line">android:layout_height= &quot;match_parent&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:layout_width= &quot;wrap_content&quot;</span><br><span class="line">android:layout_height= &quot;wrap_content&quot;</span><br><span class="line">openxu:layout_position= &quot;left&quot;</span><br><span class="line">android:background= &quot;#FF8247&quot;</span><br><span class="line">android:textColor= &quot;#ffffff&quot;</span><br><span class="line">android:textSize=&quot;20dip&quot;</span><br><span class="line">android:padding= &quot;20dip&quot;</span><br><span class="line">android:text= &quot;按钮1&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:layout_width= &quot;wrap_content&quot;</span><br><span class="line">android:layout_height= &quot;wrap_content&quot;</span><br><span class="line">openxu:layout_position= &quot;right&quot;</span><br><span class="line">android:background= &quot;#8B0A50&quot;</span><br><span class="line">android:textColor= &quot;#ffffff&quot;</span><br><span class="line">android:textSize= &quot;18dip&quot;</span><br><span class="line">android:padding= &quot;10dip&quot;</span><br><span class="line">android:text= &quot;按钮2222222222222&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:layout_width= &quot;wrap_content&quot;</span><br><span class="line">android:layout_height= &quot;wrap_content&quot;</span><br><span class="line">openxu:layout_position= &quot;bottom&quot;</span><br><span class="line">android:background= &quot;#7CFC00&quot;</span><br><span class="line">android:textColor= &quot;#ffffff&quot;</span><br><span class="line">android:textSize= &quot;20dip&quot;</span><br><span class="line">android:padding= &quot;15dip&quot;</span><br><span class="line">android:text= &quot;按钮333333&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:layout_width= &quot;wrap_content&quot;</span><br><span class="line">android:layout_height= &quot;wrap_content&quot;</span><br><span class="line">openxu:layout_position= &quot;rightAndBottom&quot;</span><br><span class="line">android:background= &quot;#1E90FF&quot;</span><br><span class="line">android:textColor= &quot;#ffffff&quot;</span><br><span class="line">android:textSize= &quot;15dip&quot;</span><br><span class="line">android:padding= &quot;10dip&quot;</span><br><span class="line">android:text= &quot;按钮4&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:layout_width= &quot;wrap_content&quot;</span><br><span class="line">android:layout_height= &quot;wrap_content&quot;</span><br><span class="line">openxu:layout_position= &quot;center&quot;</span><br><span class="line">android:background= &quot;#191970&quot;</span><br><span class="line">android:textColor= &quot;#ffffff&quot;</span><br><span class="line">android:textSize= &quot;20dip&quot;</span><br><span class="line">android:padding= &quot;15dip&quot;</span><br><span class="line">android:text= &quot;按钮5&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/com.openxu.costomlayout.CustomLayout&gt;</span><br></pre></td></tr></table></figure></p><h5 id="⑤-在onMeasure和onLayout中使用布局参数"><a href="#⑤-在onMeasure和onLayout中使用布局参数" class="headerlink" title="⑤. 在onMeasure和onLayout中使用布局参数"></a>⑤. 在onMeasure和onLayout中使用布局参数</h5><p>经过上面几步之后，我们运行程序，就能获取子控件的布局参数了，在onMeasure方法和onLayout方法中，我们按照自定义布局容器的特殊需求，对宽度和位置坐特殊处理。这里我们需要注意一下，如果布局容器被设置为包裹类容，我们只需要保证能将最大的子控件包裹住就ok，代码注释比较详细，就不多说了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onMeasure( int widthMeasureSpec, int heightMeasureSpec) &#123; </span><br><span class="line">//获得此ViewGroup上级容器为其推荐的宽和高，以及计算模式  </span><br><span class="line">int widthMode = MeasureSpec. getMode(widthMeasureSpec); </span><br><span class="line">int heightMode = MeasureSpec. getMode(heightMeasureSpec); </span><br><span class="line">int sizeWidth = MeasureSpec. getSize(widthMeasureSpec); </span><br><span class="line">int sizeHeight = MeasureSpec. getSize(heightMeasureSpec); </span><br><span class="line">int layoutWidth = 0;</span><br><span class="line">int layoutHeight = 0;</span><br><span class="line">// 计算出所有的childView的宽和高</span><br><span class="line">measureChildren(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">int cWidth = 0;</span><br><span class="line">int cHeight = 0;</span><br><span class="line">int count = getChildCount(); </span><br><span class="line"></span><br><span class="line">if(widthMode == MeasureSpec. EXACTLY)&#123;</span><br><span class="line">//如果布局容器的宽度模式是确定的（具体的size或者match_parent），直接使用父窗体建议的宽度</span><br><span class="line">layoutWidth = sizeWidth;</span><br><span class="line">&#125; else&#123;</span><br><span class="line">//如果是未指定或者wrap_content，我们都按照包裹内容做，宽度方向上只需要拿到所有子控件中宽度做大的作为布局宽度</span><br><span class="line">for ( int i = 0; i &lt; count; i++)  &#123; </span><br><span class="line">View child = getChildAt(i); </span><br><span class="line">cWidth = child.getMeasuredWidth(); </span><br><span class="line">//获取子控件最大宽度</span><br><span class="line">layoutWidth = cWidth &gt; layoutWidth ? cWidth : layoutWidth;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//高度很宽度处理思想一样</span><br><span class="line">if(heightMode == MeasureSpec. EXACTLY)&#123;</span><br><span class="line">layoutHeight = sizeHeight;</span><br><span class="line">&#125; else&#123;</span><br><span class="line">for ( int i = 0; i &lt; count; i++)  &#123; </span><br><span class="line">View child = getChildAt(i); </span><br><span class="line">cHeight = child.getMeasuredHeight();</span><br><span class="line">layoutHeight = cHeight &gt; layoutHeight ? cHeight : layoutHeight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测量并保存layout的宽高</span><br><span class="line">setMeasuredDimension(layoutWidth, layoutHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onLayout( boolean changed, int left, int top, int right,</span><br><span class="line">int bottom) &#123;</span><br><span class="line">final int count = getChildCount();</span><br><span class="line">int childMeasureWidth = 0;</span><br><span class="line">int childMeasureHeight = 0;</span><br><span class="line">CustomLayoutParams params = null;</span><br><span class="line">for ( int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">View child = getChildAt(i);</span><br><span class="line">// 注意此处不能使用getWidth和getHeight，这两个方法必须在onLayout执行完，才能正确获取宽高</span><br><span class="line">childMeasureWidth = child.getMeasuredWidth();</span><br><span class="line">childMeasureHeight = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">params = (CustomLayoutParams) child.getLayoutParams(); </span><br><span class="line">switch (params. position) &#123;</span><br><span class="line">case CustomLayoutParams. POSITION_MIDDLE:    // 中间</span><br><span class="line">left = (getWidth()-childMeasureWidth)/2;</span><br><span class="line">top = (getHeight()-childMeasureHeight)/2;</span><br><span class="line">break;</span><br><span class="line">case CustomLayoutParams. POSITION_LEFT:      // 左上方</span><br><span class="line">left = 0;</span><br><span class="line">top = 0;</span><br><span class="line">break;</span><br><span class="line">case CustomLayoutParams. POSITION_RIGHT:     // 右上方</span><br><span class="line">left = getWidth()-childMeasureWidth;</span><br><span class="line">top = 0;</span><br><span class="line">break;</span><br><span class="line">case CustomLayoutParams. POSITION_BOTTOM:    // 左下角</span><br><span class="line">left = 0;</span><br><span class="line">top = getHeight()-childMeasureHeight;</span><br><span class="line">break;</span><br><span class="line">case CustomLayoutParams. POSITION_RIGHTANDBOTTOM:// 右下角</span><br><span class="line">left = getWidth()-childMeasureWidth;</span><br><span class="line">top = getHeight()-childMeasureHeight;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 确定子控件的位置，四个参数分别代表（左上右下）点的坐标值</span><br><span class="line">child.layout(left, top, left+childMeasureWidth, top+childMeasureHeight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-支持layout-margin属性"><a href="#3-支持layout-margin属性" class="headerlink" title="3. 支持layout_margin属性"></a>3. 支持layout_margin属性</h4><p>如果我们自定义的布局参数类继承自MarginLayoutParams，就自动支持了layout_margin属性了，我们需要做的就是直接在布局文件中使用layout_margin属性，然后再onMeasure和onLayout中使用margin属性值测量和摆放子控件。需要注意的是我们测量子控件的时候应该调用measureChildWithMargin()方法。<br>布局文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding= &quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;com.openxu.costomlayout.CustomLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">xmlns:openxu= &quot;http://schemas.android.com/apk/res/com.openxu.costomlayout&quot;</span><br><span class="line">android:background=&quot;#33000000&quot;</span><br><span class="line">android:layout_width= &quot;match_parent&quot;</span><br><span class="line">android:layout_height= &quot;match_parent&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:layout_width= &quot;wrap_content&quot;</span><br><span class="line">android:layout_height= &quot;wrap_content&quot;</span><br><span class="line">openxu:layout_position= &quot;left&quot;</span><br><span class="line">android:layout_marginLeft = &quot;20dip&quot;</span><br><span class="line">android:background= &quot;#FF8247&quot;</span><br><span class="line">android:textColor= &quot;#ffffff&quot;</span><br><span class="line">android:textSize=&quot;20dip&quot;</span><br><span class="line">android:padding= &quot;20dip&quot;</span><br><span class="line">android:text=&quot;按钮1&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:layout_width= &quot;wrap_content&quot;</span><br><span class="line">android:layout_height= &quot;wrap_content&quot;</span><br><span class="line">android:layout_marginTop = &quot;30dip&quot;</span><br><span class="line">openxu:layout_position= &quot;right&quot;</span><br><span class="line">android:background= &quot;#8B0A50&quot;</span><br><span class="line">android:textColor= &quot;#ffffff&quot;</span><br><span class="line">android:textSize=&quot;18dip&quot;</span><br><span class="line">android:padding= &quot;10dip&quot;</span><br><span class="line">android:text=&quot;按钮2222222222222&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:layout_width= &quot;wrap_content&quot;</span><br><span class="line">android:layout_height= &quot;wrap_content&quot;</span><br><span class="line">android:layout_marginLeft = &quot;30dip&quot;</span><br><span class="line">android:layout_marginBottom = &quot;10dip&quot;</span><br><span class="line">openxu:layout_position= &quot;bottom&quot;</span><br><span class="line">android:background= &quot;#7CFC00&quot;</span><br><span class="line">android:textColor= &quot;#ffffff&quot;</span><br><span class="line">android:textSize=&quot;20dip&quot;</span><br><span class="line">android:padding= &quot;15dip&quot;</span><br><span class="line">android:text=&quot;按钮333333&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:layout_width= &quot;wrap_content&quot;</span><br><span class="line">android:layout_height= &quot;wrap_content&quot;</span><br><span class="line">openxu:layout_position= &quot;rightAndBottom&quot;</span><br><span class="line">android:layout_marginBottom = &quot;30dip&quot;</span><br><span class="line">android:background= &quot;#1E90FF&quot;</span><br><span class="line">android:textColor= &quot;#ffffff&quot;</span><br><span class="line">android:textSize=&quot;15dip&quot;</span><br><span class="line">android:padding= &quot;10dip&quot;</span><br><span class="line">android:text=&quot;按钮4&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:layout_width= &quot;wrap_content&quot;</span><br><span class="line">android:layout_height= &quot;wrap_content&quot;</span><br><span class="line">openxu:layout_position= &quot;center&quot;</span><br><span class="line">android:layout_marginBottom = &quot;30dip&quot;</span><br><span class="line">android:layout_marginRight = &quot;30dip&quot;</span><br><span class="line">android:background= &quot;#191970&quot;</span><br><span class="line">android:textColor= &quot;#ffffff&quot;</span><br><span class="line">android:textSize=&quot;20dip&quot;</span><br><span class="line">android:padding= &quot;15dip&quot;</span><br><span class="line">android:text=&quot;按钮5&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/com.openxu.costomlayout.CustomLayout&gt;</span><br></pre></td></tr></table></figure></p><p>onMeasure和onLayout：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; </span><br><span class="line">// 获得此ViewGroup上级容器为其推荐的宽和高，以及计算模式   </span><br><span class="line">int widthMode = MeasureSpec. getMode(widthMeasureSpec); </span><br><span class="line">int heightMode = MeasureSpec. getMode(heightMeasureSpec); </span><br><span class="line">int sizeWidth = MeasureSpec. getSize(widthMeasureSpec); </span><br><span class="line">int sizeHeight = MeasureSpec. getSize(heightMeasureSpec); </span><br><span class="line">int layoutWidth = 0;</span><br><span class="line">int layoutHeight = 0;</span><br><span class="line">int cWidth = 0;</span><br><span class="line">int cHeight = 0;</span><br><span class="line">int count = getChildCount(); </span><br><span class="line"></span><br><span class="line">// 计算出所有的childView的宽和高</span><br><span class="line">for( int i = 0; i &lt; count; i++)&#123;</span><br><span class="line">View child = getChildAt(i); </span><br><span class="line">measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);</span><br><span class="line">&#125;</span><br><span class="line">CustomLayoutParams params = null;</span><br><span class="line">if(widthMode == MeasureSpec. EXACTLY)&#123;</span><br><span class="line">//如果布局容器的宽度模式时确定的（具体的size或者match_parent）</span><br><span class="line">layoutWidth = sizeWidth;</span><br><span class="line">&#125; else&#123;</span><br><span class="line">//如果是未指定或者wrap_content，我们都按照包裹内容做，宽度方向上只需要拿到所有子控件中宽度做大的作为布局宽度</span><br><span class="line">for ( int i = 0; i &lt; count; i++)  &#123; </span><br><span class="line">View child = getChildAt(i); </span><br><span class="line">cWidth = child.getMeasuredWidth(); </span><br><span class="line">params = (CustomLayoutParams) child.getLayoutParams(); </span><br><span class="line">//获取子控件宽度和左右边距之和，作为这个控件需要占据的宽度</span><br><span class="line">int marginWidth = cWidth+params.leftMargin+params.rightMargin ;</span><br><span class="line">layoutWidth = marginWidth &gt; layoutWidth ? marginWidth : layoutWidth;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//高度很宽度处理思想一样</span><br><span class="line">if(heightMode == MeasureSpec. EXACTLY)&#123;</span><br><span class="line">layoutHeight = sizeHeight;</span><br><span class="line">&#125; else&#123;</span><br><span class="line">for ( int i = 0; i &lt; count; i++)  &#123; </span><br><span class="line">View child = getChildAt(i); </span><br><span class="line">cHeight = child.getMeasuredHeight();</span><br><span class="line">params = (CustomLayoutParams) child.getLayoutParams(); </span><br><span class="line">int marginHeight = cHeight+params.topMargin+params.bottomMargin ;</span><br><span class="line">layoutHeight = marginHeight &gt; layoutHeight ? marginHeight : layoutHeight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测量并保存layout的宽高</span><br><span class="line">setMeasuredDimension(layoutWidth, layoutHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onLayout( boolean changed, int left, int top, int right,</span><br><span class="line">int bottom) &#123;</span><br><span class="line">final int count = getChildCount();</span><br><span class="line">int childMeasureWidth = 0;</span><br><span class="line">int childMeasureHeight = 0;</span><br><span class="line">CustomLayoutParams params = null;</span><br><span class="line">for ( int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">View child = getChildAt(i);</span><br><span class="line">childMeasureWidth = child.getMeasuredWidth();</span><br><span class="line">childMeasureHeight = child.getMeasuredHeight();</span><br><span class="line">params = (CustomLayoutParams) child.getLayoutParams(); </span><br><span class="line">switch (params. position) &#123;</span><br><span class="line">case CustomLayoutParams. POSITION_MIDDLE:    // 中间</span><br><span class="line">left = (getWidth()-childMeasureWidth)/2 - params.rightMargin + params.leftMargin ;</span><br><span class="line">top = (getHeight()-childMeasureHeight)/2 + params.topMargin - params.bottomMargin ;</span><br><span class="line">break;</span><br><span class="line">case CustomLayoutParams. POSITION_LEFT:      // 左上方</span><br><span class="line">left = 0 + params. leftMargin;</span><br><span class="line">top = 0 + params. topMargin;</span><br><span class="line">break;</span><br><span class="line">case CustomLayoutParams. POSITION_RIGHT:     // 右上方</span><br><span class="line">left = getWidth()-childMeasureWidth - params.rightMargin;</span><br><span class="line">top = 0 + params. topMargin;</span><br><span class="line">break;</span><br><span class="line">case CustomLayoutParams. POSITION_BOTTOM:    // 左下角</span><br><span class="line">left = 0 + params. leftMargin;</span><br><span class="line">top = getHeight()-childMeasureHeight-params.bottomMargin ;</span><br><span class="line">break;</span><br><span class="line">case CustomLayoutParams. POSITION_RIGHTANDBOTTOM:// 右下角</span><br><span class="line">left = getWidth()-childMeasureWidth - params.rightMargin;</span><br><span class="line">top = getHeight()-childMeasureHeight-params.bottomMargin ;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 确定子控件的位置，四个参数分别代表（左上右下）点的坐标值</span><br><span class="line">child.layout(left, top, left+childMeasureWidth, top+childMeasureHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行效果：<br><img src="/2017/10/09/Android自定义View详细教程/5.jpg"></p><p>好了，就写到这里，如果想尝试设置其他属性，比如above、below等，也是可以的。<br>最后，要隆重推荐一下<code>作者：扔物线</code>写的关于<a href="http://hencoder.com/ui-1-1/" target="_blank" rel="noopener">自定义View绘制</a>的一系列文章，写的真的很用心，大赞。</p><hr><p><strong>参考资料</strong><br><a href="http://blog.csdn.net/xmxkf/article/details/51454685" target="_blank" rel="noopener">自定义View教程1</a><br><a href="https://www.jianshu.com/p/c84693096e41" target="_blank" rel="noopener">自定义View教程2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自定义View一直都是Android开发的一个重要模块，在实际开发过程中我们也无法避免地会用到它。那么今天就来详细的梳理一下这一块的知识点吧。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="自定义View" scheme="http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit使用详解及源码分析</title>
    <link href="http://yoursite.com/2017/09/06/Retrofit%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/09/06/Retrofit使用详解及源码分析/</id>
    <published>2017-09-06T12:24:20.000Z</published>
    <updated>2018-03-07T12:22:22.042Z</updated>
    
    <content type="html"><![CDATA[<p>Retrofit是Square团队旗下一个知名的Android网络请求库，准确的说，它是由Square对okhttp再次封装所成。本章在详细的介绍Retrofit用法的同时，还会分析它的前世今生，包括okhttp介绍、源码分析、java注解的掌握以及Retrofit的二次封装知识。<a id="more"></a></p><h1 id="从okhttp的使用讲起"><a href="#从okhttp的使用讲起" class="headerlink" title="从okhttp的使用讲起"></a>从okhttp的使用讲起</h1><p>前面说了Retrofit是在Okhttp的基础之上发展起来，那么要想全面的理解之，还是要把okhttp这块的用法搞懂的（不涉及源码），下面就从okhttp开始吧～</p><h2 id="okHttp主要类"><a href="#okHttp主要类" class="headerlink" title="okHttp主要类"></a>okHttp主要类</h2><p>下面是okhttp的几大主要类，这一部分的内容就围绕它们进行。<br>OkHttpClient.java<br>Request.java<br>Call.java<br>RequestBody.java<br>Response.java</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h4 id="HTTP-GET"><a href="#HTTP-GET" class="headerlink" title="HTTP GET"></a>HTTP GET</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package okhttp3.guide;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import okhttp3.OkHttpClient;</span><br><span class="line">import okhttp3.Request;</span><br><span class="line">import okhttp3.Response;</span><br><span class="line"></span><br><span class="line">public class GetExample &#123;</span><br><span class="line">OkHttpClient client = new OkHttpClient();</span><br><span class="line"></span><br><span class="line">String run(String url) throws IOException &#123;</span><br><span class="line">Request request = new Request.Builder()</span><br><span class="line">.url(url)</span><br><span class="line">.build();</span><br><span class="line"></span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line">return response.body().string();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">GetExample example = new GetExample();</span><br><span class="line">String response = example.run(&quot;https://raw.github.com/square/okhttp/master/README.md&quot;);</span><br><span class="line">System.out.println(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上面执行的流程是这样的：</strong><br>第一步，在程序第9行处获取了okhttpclient的实例；<br>第二步，在程序第12行处，通过<code>Request.Builder()</code>构建一个request请求对象，这里可以配置许多网络请求所需的参数：url、header、post对象等。<br>第三步，在程序第16行处，通过Call类的<code>execute()</code>同步方法返回一个response响应对象，对象中包含了服务端返回的字符串信息。<br>至此，一个简单的Http Get流程算是完成了。这里要注意的是:<br>1、在第二步中，我们说通过<code>Request.Builder()</code>可以配置许多网络请求相关的信息，其实我们还可以通过<code>okHttpClient.newBuilder()</code>方法配置一些更加全局的网络参数，比如：拦截器、超时时间等。<br>2、在第二步中提到配置的参数可以是post对象，它对应的方法是<code>post(RequestBody body)</code>，那么有没有提供类似get(T params)的方法供请求参数的配置呢？答案是没有。所以如果需要在url中配置请求参数，还需要以拼接字符串的方式完成。<br>3、在第三步中除了能用Call类的execute()同步方法返回响应之外，还可以使用它的<code>enqueue()</code>方法异步返回响应信息，这里要看具体的使用场景了。</p><h4 id="HTTP-POST"><a href="#HTTP-POST" class="headerlink" title="HTTP POST"></a>HTTP POST</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class PostExample &#123;</span><br><span class="line">public static final MediaType JSON</span><br><span class="line">= MediaType.parse(&quot;application/json; charset=utf-8&quot;);</span><br><span class="line"></span><br><span class="line">OkHttpClient client = new OkHttpClient();</span><br><span class="line"></span><br><span class="line">String post(String url, String json) throws IOException &#123;</span><br><span class="line">RequestBody body = RequestBody.create(JSON, json);</span><br><span class="line">Request request = new Request.Builder()</span><br><span class="line">.url(url)</span><br><span class="line">.post(body)</span><br><span class="line">.build();</span><br><span class="line">try (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">return response.body().string();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String bowlingJson(String player1, String player2) &#123;</span><br><span class="line">return &quot;&#123;&apos;winCondition&apos;:&apos;HIGH_SCORE&apos;,&quot;</span><br><span class="line">+ &quot;&apos;name&apos;:&apos;Bowling&apos;,&quot;</span><br><span class="line">+ &quot;&apos;round&apos;:4,&quot;</span><br><span class="line">+ &quot;&apos;lastSaved&apos;:1367702411696,&quot;</span><br><span class="line">+ &quot;&apos;dateStarted&apos;:1367702378785,&quot;</span><br><span class="line">+ &quot;&apos;players&apos;:[&quot;</span><br><span class="line">+ &quot;&#123;&apos;name&apos;:&apos;&quot; + player1 + &quot;&apos;,&apos;history&apos;:[10,8,6,7,8],&apos;color&apos;:-13388315,&apos;total&apos;:39&#125;,&quot;</span><br><span class="line">+ &quot;&#123;&apos;name&apos;:&apos;&quot; + player2 + &quot;&apos;,&apos;history&apos;:[6,10,5,10,10],&apos;color&apos;:-48060,&apos;total&apos;:41&#125;&quot;</span><br><span class="line">+ &quot;]&#125;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">PostExample example = new PostExample();</span><br><span class="line">String json = example.bowlingJson(&quot;Jesse&quot;, &quot;Jake&quot;);</span><br><span class="line">String response = example.post(&quot;http://www.roundsapp.com/post&quot;, json);</span><br><span class="line">System.out.println(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个向服务端发送Post请求的例子，仔细观察发现它和Get部分的不同之处主要在于第11行的<code>post(body)</code>配置方法。参数body是我们需要上传到服务器的数据，他是RequestBody类型的对象，该对象由<code>RequestBody.create(MediaType contentType, T t)</code>方法生成。MediaType代表消息内容的类型，具体可翻阅<a href="https://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="noopener">Media Types</a>、<a href="http://www.w3school.com.cn/media/media_mimeref.asp" target="_blank" rel="noopener">MIME 参考手册</a>这两篇文章。后面的T对象由MediaType的类型决定，可以看出RequestBody.create是一个重载方法。<br>对于RequestBody，api还提供了它的两个实现类：FormBody、MultipartBody，分别对应表单和文件的上传。<br>当然，OkHttp在实际应用中可能还会涉及到需要重复验证的问题，具体请结合<a href="https://howtoprogram.xyz/2016/11/03/basic-authentication-okhttp-example/" target="_blank" rel="noopener">这篇文章</a>以及掘金网的<a href="https://juejin.im/entry/584144d0128fe1006c3cfb8f" target="_blank" rel="noopener">这篇文章</a>看看。</p><h1 id="Retrofit的使用"><a href="#Retrofit的使用" class="headerlink" title="Retrofit的使用"></a>Retrofit的使用</h1><p>有了前面okhttp的使用经验，再来说Retrofit的使用就简单了。Retrofit其实质就是对okHttp的封装，使用面向接口的方式进行网络请求，利用动态生成的代理类封装了网络接口。Retrofit非常适合于 RESTful 风格的请求，使用<a href="https://www.cnblogs.com/whoislcj/p/5671622.html" target="_blank" rel="noopener">注解的方式</a>提供功能，对于<strong>注解</strong>不了解的同学，还可以结合<a href="http://blog.csdn.net/yubotianxiao/article/details/51861663" target="_blank" rel="noopener">这篇文章</a>看看。</p><blockquote><p><strong>RESTful特征：</strong><br>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</p></blockquote><h2 id="用法介绍"><a href="#用法介绍" class="headerlink" title="用法介绍"></a>用法介绍</h2><h4 id="创建API接口"><a href="#创建API接口" class="headerlink" title="创建API接口"></a>创建API接口</h4><p>在retrofit中通过一个Java接口作为http请求的api接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定以接口</span><br><span class="line">public interface GitHubService &#123;</span><br><span class="line">@GET(&quot;users/&#123;user&#125;/repos&quot;)</span><br><span class="line">Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="创建Retrofit实例"><a href="#创建Retrofit实例" class="headerlink" title="创建Retrofit实例"></a>创建Retrofit实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**获取实例*/</span><br><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">//设置OKHttpClient,如果不设置会提供一个默认的</span><br><span class="line">.client(new OkHttpClient())</span><br><span class="line">//设置baseUrl</span><br><span class="line">.baseUrl(&quot;https://api.github.com/&quot;)</span><br><span class="line">//添加Gson转换器</span><br><span class="line">.addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong><br>1.retrofit2.0后：BaseUrl要以/结尾；@GET 等请求不要以/开头；@Url: 可以定义完整url，不要以 / 开头。<br>2.addConverterFactory提供Gson支持，可以添加多种序列化Factory，但是GsonConverterFactory必须放在最后,否则会抛出异常。</p></blockquote><h4 id="调用API接口"><a href="#调用API接口" class="headerlink" title="调用API接口"></a>调用API接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br><span class="line"></span><br><span class="line">//同步请求</span><br><span class="line">//https://api.github.com/users/octocat/repos</span><br><span class="line">Call&lt;List&lt;Repo&gt;&gt; call = service.listRepos(&quot;octocat&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">Response&lt;List&lt;Repo&gt;&gt; repos  = call.execute();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//不管同步还是异步，call只能执行一次。否则会抛 IllegalStateException</span><br><span class="line">Call&lt;List&lt;Repo&gt;&gt; clone = call.clone();</span><br><span class="line"></span><br><span class="line">//异步请求</span><br><span class="line">clone.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onResponse(Response&lt;List&lt;Repo&gt;&gt; response, Retrofit retrofit) &#123;</span><br><span class="line">// Get result bean from response.body()</span><br><span class="line">List&lt;Repo&gt; repos = response.body();</span><br><span class="line">// Get header item from response</span><br><span class="line">String links = response.headers().get(&quot;Link&quot;);</span><br><span class="line">/**</span><br><span class="line">* 不同于retrofit1 可以同时操作序列化数据javabean和header</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onFailure(Throwable throwable) &#123;</span><br><span class="line">showlog(throwable.getCause().toString());   </span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h4><p>我们可以终止一个请求。终止操作是对底层的httpclient执行cancel操作。即使是正在执行的请求，也能够立即终止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call.cancel();</span><br></pre></td></tr></table></figure></p><h4 id="retrofit注解"><a href="#retrofit注解" class="headerlink" title="retrofit注解"></a>retrofit注解</h4><ul><li>方法注解，包含@GET、@POST、@PUT、@DELETE、@PATH、@HEAD、@OPTIONS、@HTTP。</li><li>标记注解，包含@FormUrlEncoded、@Multipart、@Streaming。</li><li>参数注解，包含@Query、@QueryMap、@Body、@Field，@FieldMap、@Part，@PartMap。</li><li>其他注解，包含@Path、@Header、@Headers、@Url。</li></ul><h5 id="1-一般的get请求"><a href="#1-一般的get请求" class="headerlink" title="(1)一般的get请求"></a>(1)一般的get请求</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IWeatherGet &#123;</span><br><span class="line">@GET(&quot;GetMoreWeather?cityCode=101020100&amp;weatherType=0&quot;)</span><br><span class="line">Call&lt;Weather&gt; getWeather();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有一个getWeather(）方法，通过@GET注解标识为get请求，@GET中所填写的value和baseUrl组成完整的路径，baseUrl在构造retrofit对象时给出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">/**http://weather.51wnl.com/weatherinfo/GetMoreWeather?cityCode=101020100&amp;weatherType=0*/</span><br><span class="line">//注意baseurl要以/结尾</span><br><span class="line">.baseUrl(&quot;http://weather.51wnl.com/weatherinfo/&quot;)</span><br><span class="line">.addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">.build();</span><br><span class="line">IWeatherGet weather = retrofit.create(IWeatherGet.class);</span><br><span class="line">Call&lt;Weather&gt; call = weather.getWeather();</span><br><span class="line">call.enqueue(new Callback&lt;Weather&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onResponse(Response&lt;Weather&gt; response, Retrofit retrofit) &#123;</span><br><span class="line">Weather weather = response.body();</span><br><span class="line">WeatherInfo weatherinfo = weather.weatherinfo;</span><br><span class="line">showlog(&quot;weather=&quot;+weatherinfo.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onFailure(Throwable throwable) &#123;</span><br><span class="line">showlog(throwable.getCause().toString());       </span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h5 id="（2）动态url访问-PATH"><a href="#（2）动态url访问-PATH" class="headerlink" title="（2）动态url访问@PATH"></a>（2）动态url访问@PATH</h5><p>上面说的@GET注解是将baseUrl和@GET中的value组成完整的路径。有时候我们可以将路径中某个字符串设置为不同的值来请求不同的数据，这时候怎么办呢？<br>譬如：<br>可以通过retrofit提供的@PATH注解非常方便的完成上述需求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IWeatherPath &#123;</span><br><span class="line">@GET(&quot;&#123;info&#125;?cityCode=101020100&amp;weatherType=0&quot;)</span><br><span class="line">Call&lt;Weather&gt; getWeather(@Path(&quot;info&quot;) String info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到我们定义了一个getWeather方法，方法接收一个info参数，并且我们的@GET注解中使用{info}?cityCode=101020100&amp;weatherType=0声明了访问路径，这里你可以把{info}当做占位符，而实际运行中会通过@PATH(“info”)所标注的参数进行替换。</p><h5 id="（3）查询参数的设置-Query-QueryMap"><a href="#（3）查询参数的设置-Query-QueryMap" class="headerlink" title="（3）查询参数的设置@Query@QueryMap"></a>（3）查询参数的设置@Query@QueryMap</h5><p>文章开头提过，retrofit非常适用于restful url的格式，那么例如下面这样的url：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//用于访问上海天气</span><br><span class="line">http://weather.51wnl.com/weatherinfo/GetMoreWeather?cityCode=101020100&amp;weatherType=0</span><br><span class="line"></span><br><span class="line">//用于访问北京天气</span><br><span class="line">http://weather.51wnl.com/weatherinfo/GetMoreWeather?cityCode=101010100&amp;weatherType=0</span><br></pre></td></tr></table></figure></p><p>即通过传参方式使用不同的citycode访问不同城市的天气，返回数据为json字符串。我们可以通过@Query注解方便的完成，我们再次在接口中添加一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface IWeatherQuery &#123;</span><br><span class="line">@GET(&quot;GetMoreWeather&quot;)</span><br><span class="line">Call&lt;Weather&gt; getWeather(@Query(&quot;cityCode&quot;) String cityCode, @Query(&quot;weatherType&quot;) String weatherType);</span><br><span class="line">&#125;</span><br><span class="line">/**省略retrofit的构建代码*/</span><br><span class="line">Call&lt;Weather&gt; call = weather.getWeather(&quot;101020100&quot;, &quot;0&quot;);</span><br><span class="line">//Call&lt;Weather&gt; call = weather.getWeather(&quot;101010100&quot;, &quot;0&quot;);</span><br><span class="line">/**省略call执行相关代码*/</span><br></pre></td></tr></table></figure></p><p>当我们的参数过多的时候我们可以通过@QueryMap注解和map对象参数来指定每个表单项的Key，value的值，同样是上面的例子，还可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface IWeatherQueryMap &#123;</span><br><span class="line">@GET(&quot;GetMoreWeather&quot;)</span><br><span class="line">Call&lt;Weather&gt; getWeather(@QueryMap Map&lt;String,String&gt; map);</span><br><span class="line">&#125;</span><br><span class="line">//省略retrofit的构建代码</span><br><span class="line">Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(&quot;cityCode&quot;, &quot;101020100&quot;);</span><br><span class="line">map.put(&quot;weatherType&quot;, &quot;0&quot;);</span><br><span class="line">Call&lt;Weather&gt; call = weather.getWeather(map);</span><br><span class="line">//省略call执行相关代码</span><br></pre></td></tr></table></figure></p><h5 id="（4）POST请求体方式向服务器传入json字符串-Body"><a href="#（4）POST请求体方式向服务器传入json字符串-Body" class="headerlink" title="（4）POST请求体方式向服务器传入json字符串@Body"></a>（4）POST请求体方式向服务器传入json字符串@Body</h5><p>我们app很多时候跟服务器通信，会选择直接使用POST方式将json字符串作为请求体发送到服务器，那么我们看看这个需求使用retrofit该如何实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface IUser &#123;</span><br><span class="line">@POST(&quot;add&quot;)</span><br><span class="line">Call&lt;List&lt;User&gt;&gt; addUser(@Body User user);</span><br><span class="line">&#125;</span><br><span class="line">/省略retrofit的构建代码</span><br><span class="line">Call&lt;List&lt;User&gt;&gt; call = user.addUser(new User(&quot;watson&quot;, &quot;male&quot;, &quot;28&quot;));</span><br><span class="line">//省略call执行相关代码</span><br></pre></td></tr></table></figure></p><p>可以看到其实就是使用@Body这个注解标识我们的参数对象即可，那么这里需要考虑一个问题，retrofit是如何将user对象转化为字符串呢？将实例对象根据转换方式转换为对应的json字符串参数，这个转化方式是GsonConverterFactory定义的。<br>对应okhttp，还有两种requestBody，一个是FormBody，一个是MultipartBody，前者以表单的方式传递简单的键值对，后者以表单的方式上传文件可以携带参数，retrofit也二者也有对应的注解，下面继续~</p><h5 id="（5）表单的方式传递键值对-FormUrlEncoded-Field-FieldMap"><a href="#（5）表单的方式传递键值对-FormUrlEncoded-Field-FieldMap" class="headerlink" title="（5）表单的方式传递键值对@FormUrlEncoded + @Field@FieldMap"></a>（5）表单的方式传递键值对@FormUrlEncoded + @Field@FieldMap</h5><p>这里我们模拟一个登录的方法，添加一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface IUser &#123;</span><br><span class="line">@FormUrlEncoded</span><br><span class="line">@POST(&quot;login&quot;)   </span><br><span class="line">Call&lt;User&gt; login(@Field(&quot;username&quot;) String username, @Field(&quot;password&quot;) String password);</span><br><span class="line">&#125;</span><br><span class="line">//省略retrofit的构建代码</span><br><span class="line">Call&lt;User&gt; call = user.login(&quot;watson&quot;, &quot;123&quot;);</span><br><span class="line">//省略call执行相关代码</span><br></pre></td></tr></table></figure></p><p>看起来也很简单，通过@POST指明url，添加FormUrlEncoded，然后通过@Field添加参数即可。<br>当我们有很多个表单参数时也可以通过@FieldMap注解和Map对象参数来指定每个表单项的Key，value的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface IUser &#123;</span><br><span class="line">@FormUrlEncoded</span><br><span class="line">@POST(&quot;login&quot;)   </span><br><span class="line">Call&lt;User&gt; login(@FieldMap Map&lt;String,String&gt; fieldMap);</span><br><span class="line">&#125;</span><br><span class="line">//省略retrofit的构建代码</span><br><span class="line">Map&lt;String, String&gt; propertity = new HashMap&lt;String, String&gt;();</span><br><span class="line">positories.put(&quot;name&quot;, &quot;watson&quot;);</span><br><span class="line">positories.put(&quot;password&quot;, &quot;123&quot;);</span><br><span class="line">Call&lt;User&gt; call = user.login(propertity);</span><br><span class="line">//省略call执行相关代码</span><br></pre></td></tr></table></figure></p><h5 id="（6）文件上传-Multipart-Part-PartMap"><a href="#（6）文件上传-Multipart-Part-PartMap" class="headerlink" title="（6）文件上传@Multipart + @Part@PartMap"></a>（6）文件上传@Multipart + @Part@PartMap</h5><p>1.下面先看一下单文件上传，依然是再次添加个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IUser &#123;</span><br><span class="line">@Multipart</span><br><span class="line">@POST(&quot;register&quot;)</span><br><span class="line">Call&lt;User&gt; registerUser(@Part MultipartBody.Part photo, @Part(&quot;username&quot;) RequestBody username, @Part(&quot;password&quot;) RequestBody password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里@MultiPart的意思就是允许多个@Part了，我们这里使用了3个@Part，第一个我们准备上传个文件，使用了MultipartBody.Part类型，其余两个均为简单的键值对。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(Environment.getExternalStorageDirectory(), &quot;icon.png&quot;);</span><br><span class="line">RequestBody photoRequestBody = RequestBody.create(MediaType.parse(&quot;image/png&quot;), file);</span><br><span class="line">MultipartBody.Part photo = MultipartBody.Part.createFormData(&quot;photos&quot;, &quot;icon.png&quot;, photoRequestBody);</span><br><span class="line"></span><br><span class="line">Call&lt;User&gt; call = user.registerUser(photo, RequestBody.create(null, &quot;abc&quot;), RequestBody.create(null, &quot;123&quot;));</span><br></pre></td></tr></table></figure></p><p>这里感觉略为麻烦。不过还是蛮好理解~~多个@Part，每个Part对应一个RequestBody。<br>注：这里还有另外一个方案也是可行的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface ApiInterface &#123;</span><br><span class="line">@Multipart</span><br><span class="line">@POST (&quot;/api/Accounts/editaccount&quot;)</span><br><span class="line">Call&lt;User&gt; editUser (@Header(&quot;Authorization&quot;) String authorization, @Part(&quot;photos\&quot;; filename=\&quot;icon.png&quot;) RequestBody file , @Part(&quot;FirstName&quot;) RequestBody fname, @Part(&quot;Id&quot;) RequestBody id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个value设置的值不用看就会觉得特别奇怪，然而却可以正常执行，原因是什么呢？<br>当上传key-value的时候，实际上对应这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.addPart(Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;&quot; + key + &quot;\&quot;&quot;), RequestBody.create(null, params.get(key)));</span><br></pre></td></tr></table></figure></p><p>也就是说，我们的@Part转化为了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;&quot; + key + &quot;\&quot;&quot;)</span><br></pre></td></tr></table></figure></p><p>这么一看，很随意，只要把key放进去就可以了。但是，retrofit2并没有对文件做特殊处理，文件的对应的字符串应该是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=&quot;photos&quot;;filename=&quot;icon.png&quot;&quot;);</span><br></pre></td></tr></table></figure></p><p>与键值对对应的字符串相比，多了个\”; filename=\”icon.png，就因为retrofit没有做特殊处理，所以你现在看这些hack的做法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Part(&quot;photos\&quot;; filename=\&quot;icon.png&quot;)</span><br><span class="line">==&gt; key = photos\&quot;; filename=\&quot;icon.png</span><br><span class="line"></span><br><span class="line">form-data; name=\&quot;&quot; + key + &quot;\&quot;</span><br><span class="line">拼接结果：==&gt;</span><br><span class="line">form-data; name=&quot;photos&quot;; filename=&quot;icon.png&quot;</span><br></pre></td></tr></table></figure></p><p>因为这种方式文件名写死了，我们上文使用的的是@Part MultipartBody.Part file,可以满足文件名动态设置。</p><p>2.如果是多文件上传呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IUser &#123;</span><br><span class="line">@Multipart</span><br><span class="line">@POST(&quot;register&quot;)</span><br><span class="line">Call&lt;User&gt; registerUser(@PartMap Map&lt;String, RequestBody&gt; params, @Part(&quot;password&quot;) RequestBody password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里使用了一个新的注解@PartMap，这个注解用于标识一个Map，Map的key为String类型，代表上传的键值对的key(与服务器接受的key对应),value即为RequestBody，有点类似@Part的封装版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(Environment.getExternalStorageDirectory(), &quot;local.png&quot;);</span><br><span class="line">RequestBody photo = RequestBody.create(MediaType.parse(&quot;image/png&quot;, file);</span><br><span class="line">Map&lt;String, RequestBody&gt; map = new HashMap&lt;&gt;(String, RequestBody);</span><br><span class="line">map.put(&quot;photos\&quot;; filename=\&quot;icon.png&quot;, photo);</span><br><span class="line">map.put(&quot;username&quot;,  RequestBody.create(null, &quot;abc&quot;));</span><br><span class="line"></span><br><span class="line">Call&lt;User&gt; call = user.registerUser(map, RequestBody.create(null, &quot;123&quot;));</span><br></pre></td></tr></table></figure></p><p>可以看到，可以在Map中put进一个或多个文件，键值对等，当然你也可以分开，单独的键值对也可以使用@Part，这里又看到设置文件的时候，相对应的key很奇怪，例如上例”photos\”; filename=\”icon.png”,前面的photos就是与服务器对应的key，后面filename是服务器得到的文件名，ok，参数虽然奇怪，但是也可以动态的设置文件名，不影响使用。</p><h5 id="（7）下载文件"><a href="#（7）下载文件" class="headerlink" title="（7）下载文件"></a>（7）下载文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@GET(&quot;download&quot;)</span><br><span class="line">Call&lt;ResponseBody&gt; downloadTest();</span><br><span class="line"></span><br><span class="line">Call&lt;ResponseBody&gt; call = user.downloadTest();</span><br><span class="line">call.enqueue(new Callback&lt;ResponseBody&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123;</span><br><span class="line">InputStream is = response.body().byteStream();</span><br><span class="line">//save file</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t)&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="（8）添加请求头-Header-Headers"><a href="#（8）添加请求头-Header-Headers" class="headerlink" title="（8）添加请求头@Header@Headers"></a>（8）添加请求头@Header@Headers</h5><p>@Header：header处理，不能被互相覆盖，所有具有相同名字的header将会被包含到请求中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//静态设置Header值</span><br><span class="line">@Headers(&quot;Authorization: authorization&quot;)</span><br><span class="line">@GET(&quot;widget/list&quot;)</span><br><span class="line">Call&lt;User&gt; getUser()</span><br></pre></td></tr></table></figure></p><p>@Headers 用于修饰方法,用于设置多个Header值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Headers(&#123;</span><br><span class="line">&quot;Accept: application/vnd.github.v3.full+json&quot;,</span><br><span class="line">&quot;User-Agent: Retrofit-Sample-App&quot;</span><br><span class="line">&#125;)</span><br><span class="line">@GET(&quot;users/&#123;username&#125;&quot;)</span><br><span class="line">Call&lt;User&gt; getUser(@Path(&quot;username&quot;) String username);</span><br></pre></td></tr></table></figure></p><p>还可以使用@Header注解动态的更新一个请求的<a href="https://kb.cnblogs.com/page/119118/" target="_blank" rel="noopener">header</a>。必须给@Header提供相应的参数，如果参数的值为空header将会被忽略，否则就调用参数值的toString()方法并使用返回结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//动态设置Header值</span><br><span class="line">@GET(&quot;user&quot;)</span><br><span class="line">Call&lt;User&gt; getUser(@Header(&quot;Authorization&quot;) String authorization)</span><br></pre></td></tr></table></figure></p><h5 id="配置OkHttpClient"><a href="#配置OkHttpClient" class="headerlink" title="配置OkHttpClient"></a>配置OkHttpClient</h5><p>很多时候，比如你使用retrofit需要统一的log管理，缓存管理，给每个请求添加统一的header等，这些都应该通过okhttpclient去操作。Retrofit 2.0 底层依赖于okHttp，所以需要使用okHttp的<a href="https://www.jianshu.com/p/2710ed1e6b48" target="_blank" rel="noopener">Interceptors</a>来对所有请求进行拦截。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = new OkHttpClient();</span><br><span class="line">client.networkInterceptors().add(new Interceptor() &#123;</span><br><span class="line">@Override</span><br><span class="line">public com.squareup.okhttp.Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">com.squareup.okhttp.Response response = chain.proceed(chain.request());</span><br><span class="line"></span><br><span class="line">// Do anything with response here</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">.baseUrl(BASE_URL)</span><br><span class="line">...</span><br><span class="line">.client(client) //传入自己定义的client</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure></p><p>或许你需要更多的配置，你可以单独写一个OkhttpClient的单例生成类，在这个里面完成你所需的所有的配置，然后将OkhttpClient实例通过方法公布出来，设置给retrofit。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">.callFactory(OkHttpUtils.getClient())</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure></p><p>callFactory方法接受一个okhttp3.Call.Factory对象，OkHttpClient即为一个实现类。</p><h1 id="Retrofit2-0源码分析"><a href="#Retrofit2-0源码分析" class="headerlink" title="Retrofit2.0源码分析"></a>Retrofit2.0源码分析</h1><p>接下来我们对retrofit的源码做简单的分析，首先我们看retrofit如何为我们的接口实现实例；然后看整体的执行流程；最后再看详细的细节；</p><h4 id="（1）retrofit如何为我们的接口实现实例"><a href="#（1）retrofit如何为我们的接口实现实例" class="headerlink" title="（1）retrofit如何为我们的接口实现实例"></a>（1）retrofit如何为我们的接口实现实例</h4><p>使用retrofit需要去定义一个接口，然后可以通过调用retrofit.create(IUser.class)方法，得到一个接口的实例，最后通过该实例执行我们的操作，那么retrofit如何实现我们指定接口的实例呢？<br>其实原理是：动态代理。但是不要被动态代理这几个词吓唬到，Java中已经提供了非常简单的API帮助我们来实现动态代理。<br>看源码前先看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface ITest</span><br><span class="line">&#123;</span><br><span class="line">@GET(&quot;/heiheihei&quot;)</span><br><span class="line">public void add(int a, int b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">ITest iTest = (ITest) Proxy.newProxyInstance(ITest.class.getClassLoader(), new Class&lt;?&gt;[]&#123;ITest.class&#125;, new InvocationHandler()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable</span><br><span class="line">&#123;</span><br><span class="line">Integer a = (Integer) args[0];</span><br><span class="line">Integer b = (Integer) args[1];</span><br><span class="line">System.out.println(&quot;方法名：&quot; + method.getName());</span><br><span class="line">System.out.println(&quot;参数：&quot; + a + &quot; , &quot; + b);</span><br><span class="line"></span><br><span class="line">GET get = method.getAnnotation(GET.class);</span><br><span class="line">System.out.println(&quot;注解：&quot; + get.value());</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">iTest.add(3, 5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法名：add</span><br><span class="line">参数：3 , 5</span><br><span class="line">注解：/heiheihei</span><br></pre></td></tr></table></figure></p><p>可以看到我们通过Proxy.newProxyInstance产生的代理类，当调用接口的任何方法时，都会调用InvocationHandler#invoke方法，在这个方法中可以拿到传入的参数，注解等。<br>其实retrofit也可以通过同样的方式，在invoke方法里面，拿到所有的参数，注解信息然后就可以去构造RequestBody，再去构建Request，得到Call对象封装后返回。<br>下面看retrofit#create的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">new InvocationHandler() &#123;</span><br><span class="line">@Override </span><br><span class="line">public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和上面对应。到这里，你应该明白retrofit为我们接口生成实例对象并不神奇，仅仅是使用了Proxy这个类的API而已，然后在invoke方法里面拿到足够的信息去构建最终返回的Call而已。</p><h4 id="（2）retrofit整体实现流程"><a href="#（2）retrofit整体实现流程" class="headerlink" title="（2）retrofit整体实现流程"></a>（2）retrofit整体实现流程</h4><p>Retrofit的构建：这里依然是通过构造者模式进行构建retrofit对象，好在其内部的成员变量比较少，我们直接看build()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public Builder() &#123;</span><br><span class="line">this(Platform.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Retrofit build() &#123;</span><br><span class="line">if (baseUrl == null) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Base URL required.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">okhttp3.Call.Factory callFactory = this.callFactory;</span><br><span class="line">if (callFactory == null) &#123;</span><br><span class="line">callFactory = new OkHttpClient();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Executor callbackExecutor = this.callbackExecutor;</span><br><span class="line">if (callbackExecutor == null) &#123;</span><br><span class="line">callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Make a defensive copy of the adapters and add the default Call adapter.</span><br><span class="line">List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);</span><br><span class="line">adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">// Make a defensive copy of the converters.</span><br><span class="line">List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories);</span><br><span class="line"></span><br><span class="line">return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</span><br><span class="line">callbackExecutor, validateEagerly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>baseUrl必须指定，这个是理所当然的；</p><p>然后可以看到如果不着急设置callFactory，则默认直接new OkHttpClient()，可见如果你需要对okhttpclient进行详细的设置，需要构建OkHttpClient对象，然后传入；<br>接下来是callbackExecutor，这个想一想大概是用来将回调传递到UI线程了，当然这里设计的比较巧妙，利用platform对象，对平台进行判断，判断主要是利用Class.forName(“”)进行查找，如果是Android平台，会自定义一个Executor对象，并且利用Looper.getMainLooper()实例化一个handler对象，在Executor内部通过handler.post(runnable)，ok，整理凭大脑应该能构思出来，暂不贴代码了。<br>接下来是adapterFactories，这个对象主要用于对Call进行转化，基本上不需要我们自己去自定义。<br>最后是converterFactories，该对象用于转化数据，例如将返回的responseBody转化为对象等；当然不仅仅是针对返回的数据，还能用于一般注解的参数的转化，例如@Body标识的对象做一些操作，后面遇到源码详细再描述。<br>具体Call构建流程：我们构造完成retrofit，就可以利用retrofit.create方法去构建接口的实例了，上面我们已经分析了这个环节利用了动态代理，而且我们也分析了具体的Call的构建流程在invoke方法中，下面看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">Utils.validateServiceInterface(service);</span><br><span class="line">//...</span><br><span class="line">return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">new InvocationHandler() &#123;</span><br><span class="line">@Override </span><br><span class="line">public Object invoke(Object proxy, Method method, Object... args)&#123;</span><br><span class="line">//...</span><br><span class="line">ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">return serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主要也就三行代码，第一行是根据我们的method将其包装成ServiceMethod，第二行是通过ServiceMethod和方法的参数构造retrofit2.OkHttpCall对象，第三行是通过serviceMethod.callAdapter.adapt()方法，将OkHttpCall进行代理包装。<br>总结一下：</p><ul><li>首先构造retrofit，几个核心的参数呢，主要就是baseurl,callFactory(默认okhttpclient),converterFactories,adapterFactories,excallbackExecutor。</li><li>然后通过create方法拿到接口的实现类，这里利用Java的Proxy类完成动态代理的相关代理。</li><li>在invoke方法内部，拿到我们所声明的注解以及实参等，构造ServiceMethod，ServiceMethod中解析了大量的信息，最终可以通过toRequest构造出okhttp3.Request对象。有了okhttp3.Request对象就可以很自然的构建出okhttp3.call，最后calladapter对Call进行装饰返回。</li><li>拿到Call就可以执行enqueue或者execute方法了。</li></ul><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>最后在推荐一个非常火的网络调试工具：<a href="https://github.com/facebook/stetho" target="_blank" rel="noopener">stetho</a>。利用它你可以非常方便地查看应用的本地数据库、SharePerence、网络请求等数据。这里有一篇关于它的<a href="https://www.jianshu.com/p/c03a8959d1a5" target="_blank" rel="noopener">使用指南</a>。</p><hr><p><strong>参考资料</strong><br><a href="http://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp</a><br><a href="http://www.androidchina.net/5758.html" target="_blank" rel="noopener">Android Retrofit框架解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Retrofit是Square团队旗下一个知名的Android网络请求库，准确的说，它是由Square对okhttp再次封装所成。本章在详细的介绍Retrofit用法的同时，还会分析它的前世今生，包括okhttp介绍、源码分析、java注解的掌握以及Retrofit的二次封装知识。
    
    </summary>
    
      <category term="Android框架" scheme="http://yoursite.com/categories/Android%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Retrofit" scheme="http://yoursite.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>Android屏幕适配方案</title>
    <link href="http://yoursite.com/2017/08/03/Android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    <id>http://yoursite.com/2017/08/03/Android屏幕适配/</id>
    <published>2017-08-03T12:36:37.000Z</published>
    <updated>2018-06-11T14:40:06.624Z</updated>
    
    <content type="html"><![CDATA[<p>Android的屏幕适配一直以来都在折磨着我们这些开发者，本篇文章将以Google的官方文档为基础，全面而深入的讲解Android屏幕适配的原因、重要概念、解决方案及最佳实践。<a id="more"></a></p><h1 id="Android屏幕适配出现的原因"><a href="#Android屏幕适配出现的原因" class="headerlink" title="Android屏幕适配出现的原因"></a>Android屏幕适配出现的原因</h1><p><a href="http://opensignal.com/reports/2014/android-fragmentation/" target="_blank" rel="noopener">Android的屏幕尺寸很多</a>，为了让我们开发的程序能够比较美观的显示在不同尺寸、分辨率、像素密度(这些概念我会在下面详细讲解)的设备上，那就要在开发的过程中进行处理，至于如何去进行处理，这就是我们今天的主题了。</p><h1 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h1><p>什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？<br>什么是dp、dip、dpi、sp、px？他们之间的关系是什么？<br>什么是mdpi、hdpi、xdpi、xxdpi？如何计算和区分？<br>在下面的内容中我们将介绍这些概念。</p><h4 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h4><p>屏幕尺寸指屏幕的对角线的长度，单位是英寸，1英寸=2.54厘米。<br>比如常见的屏幕尺寸有2.4、2.8、3.5、3.7、4.2、5.0、5.5、6.0等。</p><h4 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h4><p>屏幕分辨率是指在横纵向上的像素点数，单位是px，1px=1个像素点。一般以纵向像素*横向像素，如1960*1080。</p><h4 id="屏幕像素密度"><a href="#屏幕像素密度" class="headerlink" title="屏幕像素密度"></a>屏幕像素密度</h4><p>屏幕像素密度是指每英寸上的像素点数，单位是dpi，即“dot per inch”的缩写。屏幕像素密度与屏幕尺寸和屏幕分辨率有关，在单一变化条件下，屏幕尺寸越小、分辨率越高，像素密度越大，反之越小。</p><h4 id="dp、dip、dpi、sp、px"><a href="#dp、dip、dpi、sp、px" class="headerlink" title="dp、dip、dpi、sp、px"></a>dp、dip、dpi、sp、px</h4><p>px我们应该是比较熟悉的，前面的分辨率就是用的像素为单位，大多数情况下，比如UI设计、Android原生API都会以px作为统一的计量单位，像是获取屏幕宽高等。<br>dip和dp是一个意思，都是Density Independent Pixels的缩写，即密度无关像素，上面我们说过，dpi是屏幕像素密度，假如一英寸里面有160个像素，这个屏幕的像素密度就是160dpi，那么在这种情况下，dp和px如何换算呢？在Android中，规定以160dpi为基准，1dip=1px，如果密度是320dpi，则1dip=2px，以此类推。<br>假如同样都是画一条320px的线，在480*800分辨率手机上显示为2/3屏幕宽度，在320*480的手机上则占满了全屏，如果使用dp为单位，在这两种分辨率下，160dp都显示为屏幕一半的长度。这也是为什么在Android开发中，写布局的时候要尽量使用dp而不是px的原因。<br>而sp，即scale-independent pixels，除了拥有dp的特性，<strong>还会随着系统的字体大小改变而改变，建议在设置字体大小的数值要使用sp作为单位，</strong><a href="https://blog.csdn.net/donkor_/article/details/77680042" target="_blank" rel="noopener">具体可参考这篇文章</a>。<br>sp与dp之间的转换方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int px2dip(Context context, float pxValue) &#123;  </span><br><span class="line">final float scale = context.getResources().getDisplayMetrics().density;  </span><br><span class="line">return (int) (pxValue / scale + 0.5f);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public static int dip2px(Context context, float dipValue) &#123;  </span><br><span class="line">final float scale = context.getResources().getDisplayMetrics().density;  </span><br><span class="line">return (int) (dipValue * scale + 0.5f);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int px2sp(Context context, float pxValue) &#123;  </span><br><span class="line">final float fontScale = context.getResources().getDisplayMetrics().scaledDensity;  </span><br><span class="line">return (int) (pxValue / fontScale + 0.5f);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public static int sp2px(Context context, float spValue) &#123;  </span><br><span class="line">final float fontScale = context.getResources().getDisplayMetrics().scaledDensity;  </span><br><span class="line">return (int) (spValue * fontScale + 0.5f);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="mdpi、hdpi、xdpi、xxdpi"><a href="#mdpi、hdpi、xdpi、xxdpi" class="headerlink" title="mdpi、hdpi、xdpi、xxdpi"></a>mdpi、hdpi、xdpi、xxdpi</h4><p>其实之前还有个ldpi，但是随着移动设备配置的不断升级，这个像素密度的设备已经很罕见了，所在现在适配时不需考虑。<br>mdpi、hdpi、xdpi、xxdpi用来修饰Android中的drawable文件夹及values文件夹，用来区分不同像素密度下的图片和dimen值。<br>那么如何区分呢？Google官方指定按照下列标准进行区分：</p><table><thead><tr><th>名称</th><th style="text-align:center">像素密度范围</th></tr></thead><tbody><tr><td>mdpi</td><td style="text-align:center">120dpi~160dpi</td></tr><tr><td>hdpi</td><td style="text-align:center">160dpi~240dpi</td></tr><tr><td>xhdpi</td><td style="text-align:center">240dpi~320dpi</td></tr><tr><td>xxhdpi</td><td style="text-align:center">320dpi~480dpi</td></tr><tr><td>xxxhdpi</td><td style="text-align:center">480dpi~640dpi</td></tr></tbody></table><p>在进行开发的时候，我们需要把合适大小的图片放在合适的文件夹里面。下面以图标设计为例进行介绍。<br>在设计图标时，对于五种主流的像素密度（MDPI、HDPI、XHDPI、XXHDPI 和 XXXHDPI）应按照 2:3:4:6:8 的比例进行缩放。例如，一个启动图标的尺寸为48x48 dp，这表示在 MDPI 的屏幕上其实际尺寸应为 48x48 px，在 HDPI 的屏幕上其实际大小是 MDPI 的 1.5 倍 (72x72 px)，在 XDPI 的屏幕上其实际大小是 MDPI 的 2 倍 (96x96 px)，依此类推。<br>虽然 Android 也支持低像素密度 (LDPI) 的屏幕，但无需为此费神，系统会自动将 HDPI 尺寸的图标缩小到 1/2 进行匹配。<br>下图为图标的各个屏幕密度的对应尺寸:</p><table><thead><tr><th>屏幕密度</th><th style="text-align:center">图标尺寸</th></tr></thead><tbody><tr><td>mdpi</td><td style="text-align:center">48x48px</td></tr><tr><td>hdpi</td><td style="text-align:center">72x72px</td></tr><tr><td>xhdpi</td><td style="text-align:center">96x96px</td></tr><tr><td>xxhdpi</td><td style="text-align:center">144x144px</td></tr><tr><td>xxxhdpi</td><td style="text-align:center">192x192px</td></tr></tbody></table><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="支持各种屏幕尺寸"><a href="#支持各种屏幕尺寸" class="headerlink" title="支持各种屏幕尺寸"></a>支持各种屏幕尺寸</h2><h4 id="使用wrap-content、match-parent、weight"><a href="#使用wrap-content、match-parent、weight" class="headerlink" title="使用wrap_content、match_parent、weight"></a>使用wrap_content、match_parent、weight</h4><p>为了确保布局的灵活性并适应各种尺寸的屏幕，应尽量使用 “wrap_content” 和 “match_parent” 控制某些视图组件的宽度和高度。使用 “wrap_content”，系统就会将视图的宽度或高度设置成所需的最小尺寸以适应视图中的内容，而 “match_parent”（在低于 API 级别 8 的级别中称为 “fill_parent”）则会展开组件以匹配其父视图的尺寸。<br>weight是线性布局的一个独特的属性，我们可以使用这个属性来按照比例对界面进行分配，完成一些特殊的需求。但是，我们对于这个属性的计算应该如何理解呢？<br>首先，我们将布局设置为线性布局，横向排列，然后放置两个宽度为0dp的按钮，分别设置weight为1和2，我们可以想象到两个按钮按照1：2的宽度比例正常排列了，这也是我们经常使用到的场景。但是假如我们的宽度不是0dp(wrap_content和0dp的效果相同)，而是match_parent呢？<br>在这种情况下，占比和上面正好相反，这是怎么回事呢？说到这里，我们就不得不提一下weight的计算方法了。android:layout_weight的真实含义是:如果View设置了该属性并且有效，那么该 View的宽度等于原有宽度+<strong>剩余空间</strong>的占比。从这个角度我们来解释一下上面的现象。在上面的代码中，我们设置每个Button的宽度都是match_parent，假设屏幕宽度为L，那么每个Button的宽度也应该都为L，剩余宽度就等于L-（L+L）= -L。<br>Button1的weight=1，所以最终宽度为L+1/3*(-L)=2/3L，Button2的计算类似，最终宽度为L+2/3(-L)=1/3L。<br>同时，垂直方向上的结论和水平是完全一样的。虽然说我们演示了match_parent的显示效果，并说明了原因，但是在真正用的时候，我们都是设置某一个属性为0dp，然后按照权重计算所占百分比。</p><h4 id="使用相对布局，禁用绝对布局"><a href="#使用相对布局，禁用绝对布局" class="headerlink" title="使用相对布局，禁用绝对布局"></a>使用相对布局，禁用绝对布局</h4><p>在开发中，我们大部分时候使用的都是线性布局、相对布局和帧布局，绝对布局由于适配性极差，所以极少使用。<br>由于各种布局的特点不一样，所以不能说哪个布局好用，到底应该使用什么布局只能根据实际需求来确定。我们可以使用 LinearLayout 的嵌套实例并结合 “wrap_content” 和 “match_parent”，以便构建相当复杂的布局。不过，我们无法通过 LinearLayout 精确控制子视图的特殊关系；系统会将 LinearLayout 中的视图直接并排列出。<br>如果我们需要将子视图排列出各种效果而不是一条直线，通常更合适的解决方法是使用 RelativeLayout，这样就可以根据各组件之间的特殊关系指定布局了。例如，我们可以将某个子视图对齐到屏幕左侧，同时将另一个视图对齐到屏幕右侧。</p><h2 id="使用限定符"><a href="#使用限定符" class="headerlink" title="使用限定符"></a>使用限定符</h2><h4 id="使用尺寸限定符"><a href="#使用尺寸限定符" class="headerlink" title="使用尺寸限定符"></a>使用尺寸限定符</h4><p>上面所提到的灵活布局或者是相对布局，可以为我们带来的优势就只有这么多了。虽然这些布局可以拉伸组件内外的空间以适应各种屏幕，但它们不一定能为每种屏幕都提供最佳的用户体验。因此，我们的应用不仅仅只实施灵活布局，还应该应针对各种屏幕配置提供一些备用布局。<br>如何做到这一点呢？我们可以通过使用配置限定符，在运行时根据当前的设备配置自动选择合适的资源了，例如根据各种屏幕尺寸选择不同的布局。<br>很多应用会在较大的屏幕上实施“双面板”模式，即在一个面板上显示项目列表，而在另一面板上显示对应内容。平板电脑和电视的屏幕已经大到可以同时容纳这两个面板了，但手机屏幕就需要分别显示。因此，我们可以使用以下文件以便实施这些布局：<br>res/layout/main.xml，单面板（默认）布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:orientation=&quot;vertical&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>res/layout-large/main.xml，双面板布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;400dp&quot;</span><br><span class="line">android:layout_marginRight=&quot;10dp&quot;/&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/article&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>请注意第二种布局名称目录中的 large 限定符。系统会在属于较大屏幕（例如 7 英寸或更大的平板电脑）的设备上选择此布局。系统会在较小的屏幕上选择其他布局（无限定符）。</p><h4 id="使用最小宽度限定符"><a href="#使用最小宽度限定符" class="headerlink" title="使用最小宽度限定符"></a>使用最小宽度限定符</h4><p>在版本低于 3.2 的 Android 设备上，开发人员遇到的问题之一是“较大”屏幕的尺寸范围，该问题会影响戴尔 Streak、早期的 Galaxy Tab 以及大部分 7 英寸平板电脑。即使这些设备的屏幕属于“较大”的尺寸，但很多应用可能会针对此类别中的各种设备显示不同的布局（“较大”的概念不清晰导致的）。这就是 Android 3.2 版在引入其他限定符的同时引入“最小宽度”限定符的原因。<br>最小宽度限定符可让您通过指定某个最小宽度（以 dp 为单位）来定位屏幕。例如，标准 7 英寸平板电脑的最小宽度为 600 dp，因此如果您要在此类屏幕上的用户界面中使用双面板（但在较小的屏幕上只显示列表），您可以使用上文中所述的单面板和双面板这两种布局，但您应使用 sw600dp 指明双面板布局仅适用于最小宽度为 600 dp 的屏幕，而不是使用 large 尺寸限定符。<br>res/layout/main.xml，单面板（默认）布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:orientation=&quot;vertical&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>res/layout-sw600dp/main.xml，双面板布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;400dp&quot;</span><br><span class="line">android:layout_marginRight=&quot;10dp&quot;/&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/article&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>也就是说，对于最小宽度大于等于 600 dp 的设备，系统会选择 layout-sw600dp/main.xml（双面板）布局，否则系统就会选择 layout/main.xml（单面板）布局。<br>但 Android 版本低于 3.2 的设备不支持此技术，原因是这些设备无法将 sw600dp 识别为尺寸限定符，因此我们仍需使用 large 限定符。这样一来，就会有一个名称为 res/layout-large/main.xml 的文件（与 res/layout-sw600dp/main.xml 一样）。但是没有太大关系，我们将马上学习如何避免此类布局文件出现的重复。</p><h4 id="使用布局别名"><a href="#使用布局别名" class="headerlink" title="使用布局别名"></a>使用布局别名</h4><p>最小宽度限定符仅适用于 Android 3.2 及更高版本。因此，如果我们仍需使用与较低版本兼容的概括尺寸范围（小、正常、大和特大）。例如，如果要将用户界面设计成在手机上显示单面板，但在 7 英寸平板电脑、电视和其他较大的设备上显示多面板，那么我们就需要提供以下文件：</p><ul><li>res/layout/main.xml: 单面板布局</li><li>res/layout-large: 多面板布局</li><li>res/layout-sw600dp: 多面板布局</li></ul><p>后两个文件是相同的，因为其中一个用于和 Android 3.2 设备匹配，而另一个则是为使用较低版本 Android 的平板电脑和电视准备的。<br>要避免平板电脑和电视的文件出现重复（以及由此带来的维护问题），您可以使用别名文件。例如，您可以定义以下布局：</p><ul><li>res/layout/main.xml，单面板布局</li><li>res/layout/main_twopanes.xml，双面板布局</li></ul><p>然后添加这两个文件：<br>res/values-large/layout.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>res/values-sw600dp/layout.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>后两个文件的内容相同，但它们并未实际定义布局。它们只是将 main 设置成了 main_twopanes 的别名。由于这些文件包含 large 和 sw600dp 选择器，因此无论 Android 版本如何，系统都会将这些文件应用到平板电脑和电视上（版本低于 3.2 的平板电脑和电视会匹配 large，版本高于 3.2 的平板电脑和电视则会匹配 sw600dp）。</p><h4 id="使用屏幕方向限定符"><a href="#使用屏幕方向限定符" class="headerlink" title="使用屏幕方向限定符"></a>使用屏幕方向限定符</h4><p>某些布局会同时支持横向模式和纵向模式，但我们可以通过调整优化其中大部分布局的效果。在新闻阅读器示例应用中，每种屏幕尺寸和屏幕方向下的布局行为方式如下所示：</p><ul><li>小屏幕，纵向：单面板，带徽标</li><li>小屏幕，横向：单面板，带徽标</li><li>7 英寸平板电脑，纵向：单面板，带操作栏</li><li>7 英寸平板电脑，横向：双面板，宽，带操作栏</li><li>10 英寸平板电脑，纵向：双面板，窄，带操作栏</li><li>10 英寸平板电脑，横向：双面板，宽，带操作栏</li><li>电视，横向：双面板，宽，带操作栏</li></ul><p>因此，这些布局中的每一种都定义在了 res/layout/ 目录下的某个 XML 文件中。为了继续将每个布局分配给各种屏幕配置，该应用会使用布局别名将两者相匹配：<br>res/layout/onepane.xml:(单面板)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:orientation=&quot;vertical&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>res/layout/onepane_with_bar.xml:(单面板带操作栏)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:orientation=&quot;vertical&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">&lt;LinearLayout android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:id=&quot;@+id/linearLayout1&quot;  </span><br><span class="line">android:gravity=&quot;center&quot;</span><br><span class="line">android:layout_height=&quot;50dp&quot;&gt;</span><br><span class="line">&lt;ImageView android:id=&quot;@+id/imageView1&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:src=&quot;@drawable/logo&quot;</span><br><span class="line">android:paddingRight=&quot;30dp&quot;</span><br><span class="line">android:layout_gravity=&quot;left&quot;</span><br><span class="line">android:layout_weight=&quot;0&quot; /&gt;</span><br><span class="line">&lt;View android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:id=&quot;@+id/view1&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_weight=&quot;1&quot; /&gt;</span><br><span class="line">&lt;Button android:id=&quot;@+id/categorybutton&quot;</span><br><span class="line">android:background=&quot;@drawable/button_bg&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;</span><br><span class="line">android:layout_weight=&quot;0&quot;</span><br><span class="line">android:layout_width=&quot;120dp&quot;</span><br><span class="line">style=&quot;@style/CategoryButtonStyle&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>res/layout/twopanes.xml:(双面板，宽布局)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;400dp&quot;</span><br><span class="line">android:layout_marginRight=&quot;10dp&quot;/&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/article&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>res/layout/twopanes_narrow.xml:(双面板，窄布局)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;200dp&quot;</span><br><span class="line">android:layout_marginRight=&quot;10dp&quot;/&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/article&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>既然我们已定义了所有可能的布局，那就只需使用配置限定符将正确的布局映射到各种配置即可。<br>现在只需使用布局别名技术即可做到这一点：<br>res/values/layouts.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane_with_bar&lt;/item&gt;</span><br><span class="line">&lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>res/values-sw600dp-land/layouts.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes&lt;/item&gt;</span><br><span class="line">&lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>res/values-sw600dp-port/layouts.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane&lt;/item&gt;</span><br><span class="line">&lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>res/values-large-land/layouts.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes&lt;/item&gt;</span><br><span class="line">&lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>res/values-large-port/layouts.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes_narrow&lt;/item&gt;</span><br><span class="line">&lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><h2 id="使用自动拉伸位图-9图"><a href="#使用自动拉伸位图-9图" class="headerlink" title="使用自动拉伸位图(.9图)"></a>使用自动拉伸位图(.9图)</h2><p>在Android的设计过程中，为了适配不同的手机分辨率，图片大多需要拉伸或者压缩，这样就出现了可以任意调整大小的一种图片格式“.9.png”。<a href="http://blog.csdn.net/lastwarmth/article/details/49991445" target="_blank" rel="noopener">详细教程请参考这篇文章</a>。</p><h2 id="支持各种屏幕密度"><a href="#支持各种屏幕密度" class="headerlink" title="支持各种屏幕密度"></a>支持各种屏幕密度</h2><h4 id="使用密度无关像素"><a href="#使用密度无关像素" class="headerlink" title="使用密度无关像素"></a>使用密度无关像素</h4><p>由于各种屏幕的像素密度都有所不同，因此相同数量的像素在不同设备上的实际大小也有所差异，这样使用像素定义布局尺寸就会产生问题。因此，请务必使用 dp 或 sp 单位指定尺寸。<br>例如，请使用 dp（而非 px）指定两个视图间的间距：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:text=&quot;@string/clickme&quot;</span><br><span class="line">android:layout_marginTop=&quot;20dp&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>请务必使用 sp 指定文字大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:textSize=&quot;20sp&quot; /&gt;</span><br></pre></td></tr></table></figure><p>除了介绍这些最基础的知识之外，我们下面再来讨论一下另外一个问题。<br>经过上面的介绍，我们都清楚，为了能够规避不同像素密度的陷阱，Google推荐使用dp来代替px作为控件长度的度量单位，但是我们来看下面的一个场景。<br>假如我们以Nexus5作为书写代码时查看效果的测试机型，Nexus5的总宽度为360dp，我们现在需要在水平方向上放置两个按钮，一个是150dp左对齐，另外一个是200dp右对齐，最后中间留有10dp间隔。<br>但是如果在Nexus S或者是Nexus One运行，两个按钮就发生了重叠。我们都已经用了dp了，为什么会出现这种情况呢？<br>虽然说dp可以去除不同像素密度的问题，使得1dp在不同像素密度上面的物理长度基本相同(如果xdpi，ydpi与densityDpi不一样，则物理长度会有偏差)，但是还是由于Android屏幕设备的多样性，如果使用dp来作为度量单位，并不是所有的屏幕的宽度都是相同的dp长度，比如说，Nexus S和Nexus One属于hdpi，屏幕宽度是320dp，而Nexus 5属于xxhdpi，屏幕宽度是360dp，Galaxy Nexus属于xhdpi，屏幕宽度是384dp，Nexus 6 属于xxxhdpi，屏幕宽度是410dp。所以说，光Google自己一家的产品就已经有这么多的标准，而且屏幕宽度和像素密度没有任何关联关系，即使我们使用dp，在320dp宽度的设备和410dp的设备上，还是会有90dp的差别。<br>所以总结的结果是，<strong>我们要尽量使用match_parent和wrap_content，尽可能少的用dp来指定控件的具体长宽，再结合上权重，大部分的情况我们都是可以做到适配的。</strong>如果遇到上述情况的话，这里有一种方法就是，我们假设手机屏幕的宽度都是320某单位，那么我们将一个屏幕宽度的总像素数平均分成320份，每一份对应具体的像素就可以了。<a href="http://blog.csdn.net/lmj623565791/article/details/45460089" target="_blank" rel="noopener">具体介绍可以参考这篇文章。</a></p><h4 id="提供备用位图"><a href="#提供备用位图" class="headerlink" title="提供备用位图"></a>提供备用位图</h4><p>由于 Android 可在具有各种屏幕密度的设备上运行，因此我们提供的位图资源应始终可以满足各类普遍密度范围的要求：低密度、中等密度、高密度以及超高密度。这将有助于我们的图片在所有屏幕密度上都能得到出色的质量和效果。<br>要生成这些图片，我们应先提取矢量格式的原始资源，然后根据以下尺寸范围针对各密度生成相应的图片。</p><ul><li>xhdpi：2.0</li><li>hdpi：1.5</li><li>mdpi：1.0（最低要求）</li><li>ldpi：0.75</li></ul><p>也就是说，如果我们为 xhdpi 设备生成了 200x200 px尺寸的图片，就应该使用同一资源为 hdpi、mdpi 和 ldpi 设备分别生成 150x150、100x100 和 75x75 尺寸的图片。然后，将生成的图片文件放在 res/ 下的相应子目录中(mdpi、hdpi、xhdpi、xxhdpi)，系统就会根据运行您应用的设备的屏幕密度自动选择合适的图片。</p><blockquote><p><strong>注意：</strong><br>实际开发的过程中，通常都会做三套配图，对应着drawable-hdpi、drawable-xhdpi、drawable-xxhdpi三个文件夹。当然时间赶的话，做一套也是可以的。具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650235875&amp;idx=1&amp;sn=add1f85f961b2e70164900cc287b1e66&amp;scene=38#wechat_redirect" target="_blank" rel="noopener">王月半子的文章</a>和<a href="http://www.imooc.com/article/7265" target="_blank" rel="noopener">慕课网的这篇文章</a>，对于慕课网的这篇，其中对资源的加载策略做了详细的讲解，值得一看。</p></blockquote><p>这样一来，只要我们引用 @drawable/id，系统都能根据相应屏幕的 dpi 选取合适的位图。还记得我们上面提到的图标设计尺寸吗？和这个其实是一个意思。但是还有个问题需要注意下，<strong>如果是.9图或者是不需要多个分辨率的图片，就放在drawable文件夹即可。</strong></p><blockquote><p>drawable对应的dpi是160dpi，相当于drawable-mdpi，但是不会作为一个特定dpi的文件夹使用。它的作用是存放一些xml文件、.9图以及一些不需要适配多个分辨率的图片。</p></blockquote><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><h2 id="关于高清设计图尺寸"><a href="#关于高清设计图尺寸" class="headerlink" title="关于高清设计图尺寸"></a>关于高清设计图尺寸</h2><p>Google官方给出的高清设计图尺寸有两种方案，一种是以mdpi设计，然后对应放大得到更高分辨率的图片，另外一种则是以高分辨率作为设计大小，然后按照倍数对应缩小到小分辨率的图片。<br>根据经验，我更推荐第二种方法，因为小分辨率在生成高分辨率图片的时候，会出现像素丢失，我不知道是不是有方法可以阻止这种情况发生。<br>而分辨率可以以1280*720或者是1960*1080作为主要分辨率进行设计。这里有一篇关于<a href="https://www.25xt.com/android" target="_blank" rel="noopener">UI设计的规范说明</a>,UI设计时可以参考。</p><h2 id="ImageView的ScaleType属性"><a href="#ImageView的ScaleType属性" class="headerlink" title="ImageView的ScaleType属性"></a>ImageView的ScaleType属性</h2><p>设置不同的ScaleType会得到不同的显示效果，一般情况下，设置为centerCrop能获得较好的适配效果。</p><h2 id="动态设置"><a href="#动态设置" class="headerlink" title="动态设置"></a>动态设置</h2><p>有一些情况下，我们需要动态的设置控件大小或者是位置，比如说popwindow的显示位置和偏移量等，这个时候我们可以动态的获取当前的屏幕属性，然后设置合适的数值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ScreenSizeUtil &#123;</span><br><span class="line"></span><br><span class="line">public static int getScreenWidth(Activity activity) &#123;</span><br><span class="line">return activity.getWindowManager().getDefaultDisplay().getWidth();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int getScreenHeight(Activity activity) &#123;</span><br><span class="line">return activity.getWindowManager().getDefaultDisplay().getHeight();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考资料</strong><br><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/45419023" target="_blank" rel="noopener">Android屏幕适配全攻略(最权威的官方适配指导)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android的屏幕适配一直以来都在折磨着我们这些开发者，本篇文章将以Google的官方文档为基础，全面而深入的讲解Android屏幕适配的原因、重要概念、解决方案及最佳实践。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="屏幕适配" scheme="http://yoursite.com/tags/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android软键盘</title>
    <link href="http://yoursite.com/2017/07/01/Android%E8%BD%AF%E9%94%AE%E7%9B%98/"/>
    <id>http://yoursite.com/2017/07/01/Android软键盘/</id>
    <published>2017-07-01T08:45:15.000Z</published>
    <updated>2018-05-12T13:02:15.298Z</updated>
    
    <content type="html"><![CDATA[<p>说起Android软键盘，这里遇到的坑多数就是对它理解不够全面导致的，所以决定好好总结一下它。在避免自己二次掉坑的同时，如果能帮助到在这个知识区正疑惑的你，那就太好了。<a id="more"></a>本篇的讲解将分以下几个主题：<br>1、操作软键盘<br>2、监听键盘的弹起与隐藏<br>3、如何避免键盘遮挡输入框</p><h1 id="操作软键盘"><a href="#操作软键盘" class="headerlink" title="操作软键盘"></a>操作软键盘</h1><p>想要操作软键盘，需要使用到 InputMethodManager ，它是一个系统服务，可以使用 Context.getSystemService() 获取到它。</p><h4 id="显示软键盘"><a href="#显示软键盘" class="headerlink" title="显示软键盘"></a>显示软键盘</h4><p>在 InputMethodManager中，有两个方法showSoftInput()和showSoftInputFromInputMethod()，而实际上，只有showSoftInput()是有效的。<br><img src="/2017/07/01/Android软键盘/1.jpeg"><br>这里我们只需要传递两个参数。它首先需要一个View ，使用软键盘就是为了输入，而输入就需要有接收输入内容的View ，这里接收输入的View ，最好是一个EditText（但这不是必须的）。<br>而第二个参数flags就是个标志位，从上面截图的方法签名上的文档上可以看到，它接收0或者SHOW_INPYT_IMPLICIT 两个参数，但是实际上，它有第三个参数，另外一个是SHOW_FORCED。一般没有特别需要的话，我们直接传递0就好了(实际上SHOW_INPYT_IMPLICIT、SHOW_FORCED并不影响显示，只是在隐藏的时候，会有一些限制。而且我们一般的话，不管显示或者隐藏都将flag设置为0，特殊情况遇到再做分析)。<br>现在，简单总结一下调用showSoftInput()会生效的关键点：<br>1、第一个参数，最好是EditText或者它的子类。<br>考虑到软键盘就是为了输入，EditText就是一个接收输入的控件。而这不是绝对的，如果不是一个EditText ，就必须要求这个View有两个属性，分别是：android:focusable=”true” 和android:focusableInTouchMode=”true”。<br>2、第一个参数，必须是可获取焦点的，并且当前已经获取到焦点。<br>EditText默认是允许获取焦点的，但是假如布局中，存在多个可获取焦点的控件，就需要提前让我们传递进去的View获取到焦点。获取焦点可以使用requestFocus()方法。<br>3、布局必须加载完成。<br>在onCreate()中，如果立即调用showSoftInput()是不会生效的。想要在页面一启动的时候就弹出键盘，可以在Activity上，设置 android:windowSoftInputMode属性来完成，或者做一个延迟加载，View.postDelayed()也是一个解决方案。<br>所以最终，完整的显示软键盘的代码就如下所示了。<br><img src="/2017/07/01/Android软键盘/2.jpeg"></p><h4 id="隐藏软键盘"><a href="#隐藏软键盘" class="headerlink" title="隐藏软键盘"></a>隐藏软键盘</h4><p>虽然showSoftInput()方法是有效的，但是想要隐藏软键盘，就没有提供对应的hideSoftInput()方法，但是却有一个hideSoftInputFromWindow()方法，可以用来隐藏软键盘。<br>先来看看这个方法的签名，它同样有两个方法可以调用。<br><img src="/2017/07/01/Android软键盘/3.jpeg"><br>它接收两个参数，第一个参数是一个IBinder ，可以直接传递一个 View.getWindowToken()的windowToken对象就可以了。而第二个参数，就是隐藏软键盘的标志位，如果没有特殊要求的话，直接传递0就好了。</p><blockquote><p><strong>注意：</strong>这里虽然原则上需要传递一个之前弹出键盘传递的时候，传递的View的windowToken，但是实际情况是你只需要传递一个存在于当前布局ViewTree中，随意一个View的windowToken就可以了。</p></blockquote><p>最终隐藏软件的代码就是这样的。<br><img src="/2017/07/01/Android软键盘/4.jpeg"></p><h4 id="切换键盘的弹出和隐藏"><a href="#切换键盘的弹出和隐藏" class="headerlink" title="切换键盘的弹出和隐藏"></a>切换键盘的弹出和隐藏</h4><p>在InputMethodManager中，还提供了一个toggleSoftInput()方法，如同它的名字一样，它可以让软键盘在显示和隐藏之间切换。<br><img src="/2017/07/01/Android软键盘/5.jpeg"><br>该方法，接收两个flags ，分别是控制show和hide时候的标识，它们的含义和前面介绍的showSoftInput()和hideSoftInputFromWindow()一致，所以没有特殊要求，直接传递0就好了。<br>toggleSoftInput()方法不要求传递一个View或者windowToken，所以它并没有showSoftInput()中的一些限制，但是依然还有需要在布局绘制完成之后调用才会有效果。<br><img src="/2017/07/01/Android软键盘/6.jpeg"><br>虽然这个方法，限制很少，但是我们基本上不会使用它。主要原因在于，它是一个开关的方法，会根据当前的状态做相反的操作。这就导致很多时候，我们在代码中，无法直接根据InputMethodManager提供的方法判断当前软键盘的显示状态，这样也就无法确定调用它的时候的效果了。</p><h1 id="监听键盘的弹起与隐藏"><a href="#监听键盘的弹起与隐藏" class="headerlink" title="监听键盘的弹起与隐藏"></a>监听键盘的弹起与隐藏</h1><p>如果想要监听键盘的弹出和收起，可以使用<code>ViewTreeObserver.OnGlobalLayoutListener</code>这个监听，来监听布局的调整，从而判断出键盘的弹出和隐藏。下面是一个使用ViewTreeObserver.OnGlobalLayoutListener后获取屏幕中各个类型高度的例子，请注意代码中的注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getDecorView().getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onGlobalLayout() &#123;</span><br><span class="line">Log.d(&quot;sss_main&quot;, &quot;root.getHeight(): &quot; + root.getHeight());//当前所引用视图的高度</span><br><span class="line">Log.d(&quot;sss_main&quot;, &quot;root.getRootView().getHeight(): &quot; + root.getRootView().getHeight());//屏幕高度</span><br><span class="line">Log.d(&quot;sss_main&quot;, &quot;getWindow().getDecorView(): &quot; + getWindow().getDecorView().getHeight());//屏幕高度</span><br><span class="line">Rect r = new Rect();</span><br><span class="line">getWindow().getDecorView().getWindowVisibleDisplayFrame(r);</span><br><span class="line">Log.d(&quot;sss_main&quot;, &quot;r.top: &quot; + r.top);//状态栏高度</span><br><span class="line">Log.d(&quot;sss_main&quot;, &quot;r.bottom-r.top: &quot; + (r.bottom - r.top));//用户界面的可视高度（除去状态栏和底部导航）</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>代码中<code>r.bottom - r.top</code>代表了除去状态栏、底部导航栏后，手机屏幕剩余可视高度。注意，这个剩余可视高度也不包括输入法弹窗的高度（如果屏幕中有输入法弹窗的话）。有了以上的基础，我们就可以通过<code>getWindow().getDecorView().getHeight()-r.bottom&gt;100?键盘弹出：键盘隐藏</code>来判断键盘是否隐藏了。</p><blockquote><p><strong>注意：</strong>为什么要大于100呢？因为如果手机具备底部导航区域的话，要排除这个值的干扰。当然了，直接默认底部导航区域高度为100肯定是不精确的，实际应用中我们应该获取到真实的底部导航区域高度，具体如何获取底部导航区域高度可以<a href="http://blog.csdn.net/u012764110/article/details/49783465" target="_blank" rel="noopener">参考这篇文章</a>。</p></blockquote><h1 id="如何避免键盘遮挡输入框"><a href="#如何避免键盘遮挡输入框" class="headerlink" title="如何避免键盘遮挡输入框"></a>如何避免键盘遮挡输入框</h1><p>在开发中，经常会遇到键盘挡住输入框的情况，比如登录界面或注册界面，弹出的软键盘把登录或注册按钮挡住了，用户必须把软键盘收起，才能点击相应按钮，这样的用户体验非常不好。下面对几种在开发中常用的避免键盘遮挡输入框的方法进行总结。</p><h4 id="方法一：windowSoftInputMode-adjustResize和adjustPan"><a href="#方法一：windowSoftInputMode-adjustResize和adjustPan" class="headerlink" title="方法一：windowSoftInputMode:adjustResize和adjustPan"></a>方法一：windowSoftInputMode:adjustResize和adjustPan</h4><p>主要实现方法：在 AndroidManifest.xml 对应的Activity里添加 android:windowSoftInputMode=”adjustPan” 或是 android:windowSoftInputMode=”adjustResize”属性<br>这两种属性的区别，官方的解释是：<br><img src="/2017/07/01/Android软键盘/7.png"><br>这两个属性作用都是为了调整界面使键盘不挡住输入框,这里对这两种属性使用场景、优缺点、注意事项进行了全方面总结。对于<code>fitsystemwindows</code>还比较懵逼的你，可以参考<a href="http://blog.csdn.net/u012885461/article/details/51068553" target="_blank" rel="noopener">这篇文章</a>。<br><img src="/2017/07/01/Android软键盘/8.jpg"><br>最后附一张官方的截图。<br><img src="/2017/07/01/Android软键盘/9.jpg" title="该属性是在API级别3引入的。"></p><blockquote><p><strong>插播知识：</strong><br>这里再提一下clipToPadding和clipChildren这两个属性吧，虽然和本篇没有关系但是同样是有一定概率出现的，所以要讲一下。clipToPadding就是说控件的绘制区域是否在padding里面的，true的情况下如果你设置了padding那么绘制的区域就往里缩，clipToPadding主要应用在listview头部和尾部设置padding后希望可以在滑动item时能滑动到padding区域。clipChildren表示是否限制子View在所属父View的范围内，我们将其值设置为false后那么当子控件的高度高于父控件时也会完全显示,而不会被压缩。注意clipChildren一定是在布局文件的根节点设置，否则不起作用,具体请看<a href="http://blog.csdn.net/flymoon1201/article/details/44646473" target="_blank" rel="noopener">这篇文章</a>。</p></blockquote><h4 id="方法二：当键盘弹起时，让界面整体上移；键盘收起，让界面整体下移"><a href="#方法二：当键盘弹起时，让界面整体上移；键盘收起，让界面整体下移" class="headerlink" title="方法二：当键盘弹起时，让界面整体上移；键盘收起，让界面整体下移"></a>方法二：当键盘弹起时，让界面整体上移；键盘收起，让界面整体下移</h4><p>使用场景：针对界面全屏模式，输入框不会被键盘遮挡。主要用于一些登录界面，或是需要把界面整体都顶上去的场景。</p><h5 id="1､主要实现步骤"><a href="#1､主要实现步骤" class="headerlink" title="1､主要实现步骤"></a>1､主要实现步骤</h5><p>(1). 获取Activity布局xml的最外层控件，如xml文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;</span><br><span class="line">android:id=&quot;@+id/main&quot;</span><br><span class="line">tools:context=&quot;com.example.liubin1.softkeyboardhelper.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;EditText</span><br><span class="line">android:id=&quot;@+id/name&quot;</span><br><span class="line">android:hint=&quot;请输入用户名：&quot;</span><br><span class="line">android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;50dp&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;EditText</span><br><span class="line">android:id=&quot;@+id/pas&quot;</span><br><span class="line">android:layout_below=&quot;@id/name&quot;</span><br><span class="line">android:hint=&quot;请输入密码：&quot;</span><br><span class="line">android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;50dp&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">android:id=&quot;@+id/login_btn&quot;</span><br><span class="line">android:layout_below=&quot;@id/rpas&quot;</span><br><span class="line">android:layout_centerHorizontal=&quot;true&quot;</span><br><span class="line">android:text=&quot;登录&quot;</span><br><span class="line">android:layout_width=&quot;180dp&quot;</span><br><span class="line">android:layout_height=&quot;50dp&quot; /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure></p><p>先获取到最外层控件:<br>RelativeLayout main = (RelativeLayout) findViewById(R.id.main);<br>(2). 获取到最后一个控件，如上面的xml文件，最后一个控件是Button:<br>Button login_btn = (Button) findViewById(R.id.login_btn);<br>(3). 给最外层控件和最后一个控件添加监听事件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//在Activity的onCreate里添加如下方法</span><br><span class="line">addLayoutListener(main,login_btn);</span><br><span class="line">/**   </span><br><span class="line">* addLayoutListener方法如下</span><br><span class="line">* @param main 根布局</span><br><span class="line">* @param scroll 需要显示的最下方View</span><br><span class="line">*/</span><br><span class="line">public void addLayoutListener(final View main, final View scroll) &#123;</span><br><span class="line">main.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onGlobalLayout() &#123;</span><br><span class="line">Rect rect = new Rect();</span><br><span class="line">//1、获取main在窗体的可视区域</span><br><span class="line">main.getWindowVisibleDisplayFrame(rect);</span><br><span class="line">//2、获取main在窗体的不可视区域高度，在键盘没有弹起时，main.getRootView().getHeight()调节度应该和rect.bottom高度一样</span><br><span class="line">int mainInvisibleHeight = main.getRootView().getHeight() - rect.bottom;</span><br><span class="line">int screenHeight = main.getRootView().getHeight();//屏幕高度</span><br><span class="line">//3、不可见区域大于屏幕本身高度的1/4：说明键盘弹起了</span><br><span class="line">if (mainInvisibleHeight &gt; screenHeight / 4) &#123;</span><br><span class="line">int[] location = new int[2];</span><br><span class="line">scroll.getLocationInWindow(location);</span><br><span class="line">// 4､获取Scroll的窗体坐标，算出main需要滚动的高度</span><br><span class="line">int srollHeight = (location[1] + scroll.getHeight()) - rect.bottom;</span><br><span class="line">//5､让界面整体上移键盘的高度</span><br><span class="line">main.scrollTo(0, srollHeight);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//3、不可见区域小于屏幕高度1/4时,说明键盘隐藏了，把界面下移，移回到原有高度</span><br><span class="line">main.scrollTo(0, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2､实现原理"><a href="#2､实现原理" class="headerlink" title="2､实现原理"></a>2､实现原理</h5><p>此方法通过监听 Activity 最外层布局控件来检测软键盘是否弹出，然后去手动调用控件的scrollTo方法达到调整布局目的。</p><hr><p><strong>参考资料</strong><br>1.<a href="https://segmentfault.com/a/1190000012279204" target="_blank" rel="noopener">Android软键盘的显示与隐藏</a><br>2.<a href="https://blog.csdn.net/smileiam/article/details/69055963" target="_blank" rel="noopener">Android各种键盘挡住输入框解决办法</a><br>3.<a href="https://developer.android.com/guide/topics/manifest/activity-element.html?hl=zh-cn" target="_blank" rel="noopener">API指南</a><br>4.<a href="https://stackoverflow.com/questions/2150078/how-to-check-visibility-of-software-keyboard-in-android" target="_blank" rel="noopener">stackoverflow:监听软件的弹出与隐藏</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起Android软键盘，这里遇到的坑多数就是对它理解不够全面导致的，所以决定好好总结一下它。在避免自己二次掉坑的同时，如果能帮助到在这个知识区正疑惑的你，那就太好了。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="软键盘" scheme="http://yoursite.com/tags/%E8%BD%AF%E9%94%AE%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Android中退出APP的解决方案</title>
    <link href="http://yoursite.com/2017/06/20/Android%E4%B8%AD%E9%80%80%E5%87%BAAPP%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/06/20/Android中退出APP的解决方案/</id>
    <published>2017-06-20T03:23:06.000Z</published>
    <updated>2018-03-06T03:28:59.662Z</updated>
    
    <content type="html"><![CDATA[<p>对于单一Activity的应用来说，退出很简单，直接调用<code>finish（）</code>方法即可。但是对于多个activity的应用来说，当打开多个activity后，想再最后一个activity中直接退出app，这就需要每个activity都关掉，然后退出。下面介绍四种安全退出已调用多个activity的application的方法。<a id="more"></a></p><h1 id="抛出异常退出"><a href="#抛出异常退出" class="headerlink" title="抛出异常退出"></a>抛出异常退出</h1><p>该方法通过抛出异常，使程序强制关闭。但是，这种方法会让程序弹出Force close的弹窗，用户体验很差。</p><h1 id="记录打开的activity并逐一关闭"><a href="#记录打开的activity并逐一关闭" class="headerlink" title="记录打开的activity并逐一关闭"></a>记录打开的activity并逐一关闭</h1><p>这种方法的操作需要抽取到Activity的父类中进行，在父类的<code>onCreate()</code>中将每个打开的Activity加载到一个activity的集合中。当退出时，需要在父类定义一个killAll()方法，在该方法复制一个Activity的集合，然后遍历复制后的集合关闭所有打开的Activity。</p><h1 id="发送特定广播实现安全退出（推荐）"><a href="#发送特定广播实现安全退出（推荐）" class="headerlink" title="发送特定广播实现安全退出（推荐）"></a>发送特定广播实现安全退出（推荐）</h1><p>在需要结束应用时，发送一个特定广播，每个Activity收到广播后，关闭即可。在这个过程中，注册广播接受者的逻辑可以抽取到父类中实现，需要安全退出时，发送的action为注册时指定的action即可，所有开启的activity都注册有能够响应改action的广播接受者，广播接受者接受到此类广播后，将直接调用<code>finish（）</code>方法，关闭当前Activity。</p><h1 id="递归退出每个Activity"><a href="#递归退出每个Activity" class="headerlink" title="递归退出每个Activity"></a>递归退出每个Activity</h1><p>当需要打开新的activity时，使用<code>startActivityForResult()</code>方法打开Activity,需要退出整个应用时，自定义一个标志退出的Flag，在各个activity的<code>onActivityResult</code>方法中处理该Flay，来实现递归关闭。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于单一Activity的应用来说，退出很简单，直接调用&lt;code&gt;finish（）&lt;/code&gt;方法即可。但是对于多个activity的应用来说，当打开多个activity后，想再最后一个activity中直接退出app，这就需要每个activity都关掉，然后退出。下面介绍四种安全退出已调用多个activity的application的方法。
    
    </summary>
    
      <category term="四大组件" scheme="http://yoursite.com/categories/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="退出APP" scheme="http://yoursite.com/tags/%E9%80%80%E5%87%BAAPP/"/>
    
      <category term="广播" scheme="http://yoursite.com/tags/%E5%B9%BF%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>GlobalDialog框架使用教程</title>
    <link href="http://yoursite.com/2017/06/10/GlobalDialog%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/06/10/GlobalDialog框架使用教程/</id>
    <published>2017-06-10T00:37:54.000Z</published>
    <updated>2018-05-12T13:06:36.063Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/06/10/GlobalDialog框架使用教程/1.jpg" title="请勿模仿。"><p>GlobalDialog是由<a href="http://italkyou.bmob.site" target="_blank" rel="noopener">ITalk应用</a>开源的一款全局对话框库。相比于Android原生对话框的繁琐配置，GlobalDialog的优势在于能够快速实现<strong>全局对话框</strong>的功能（通知账号下线、通知账号异常等）。进一步了解，请访问笔者的<a href="https://github.com/tangxianming/global-dialog" target="_blank" rel="noopener">Github</a>。<br><a id="more"></a> </p><p>#集成方法<br>在Module的build.gradle文件中添加如下依赖即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.txm.topcodes.globaldialog:globaldialog:0.1.6&apos;</span><br></pre></td></tr></table></figure></p><p>#调用方式<br>常规方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new GlobalDialog.Builder()</span><br><span class="line">.setContext(context) </span><br><span class="line">.setDescription(&quot;hello world&quot;) //弹出框的提示信息。</span><br><span class="line">.setStyle(GlobalDialog.Style.SingleAlert) //弹窗的样式。有DoubleAlert、SingleAlert两种，默认为后者。</span><br><span class="line">.setForce(ture) //设置弹框销毁的策略。默认为true。</span><br><span class="line">.setDialogClickListener(new OnDialogClickListener() &#123; //设置回调，也可以不设置。</span><br><span class="line">@Override</span><br><span class="line">public void onSure() &#123;</span><br><span class="line">super.onSure();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).build().show();</span><br></pre></td></tr></table></figure></p><p>精简方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new GlobalDialog.Builder()</span><br><span class="line">.setContext(context) </span><br><span class="line">.setDescription(&quot;hello world&quot;) </span><br><span class="line">.build().show();</span><br></pre></td></tr></table></figure></p><p>#FAQ</p><hr><p><strong>我发现GlobalDialog还存在BUG？</strong><br>GlobalDialog是一个完全开源的框架，如果您在使用过程中发现问题，欢迎在笔者的GitHub创建一个<a href="https://github.com/tangxianming/global-dialog/issues" target="_blank" rel="noopener">Issue</a>。</p><p><strong>我是Eclipse用户，可以使用GlobalDialog么？</strong><br>不可以。</p><p><strong>我在Android studio中链接GlobalDialog库失败了？</strong><br>确保您的工程使用的远程仓库为jcenter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">jcenter()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/06/10/GlobalDialog框架使用教程/1.jpg&quot; title=&quot;请勿模仿。&quot;&gt;
&lt;p&gt;GlobalDialog是由&lt;a href=&quot;http://italkyou.bmob.site&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ITalk应用&lt;/a&gt;开源的一款全局对话框库。相比于Android原生对话框的繁琐配置，GlobalDialog的优势在于能够快速实现&lt;strong&gt;全局对话框&lt;/strong&gt;的功能（通知账号下线、通知账号异常等）。进一步了解，请访问笔者的&lt;a href=&quot;https://github.com/tangxianming/global-dialog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="我的Android框架" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84Android%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="View" scheme="http://yoursite.com/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Android实现阴影效果的三种方式</title>
    <link href="http://yoursite.com/2017/05/20/Android%E5%AE%9E%E7%8E%B0%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/05/20/Android实现阴影效果的三种方式/</id>
    <published>2017-05-20T09:27:38.000Z</published>
    <updated>2018-05-12T13:17:25.273Z</updated>
    
    <content type="html"><![CDATA[<p>实现Android阴影共有三种方式：使用.9图（略）、设置视图的高度、在layer-list资源文件中模拟阴影效果，本篇文章将对后两种方式做介绍。<a id="more"></a></p><h1 id="视图高度（Z值）实现阴影"><a href="#视图高度（Z值）实现阴影" class="headerlink" title="视图高度（Z值）实现阴影"></a>视图高度（Z值）实现阴影</h1><p>Material Design为UI元素引入了高度（Z值）概念，拥有较高 Z 值的视图将投射更大且更柔和的阴影，并将挡住拥有较低Z值的视图，不过视图的Z值并不影响视图的大小。阴影的效果是由被提升视图的父项所提供的，因此阴影裁剪也是受父视图影响的，<strong>值得注意的是，如果父视图没有提供额外的空间给被提升视图，则阴影效果不会被展现。</strong></p><h4 id="指定视图高度"><a href="#指定视图高度" class="headerlink" title="指定视图高度"></a>指定视图高度</h4><p>视图的Z值包含两个组件：</p><ul><li>高度：静态组件。</li><li>转换：用于动画的动态组件。</li></ul><p>Z = elevation + translationZ<br><img src="/2017/05/20/Android实现阴影效果的三种方式/1.png" title="不同视图高度的阴影。"><br>如果要在布局定义中设置视图的高度，请使用 <code>android:elevation</code> 属性。如果要在Activity的代码中设置视图高度，请使用 <code>View.setElevation()</code> 方法。<br>如果要设置视图转换，请使用 <code>View.setTranslationZ()</code> 方法，同时，该方法可以通过<strong>属性动画</strong>为视图高度添加动画。</p><h4 id="自定义视图阴影"><a href="#自定义视图阴影" class="headerlink" title="自定义视图阴影"></a>自定义视图阴影</h4><p>视图的背景将决定其阴影的默认形状，下面举一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">android:id=&quot;@+id/myview&quot;</span><br><span class="line">...</span><br><span class="line">android:elevation=&quot;2dp&quot;</span><br><span class="line">android:background=&quot;@drawable/myrect&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>背景被定义为一个拥有圆角的矩形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- res/drawable/myrect.xml --&gt;</span><br><span class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:shape=&quot;rectangle&quot;&gt;</span><br><span class="line">&lt;solid android:color=&quot;#42000000&quot; /&gt;</span><br><span class="line">&lt;corners android:radius=&quot;5dp&quot; /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure></p><p>视图将投射一个带有圆角的阴影，因为背景将定义视图的轮廓。 如果提供一个自定义轮廓，则此轮廓将替换视图阴影的默认形状。</p><h1 id="layer-list模拟阴影效果"><a href="#layer-list模拟阴影效果" class="headerlink" title="layer-list模拟阴影效果"></a>layer-list模拟阴影效果</h1><p>使用layer-list可以将多个drawable按照顺序层叠在一起显示，默认情况下，所有的item中的drawable都会自动根据所依附view的大小而进行缩放，layer-list中的item是按照顺序从下往上叠加的，即先定义的item在下面，后面的依次往上面叠放。以下是带阴影的圆角矩形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">&lt;item</span><br><span class="line">android:left=&quot;2dp&quot;</span><br><span class="line">android:top=&quot;2dp&quot;&gt;</span><br><span class="line">&lt;shape&gt;</span><br><span class="line">&lt;corners android:radius=&quot;20dp&quot; /&gt;</span><br><span class="line">&lt;solid android:color=&quot;#acacac&quot; /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br><span class="line">&lt;/item&gt;</span><br><span class="line">&lt;item</span><br><span class="line">android:right=&quot;2dp&quot;</span><br><span class="line">android:bottom=&quot;2dp&quot;&gt;</span><br><span class="line">&lt;shape&gt;</span><br><span class="line">&lt;corners android:radius=&quot;20dp&quot; /&gt;</span><br><span class="line">&lt;solid android:color=&quot;#FFFFFF&quot; /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br><span class="line">&lt;/item&gt;</span><br><span class="line">&lt;/layer-list&gt;</span><br></pre></td></tr></table></figure></p><p>layer-list可以添加多个item子节点，每个item子节点对应一个drawable资源，按照item从上到下的顺序叠加在一起，再通过设置每个item的偏移量就可以看到阴影等效果了。layer-list的item可以通过下面四个属性设置偏移量：<br>android:top 顶部的偏移量<br>android:bottom 底部的偏移量<br>android:left 左边的偏移量<br>android:right 右边的偏移量<br>这四个偏移量和控件的margin设置差不多，都是外间距的效果。</p><h1 id="两种方式对比"><a href="#两种方式对比" class="headerlink" title="两种方式对比"></a>两种方式对比</h1><table><thead><tr><th>视图高度</th><th>layer-list资源</th></tr></thead><tbody><tr><td>只兼容Android 5.0以上版本</td><td>都兼容</td></tr><tr><td>效果逼真</td><td>效果不真实</td></tr><tr><td>需要额外的空间展示阴影</td><td>不需要额外的空间</td></tr></tbody></table><hr><p><strong>参考资料</strong><br>1.<a href="https://developer.android.com/training/material/shadows-clipping.html?hl=zh-cn" target="_blank" rel="noopener">定义阴影</a><br>2.<a href="http://blog.csdn.net/u014695188/article/details/52815444" target="_blank" rel="noopener">Android中layer-list使用详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现Android阴影共有三种方式：使用.9图（略）、设置视图的高度、在layer-list资源文件中模拟阴影效果，本篇文章将对后两种方式做介绍。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="layer-list" scheme="http://yoursite.com/tags/layer-list/"/>
    
      <category term="elevation" scheme="http://yoursite.com/tags/elevation/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceView使用教程</title>
    <link href="http://yoursite.com/2017/04/26/SurfaceView%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/04/26/SurfaceView使用教程/</id>
    <published>2017-04-26T14:53:28.000Z</published>
    <updated>2018-01-27T03:02:40.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>SurfaceView是视图(View)的继承类，这个视图里内嵌了一个专门用于绘制的Surface。你可以控制这个Surface的格式和尺寸。Surfaceview控制这个Surface的绘制位置。<a id="more"></a><br>Surface是纵深排序(Z-ordered)的，这表明它总在自己所在窗口的后面。Surfaceview提供了一个可见区域，只有在这个可见区域内Surface部分内容才可见，可见区域外的部分不可见。<br>Surface的排版显示受到视图层级关系的影响，它的兄弟视图结点会在顶端显示。这意味者 surface 的内容会被它的兄弟视图遮挡，这一特性可以用来放置遮盖物(overlays)(例如，文本和按钮等控件)。如果 surface 上面有透明控件，那么它的每次变化都会引起框架重新计算它和顶层控件之间的透明效果，这会影响性能。<br>你可以通过getHolder()返回的SurfaceHolder实例访问Surface。Surfaceview变得可见时，Surface被创建；Surfaceview隐藏前，Surface被销毁，这样能节省资源。如果你要查看Surface被创建和销毁的时机，可以重载surfaceCreated(SurfaceHolder)和 surfaceDestroyed(SurfaceHolder)。<br>这里应注意： </p><ol><li>所有SurfaceView和SurfaceHolder.Callback的方法都会在UI线程里调用，一般来说就是应用程序主线程。所以渲染线程所要访问的各种变量应该作同步处理。 </li><li>由于Surface可能被销毁，它只在SurfaceHolder.Callback.surfaceCreated()和SurfaceHolder.Callback.surfaceDestroyed()之间有效，所以要确保渲染线程访问的是合法有效的Surface。</li></ol><blockquote><p><strong>SurfaceView最终会和UI线程打交道：</strong><br>SurfaceView带有独立的Surface（独立与Window的Surface），这可以让子线程在独立的Surface上面绘制东西，进行SurfaceView的界面绘制，这个子线程就叫做渲染线程，但是要让独立的Surface上面的东西在View上面展示出来，需要post一个消息给主线程，目的是把该Surface中canvas 上的东西绘制到View的真正的画布上面（window的Surface的canvas上）。</p></blockquote><h1 id="SurfaceView和View的不同之处"><a href="#SurfaceView和View的不同之处" class="headerlink" title="SurfaceView和View的不同之处"></a>SurfaceView和View的不同之处</h1><table><thead><tr><th>View</th><th>SurfaceView</th></tr></thead><tbody><tr><td>适用于主动更新</td><td>适用于被动刷新</td></tr><tr><td>在主线程中进行画面更新</td><td>通常通过一个子线程来进行画面更新</td></tr><tr><td>绘图中没有使用双缓冲机制</td><td>在底层实现中就实现了双缓冲机制</td></tr></tbody></table><p>比较了上面的不同之处，显然可以发现，如果一个View需要频繁的刷新，或者在刷新时数据处理量大（可能引起卡顿），可以考虑使用SurfaceView来替代View。</p><h4 id="SurfaceView的双缓冲机制"><a href="#SurfaceView的双缓冲机制" class="headerlink" title="SurfaceView的双缓冲机制"></a>SurfaceView的双缓冲机制</h4><p>对于每一个SurfaceView对象而言，有两个独立的graphic buffer。在Android SurfaceView的双缓冲机制中是这样实现的：<br>在Buffer A中绘制内容，然后让屏幕显示Buffer A；在下一个循环中，在Buffer B中绘制内容，然后让屏幕显示Buffer B，如此往复。而由于这个双缓冲机制的存在，可能会引起闪屏现象。在第一个”lockCanvas-drawCanvas-unlockCanvasAndPost “循环中，更新的是buffer A的内容；到下一个”lockCanvas-drawCanvas-unlockCanvasAndPost”循环中，更新的是buffer B的内容。 如果buffer A与buffer B中某个buffer内容为空，当屏幕轮流显示它们时，就会出现画面黑屏闪烁现象。<br><strong>解决方法:</strong><br>当准备更新内容时，先判断内容是否为空，只有非空时才启动”lockCanvas-drawCanvas-unlockCanvasAndPost”这个流程。</p><h1 id="SurfaceView使用步骤"><a href="#SurfaceView使用步骤" class="headerlink" title="SurfaceView使用步骤"></a>SurfaceView使用步骤</h1><ol><li>获取到SurfaceView对应的SurfaceHolder，通过addCallback()方法设置SurfaceHolder.Callback用于监听Surface的创建和销毁。</li><li>创建渲染线程对象。</li><li>在子线程中使用SurfaceHolder的lockCanvas获取Surface上面指定区域的Canvas。</li><li>在该Canvas上绘制图形。绘制结束后，使用SurfaceHolder的unlockCanvasAndPost（）方法解锁Canvas，并且让UI线程把Surface上面的东西绘制到View的Canvas上面。</li></ol><h4 id="使用SurfaceHolder的例子"><a href="#使用SurfaceHolder的例子" class="headerlink" title="使用SurfaceHolder的例子"></a>使用SurfaceHolder的例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class GameUI extends SurfaceView implements SurfaceHolder.Callback &#123;</span><br><span class="line">private SurfaceHolder holder;</span><br><span class="line">private RenderThread renderThread;</span><br><span class="line">private boolean isDraw = false;</span><br><span class="line"></span><br><span class="line">public GameUI(Context context) &#123;</span><br><span class="line">super(context);</span><br><span class="line">holder = getHolder();</span><br><span class="line">holder.addCallback(this);</span><br><span class="line">renderThread = new RenderThread();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public GameUI(Context context, AttributeSet attrs) &#123;</span><br><span class="line">super(context, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public GameUI(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">super(context, attrs, defStyleAttr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void surfaceCreated(SurfaceHolder holder) &#123;</span><br><span class="line">isDraw = true;</span><br><span class="line">if (!renderThread.isAlive()) &#123;</span><br><span class="line">renderThread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void surfaceDestroyed(SurfaceHolder holder) &#123;</span><br><span class="line">isDraw = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class RenderThread extends Thread &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">super.run();</span><br><span class="line">while (isDraw) &#123;</span><br><span class="line">drawUI();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void drawUI() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Canvas canvas = holder.lockCanvas();</span><br><span class="line">drawCanvas(canvas);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">//由于双缓冲机制的存在，判断画布是否为空，从而避免黑屏情况。</span><br><span class="line">if(canvas!=null)&#123;</span><br><span class="line">holder.unlockCanvasAndPost(canvas);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void drawCanvas(Canvas canvas) &#123;</span><br><span class="line">// 在 canvas 上绘制需要的图形</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>参考资料</strong><br>1.<a href="https://developer.android.com/reference/android/view/SurfaceView.html" target="_blank" rel="noopener">SurfaceView</a><br>2.<a href="https://www.cnblogs.com/zhangyingai/p/7087371.html" target="_blank" rel="noopener">SurfaceView的基本使用</a><br>3.<a href="http://blog.csdn.net/zhaoyw2008/article/details/45825069" target="_blank" rel="noopener">SurfaceView基础用法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;SurfaceView是视图(View)的继承类，这个视图里内嵌了一个专门用于绘制的Surface。你可以控制这个Surface的格式和尺寸。Surfaceview控制这个Surface的绘制位置。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="SurfaceView" scheme="http://yoursite.com/tags/SurfaceView/"/>
    
  </entry>
  
  <entry>
    <title>WebView使用教程</title>
    <link href="http://yoursite.com/2017/03/10/WebView%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/03/10/WebView使用教程/</id>
    <published>2017-03-10T13:03:15.000Z</published>
    <updated>2018-01-27T03:07:22.213Z</updated>
    
    <content type="html"><![CDATA[<p>如果你想在将web页面作为APP的一部分，那么我们可以使用WebView。WebView在Android中继承了view类，作为承载网页的控件。但是我们应该知道它并没有继承web浏览器的所有特性，它所实现的也只是展示网页，以及一些基本的交互和监听功能。<a id="more"></a><br>WebView经常被使用的场景是，当你的APP需要向用户展示一个随时可更新的内容，比如用户条款、使用向导。那么这样的话，我们可以在一个Activity中包含一个WebView控件用来展示服务器维护的内容，这些内容可以在服务器随时更改。<br>WeblView另一个使用场景是，当我们需要在一个页面中请求所有用户的数据，一般的做法是写一个layout，然后利用网络请求所有所需数据，最后将这些数据填充到layout中。但最简洁的方式是，我们其实可以直接加载一个网页，这个网页包含了需要的数据。<br>这个教程将帮助你学会使用WebView，以及关于它高级一点的用法，比如页面跳转、js交互等。</p><h1 id="添加WebView到你的应用"><a href="#添加WebView到你的应用" class="headerlink" title="添加WebView到你的应用"></a>添加WebView到你的应用</h1><p>添加WebView到你的应用最简单的方式是在Layout中添加&lt; WebView &gt;标签，例如下面的例子表示一个全屏的WebView。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;WebView  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:id=&quot;@+id/webview&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><p>加载网页，调用loadUrl()方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.loadUrl(&quot;http://www.example.com&quot;);</span><br></pre></td></tr></table></figure></p><p>请求服务器网页时，别忘了要加网络请求权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest ... &gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure></p><p>以上就是最简单的加载网页方式。</p><h1 id="在WebView中使用JavaScript"><a href="#在WebView中使用JavaScript" class="headerlink" title="在WebView中使用JavaScript"></a>在WebView中使用JavaScript</h1><p>如果你在APP展示的网页中包含JS，那么请确保WebView支持JS的加载。在此之后，你还可以新建接口让WebView与Android代码交互。</p><h2 id="授权使用JavaScript"><a href="#授权使用JavaScript" class="headerlink" title="授权使用JavaScript"></a>授权使用JavaScript</h2><p>WebView默认不支持JS的加载，开启它需要调用WebSetting的setJavaScriptEnable()方法。WebSetting可以通过WebView的getSettings()方法获得。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">WebSettings webSettings = myWebView.getSettings();</span><br><span class="line">webSettings.setJavaScriptEnabled(true);</span><br></pre></td></tr></table></figure></p><p>WebSetting提供了许多使用性的功能，比如你想让你幸幸苦苦开发的web page只能在自己的android应用中展示，那么可以在客户端通过setUserAgentString()设置用户代理之后，在服务端遍历userAgentString字段是否是自己的客户端所设定的。</p><h2 id="在Android代码中绑定JavaScript代码"><a href="#在Android代码中绑定JavaScript代码" class="headerlink" title="在Android代码中绑定JavaScript代码"></a>在Android代码中绑定JavaScript代码</h2><p>通过接口的方式，你可以使你的Android代码和JavaScript代码进行交互。例如，你的JavaScript代码可以调用Android代码弹出一个提示框，而不是使用JavaScript的Alert（）方法。<br>让JavaScript和Android代码产生联系的关键是addJavaScriptInterface()方法，此方法包含两个参数，第一个是一个类对象，供JavaScript调用。第二个是接口名称，它用在JavaScript中作为调用Android方法的别名。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class WebAppInterface &#123;</span><br><span class="line">Context mContext;</span><br><span class="line"></span><br><span class="line">/** Instantiate the interface and set the context */</span><br><span class="line">WebAppInterface(Context c) &#123;</span><br><span class="line">mContext = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Show a toast from the web page */</span><br><span class="line">@JavascriptInterface</span><br><span class="line">public void showToast(String toast) &#123;</span><br><span class="line">Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>特别提醒：</strong>如果你的Android目标SDK版本在17或以上，你必须在那些将要在JavaScript中调用的方法体前使用@JavascriptInterface标识。否则，这些方法将不会被调用。</p></blockquote><p>在这个实例中，WebAppInterface允许JavaScript运行showToast方法弹出一个Toast。<br>你可以运行这段代码通过WebView的addJavaScriptInterface()方法，并指定接口的名称为“Android”，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView webView = (WebView) findViewById(R.id.webview);</span><br><span class="line">webView.addJavascriptInterface(new WebAppInterface(this), &quot;Android&quot;);</span><br></pre></td></tr></table></figure></p><p>这段代码为运行在WebView中的JavaScript创建了一个接口“Android”，那么现在你的JavaScript已经有能力访问WebAppInterface中的showToast方法了。下面的HTML和JS代码将调用showToast方法弹出Toast提示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;Say hello&quot; onClick=&quot;showAndroidToast(&apos;Hello Android!&apos;)&quot; /&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function showAndroidToast(toast) &#123;</span><br><span class="line">Android.showToast(toast);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>如你所看到的，在JS中使用“Android”这个接口时，并不需要初始化它，在此之前，WebView已经为你准备好了一些，你只需要通过它调用逻辑即可。</p><blockquote><p><strong>注意：</strong><br>1.WebAppInterface的实例将运行在另一个线程，并不在原来新建它的线程。<br>2.由于通过JS可以调用本地的Android代码，那么我们对于这点要非常的谨慎。对于不受信任的web链接，不应该使用addJavascriptInterface()，除非这个链接是自己本人写的或者其它应该充分信任它的理由。同时，对于不信任的网站，我们在处理它的跳转时应该非常小心，不应该在我们的WebView中直接接受链接的跳转。（默认情况，WebView网页中的链接会跳转到手机的Web浏览器，这是保证安全的前提下一种很好的处理方法。但是，在接下来会提到的serWebViewClient()方法中，你可以自定义链接的行为，这就需要小心了。）</p></blockquote><h1 id="页面导航"><a href="#页面导航" class="headerlink" title="页面导航"></a>页面导航</h1><p>当用户在WebView点击一个链接后，默认的行为是在web浏览器中打开该链接所指向的网页。正如上面所提及的一样，你是可以通过WebView的serWebViewClient方法自定义这个行为的。例如在自己的WebView中展示跳转的内容，而不是跳转到web浏览器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.setWebClient(new WebClient());</span><br></pre></td></tr></table></figure></p><p>当然你还可以做更多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private class MyWebViewClient extends WebViewClient &#123;</span><br><span class="line">@Override</span><br><span class="line">public boolean shouldOverrideUrlLoading(WebView view,String url)&#123;</span><br><span class="line">if (Uri.parse(url).getHost().equals(&quot;www.example.com&quot;)) &#123;</span><br><span class="line">// This is my web site, so do not override; let my WebView load the page</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">// Otherwise, the link is not for a page on my site, so launch another Activity that handles URLs</span><br><span class="line">Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));</span><br><span class="line">startActivity(intent);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后创建MyWebViewClient的实例作为setWebClient()的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.setWebClient(new MyWebViewClient());</span><br></pre></td></tr></table></figure></p><h2 id="导航web的浏览记录"><a href="#导航web的浏览记录" class="headerlink" title="导航web的浏览记录"></a>导航web的浏览记录</h2><p>在WebView中浏览网页时，我们可能会通过web中包含的外链跳转到其它的网页（在同一Webview页面中），那么这些跳转记录是可以来回切换的，这里主要涉及到goBack()和goForward()方法的使用。<br>例如下面的例子，我们通过设备的返回按钮让WebView回退到上一个页面，或者退出当前Activity。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onKeyDown(int keyCode, KeyEvent event) &#123;</span><br><span class="line">    // Check if the key event was the Back button and if there&apos;s history</span><br><span class="line">    if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; myWebView.canGoBack()) &#123;</span><br><span class="line">        myWebView.goBack());</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // If it wasn&apos;t the Back key or there&apos;s no web page history, bubble up to the default</span><br><span class="line">    // system behavior (probably exit the activity)</span><br><span class="line">    return super.onKeyDown(keyCode, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考资料</strong><br><a href="https://developer.android.com/guide/webapps/webview.html#HandlingNavigation" target="_blank" rel="noopener">Building Web Apps in WebView</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你想在将web页面作为APP的一部分，那么我们可以使用WebView。WebView在Android中继承了view类，作为承载网页的控件。但是我们应该知道它并没有继承web浏览器的所有特性，它所实现的也只是展示网页，以及一些基本的交互和监听功能。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="WebView" scheme="http://yoursite.com/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之Volatile和Automic</title>
    <link href="http://yoursite.com/2017/02/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BVolatile%E5%92%8CAutomic/"/>
    <id>http://yoursite.com/2017/02/21/Java并发编程之Volatile和Automic/</id>
    <published>2017-02-21T05:20:00.000Z</published>
    <updated>2018-01-22T12:09:24.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h1><p>当我们声明共享变量为volatile后，对这个变量的读/写将会很特别。理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步(实际上不是完全一样的，后面会提到)。下面我们通过具体的示例来说明，请看下面的示例代码：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class VolatileFeaturesExample &#123;</span><br><span class="line">//使用volatile声明64位的long型变量</span><br><span class="line">volatile long vl = 0L;</span><br><span class="line"></span><br><span class="line">public void set(long l) &#123;</span><br><span class="line">vl = l;   //单个volatile变量的写</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void getAndIncrement () &#123;</span><br><span class="line">vl++;    //复合（多个）volatile变量的读/写</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public long get() &#123;</span><br><span class="line">return vl;   //单个volatile变量的读</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设有多个线程分别调用上面程序的三个方法，这个程序在语义上和下面程序等价：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class VolatileFeaturesExample &#123;</span><br><span class="line">long vl = 0L;               // 64位的long型普通变量</span><br><span class="line"></span><br><span class="line">//对单个的普通 变量的写用同一个锁同步</span><br><span class="line">public synchronized void set(long l) &#123;             </span><br><span class="line">vl = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void getAndIncrement () &#123; //普通方法调用</span><br><span class="line">long temp = get();           //调用已同步的读方法</span><br><span class="line">temp += 1L;                  //普通写操作</span><br><span class="line">set(temp);                   //调用已同步的写方法</span><br><span class="line">&#125;</span><br><span class="line">public synchronized long get() &#123; </span><br><span class="line">//对单个的普通变量的读用同一个锁同步</span><br><span class="line">return vl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上面示例程序所示，对一个volatile变量的单个读/写操作，与对一个普通变量的读/写操作使用同一个锁来同步，它们之间的执行效果相同。<br>锁的<a href="http://www.baeldung.com/java-volatile" target="_blank" rel="noopener">happens-before规则</a>保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。<br>锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。<br>简而言之，volatile变量自身具有下列特性：<br>1.可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。<br>2.原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</p><h5 id="volatile-与-synchronized-的比较"><a href="#volatile-与-synchronized-的比较" class="headerlink" title="volatile 与 synchronized 的比较"></a>volatile 与 synchronized 的比较</h5><p>volatile主要用在多个线程感知实例变量被更改的场合，从而使得各个线程获得最新的值。比较：<br>①volatile轻量级，只能修饰变量。synchronized重量级，还可修饰方法。<br>②volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞。synchronized不仅保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。</p><h5 id="由锁释放和获取的内存语义引申volatile"><a href="#由锁释放和获取的内存语义引申volatile" class="headerlink" title="由锁释放和获取的内存语义引申volatile"></a>由锁释放和获取的内存语义引申volatile</h5><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须要“从主内存中去读取共享变量”。<strong><em>实际上，锁释放-获取的内存语义与volatile写-读的内存语义有着一一对应的关系，锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</em></strong><br>下面对锁释放和锁获取的内存语义做个总结（volatile的读、写类似）：</p><ol><li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</li><li>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</li><li>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</li></ol><h1 id="AtomicInteger介绍"><a href="#AtomicInteger介绍" class="headerlink" title="AtomicInteger介绍"></a>AtomicInteger介绍</h1><p>原子操作在多线程场景是很有必要的，它可以避免数据的二义性产生。下面的程序中我们新建了两个线程，每个线程对同一个数增加了4次，每次加1，最后的结果正确应该是8。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class JavaAtomic &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">ProcessingThread pt = new ProcessingThread();</span><br><span class="line">Thread t1 = new Thread(pt, &quot;t1&quot;);</span><br><span class="line">t1.start();</span><br><span class="line">Thread t2 = new Thread(pt, &quot;t2&quot;);</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(&quot;Processing count=&quot; + pt.getCount());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProcessingThread implements Runnable &#123;</span><br><span class="line">private int count;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">processSomething(i);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getCount() &#123;</span><br><span class="line">return this.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void processSomething(int i) &#123;</span><br><span class="line">// processing some job</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(i * 1000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行上面的程序后，你会发现最后的运行结果每次都不一样，可能是5，6，7或者8。原因就是count++不具备原子性，当一个线程读取了count的值并进行完加1操作时，另外一个线程还是引用的原来旧的count值，这样就导致了最后加1后的结果不符合预期的现象。<br>为了解决这个问题，我们除了可以使用Synchronized、Lock，还可以使用 Java 5 java.util.concurrent.atomic提供的AutomicInteger实现原子操作。并且在程序逻辑允许的情况下，我们应该优先使用atomic，<a href="https://www.callicoder.com/java-locks-and-atomic-variables-tutorial/" target="_blank" rel="noopener">它在执行速度、可读性、实用性方面均优于前两者</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class JavaAtomic &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">ProcessingThread pt = new ProcessingThread();</span><br><span class="line">Thread t1 = new Thread(pt, &quot;t1&quot;);</span><br><span class="line">t1.start();</span><br><span class="line">Thread t2 = new Thread(pt, &quot;t2&quot;);</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(&quot;Processing count=&quot; + pt.getCount());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProcessingThread implements Runnable &#123;</span><br><span class="line">private AtomicInteger count = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">processSomething(i);</span><br><span class="line">count.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getCount() &#123;</span><br><span class="line">return this.count.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void processSomething(int i) &#123;</span><br><span class="line">// processing some job</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(i * 1000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考资料</strong><br>1.<a href="http://ifeve.com/java-memory-model-4/" target="_blank" rel="noopener">并发编程网</a><br>2.<a href="https://www.journaldev.com/1095/atomicinteger-java" target="_blank" rel="noopener">AtomicInteger in Java</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;volatile的特性&quot;&gt;&lt;a href=&quot;#volatile的特性&quot; class=&quot;headerlink&quot; title=&quot;volatile的特性&quot;&gt;&lt;/a&gt;volatile的特性&lt;/h1&gt;&lt;p&gt;当我们声明共享变量为volatile后，对这个变量的读/写将会很特别。理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步(实际上不是完全一样的，后面会提到)。下面我们通过具体的示例来说明，请看下面的示例代码：&lt;br&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="并发编程" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Fragment的理解</title>
    <link href="http://yoursite.com/2017/02/16/Fragment%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/02/16/Fragment的理解/</id>
    <published>2017-02-16T12:55:41.000Z</published>
    <updated>2018-03-15T03:22:28.205Z</updated>
    
    <content type="html"><![CDATA[<p>碎片化的出现让一些复杂冗长的内容在一些屏幕与分辨率存在差异的屏幕上得到了合理的展示，极大地提高了用户的体验。下面对Fragment的一些热点问题进行一下讲解。<a id="more"></a></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Fragment（碎片）是在Android 3.0出现的。可以把Fragment理解成Activity的一个模块化区域，他拥有自己的生命周期，接收属于自己的输入事件，并且可以在Activity运行期间被添加和删除。Fragment必须被嵌入一个Activity中，它们的生命周期直接受宿主Activity的影响。当一个Activity正在运行时，可以独立的操作其中的每一个Fragment，如添加和删除。<br>Fragment的加载方式有两种：静态加载和动态加载。静态加载很简单，只需把Fragment当成普通UI放在界面Layout中。动态加载需要先了解Fragment事务，事务指的就是原子性，不可分割的操作。所谓的Fragment事务。所谓Fragment事务，就是对Fragment的进行添加、删除、替换或者其它操作，提交给Activity的每一个变化，这就是事务。动态加载的流程如下：</p><ol><li>开启一个新事务；</li><li>通过事务添加Fragment；</li><li>提交事务，否则添加不成功。</li></ol><h1 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h1><p>Fragment的生命周期与Activity类似，用到的方法如下表所示。</p><table><thead><tr><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>onAttach()</td><td>绑定Fragment到Activity</td></tr><tr><td>onCreate()</td><td>创建Fragment</td></tr><tr><td>onCreateView()</td><td>创建Fragment的布局</td></tr><tr><td>onActivityCreated()</td><td>Activity创建完成后回调该方法</td></tr><tr><td>onStart()</td><td>可见，不可交互状态</td></tr><tr><td>onResume()</td><td>可见，可交互状态</td></tr><tr><td>onPause()</td><td>部分可见，不可交互状态</td></tr><tr><td>onStop()</td><td>不可见</td></tr><tr><td>onDestroyView()</td><td>销毁Fragment的View对象</td></tr><tr><td>onDestroy()</td><td>Fragment被销毁</td></tr><tr><td>onDetach()</td><td>Fragment从Activity解绑</td></tr></tbody></table><p>这里有几点需要注意的地方：<br>1、因为Fragment与Activity是绑定在一起的，所以当Activity被销毁时，Fragment也要被销毁。Fragment的调销毁过程是：onPause()——&gt;onStop()——&gt;onDestroyView()——&gt;onDestroy()——&gt;onDetach()。<br>2、调用FragmentTransaction的hide()与show()对于Fragment的生命周期没有影响。<br>3、调用FragmentTransaction的replace()方法，并且在次之前没有调用addToBackStack，则之前已创建的Fragment(如果有)将会被解绑；反之，如果在次之前调用了addToBackStack方法，之前已创建的Fragment(如果有)将只会被销毁它的View对象，即调用onDestroyView()方法。</p><h1 id="Fragment与Activity如何进行交互"><a href="#Fragment与Activity如何进行交互" class="headerlink" title="Fragment与Activity如何进行交互"></a>Fragment与Activity如何进行交互</h1><p>由于所有的Fragment都依赖与Activity，因此它们之间实现通信并不复杂，大概可以分为两种：一种是在Activity中访问Fragment，一种是在Frament中访问Activity，具体如下：</p><h4 id="在Activity中访问Frament"><a href="#在Activity中访问Frament" class="headerlink" title="在Activity中访问Frament"></a>在Activity中访问Frament</h4><p>因为可以在Activity中获取Fragment实例（特殊除外），所以可以直接访问Frament中声明的公有方法。</p><blockquote><p>小提示：<br>除了直接通过Fragment的公有方法访问外，我们还可以通过接口回调的方式访问Fragment中相关参数。</p></blockquote><h4 id="在Fragment中访问Activity"><a href="#在Fragment中访问Activity" class="headerlink" title="在Fragment中访问Activity"></a>在Fragment中访问Activity</h4><p>在Fragment中可以通过<code>getActivity()</code>方法得到当前绑定的Activity的实例，然后进行操作。</p><h1 id="如何切换Fragment"><a href="#如何切换Fragment" class="headerlink" title="如何切换Fragment"></a>如何切换Fragment</h1><p>首先分别获取FragmentMangager与FragmentTransaction的实例，然后创建一个Fragment对象，接下来调用FragmentTransaction对象的replace（）方法和commit方法来完成Fragment的切换。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取FragmentManager的实例</span><br><span class="line">FragmentManager fragmentManager=getFragmentManager();</span><br><span class="line">FragmentTransaction transaction=fragmentManager.beginTransaction();</span><br><span class="line">ExampleFragment fragment=new ExampleFragment();//创建一个Fragment</span><br><span class="line">fragmentTransaction.replace(R.id.content,fragment);//R.id.content对应的控件必须是一个ViewGroup</span><br><span class="line">fragmentTransaction.commit();</span><br></pre></td></tr></table></figure></p><h1 id="理解addToBackStack"><a href="#理解addToBackStack" class="headerlink" title="理解addToBackStack()"></a>理解addToBackStack()</h1><p>官方的解释：Add this transaction to the back stack.  This means that the transaction will be remembered after it is committed, and will reverse its operation when later popped off the stack.<br>大白话：在commit之前保存此时的状态，之后如果按返回键，可以再次回到此时的状态。一般我们需要使用addToBackStack的话，直接调用addToBackStack(null)即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;碎片化的出现让一些复杂冗长的内容在一些屏幕与分辨率存在差异的屏幕上得到了合理的展示，极大地提高了用户的体验。下面对Fragment的一些热点问题进行一下讲解。
    
    </summary>
    
      <category term="四大组件" scheme="http://yoursite.com/categories/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="Fragment" scheme="http://yoursite.com/tags/Fragment/"/>
    
  </entry>
  
</feed>
