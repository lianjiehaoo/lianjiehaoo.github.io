<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TXM</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-03T13:50:50.412Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>TXM</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android屏幕适配方案</title>
    <link href="http://yoursite.com/2017/08/03/Android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    <id>http://yoursite.com/2017/08/03/Android屏幕适配/</id>
    <published>2017-08-03T12:36:37.000Z</published>
    <updated>2018-02-03T13:50:50.412Z</updated>
    
    <content type="html"><![CDATA[<p>Android的屏幕适配一直以来都在折磨着我们这些开发者，本篇文章将以Google的官方文档为基础，全面而深入的讲解Android屏幕适配的原因、重要概念、解决方案及最佳实践。<a id="more"></a></p><h1 id="Android屏幕适配出现的原因"><a href="#Android屏幕适配出现的原因" class="headerlink" title="Android屏幕适配出现的原因"></a>Android屏幕适配出现的原因</h1><p><a href="http://opensignal.com/reports/2014/android-fragmentation/" target="_blank" rel="noopener">Android的屏幕尺寸很多</a>，为了让我们开发的程序能够比较美观的显示在不同尺寸、分辨率、像素密度(这些概念我会在下面详细讲解)的设备上，那就要在开发的过程中进行处理，至于如何去进行处理，这就是我们今天的主题了。</p><h1 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h1><p>什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？<br>什么是dp、dip、dpi、sp、px？他们之间的关系是什么？<br>什么是mdpi、hdpi、xdpi、xxdpi？如何计算和区分？<br>在下面的内容中我们将介绍这些概念。</p><h4 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h4><p>屏幕尺寸指屏幕的对角线的长度，单位是英寸，1英寸=2.54厘米。<br>比如常见的屏幕尺寸有2.4、2.8、3.5、3.7、4.2、5.0、5.5、6.0等。</p><h4 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h4><p>屏幕分辨率是指在横纵向上的像素点数，单位是px，1px=1个像素点。一般以纵向像素*横向像素，如1960*1080。</p><h4 id="屏幕像素密度"><a href="#屏幕像素密度" class="headerlink" title="屏幕像素密度"></a>屏幕像素密度</h4><p>屏幕像素密度是指每英寸上的像素点数，单位是dpi，即“dot per inch”的缩写。屏幕像素密度与屏幕尺寸和屏幕分辨率有关，在单一变化条件下，屏幕尺寸越小、分辨率越高，像素密度越大，反之越小。</p><h4 id="dp、dip、dpi、sp、px"><a href="#dp、dip、dpi、sp、px" class="headerlink" title="dp、dip、dpi、sp、px"></a>dp、dip、dpi、sp、px</h4><p>px我们应该是比较熟悉的，前面的分辨率就是用的像素为单位，大多数情况下，比如UI设计、Android原生API都会以px作为统一的计量单位，像是获取屏幕宽高等。<br>dip和dp是一个意思，都是Density Independent Pixels的缩写，即密度无关像素，上面我们说过，dpi是屏幕像素密度，假如一英寸里面有160个像素，这个屏幕的像素密度就是160dpi，那么在这种情况下，dp和px如何换算呢？在Android中，规定以160dpi为基准，1dip=1px，如果密度是320dpi，则1dip=2px，以此类推。<br>假如同样都是画一条320px的线，在480*800分辨率手机上显示为2/3屏幕宽度，在320*480的手机上则占满了全屏，如果使用dp为单位，在这两种分辨率下，160dp都显示为屏幕一半的长度。这也是为什么在Android开发中，写布局的时候要尽量使用dp而不是px的原因。<br>而sp，即scale-independent pixels，与dp类似，但是可以根据文字大小首选项进行放缩，是设置字体大小的御用单位。</p><h4 id="mdpi、hdpi、xdpi、xxdpi"><a href="#mdpi、hdpi、xdpi、xxdpi" class="headerlink" title="mdpi、hdpi、xdpi、xxdpi"></a>mdpi、hdpi、xdpi、xxdpi</h4><p>其实之前还有个ldpi，但是随着移动设备配置的不断升级，这个像素密度的设备已经很罕见了，所在现在适配时不需考虑。<br>mdpi、hdpi、xdpi、xxdpi用来修饰Android中的drawable文件夹及values文件夹，用来区分不同像素密度下的图片和dimen值。<br>那么如何区分呢？Google官方指定按照下列标准进行区分：</p><table><thead><tr><th>名称</th><th style="text-align:center">像素密度范围</th></tr></thead><tbody><tr><td>mdpi</td><td style="text-align:center">120dpi~160dpi</td></tr><tr><td>hdpi</td><td style="text-align:center">160dpi~240dpi</td></tr><tr><td>xhdpi</td><td style="text-align:center">240dpi~320dpi</td></tr><tr><td>xxhdpi</td><td style="text-align:center">320dpi~480dpi</td></tr><tr><td>xxxhdpi</td><td style="text-align:center">480dpi~640dpi</td></tr></tbody></table><p>在进行开发的时候，我们需要把合适大小的图片放在合适的文件夹里面。下面以图标设计为例进行介绍。<br>在设计图标时，对于五种主流的像素密度（MDPI、HDPI、XHDPI、XXHDPI 和 XXXHDPI）应按照 2:3:4:6:8 的比例进行缩放。例如，一个启动图标的尺寸为48x48 dp，这表示在 MDPI 的屏幕上其实际尺寸应为 48x48 px，在 HDPI 的屏幕上其实际大小是 MDPI 的 1.5 倍 (72x72 px)，在 XDPI 的屏幕上其实际大小是 MDPI 的 2 倍 (96x96 px)，依此类推。<br>虽然 Android 也支持低像素密度 (LDPI) 的屏幕，但无需为此费神，系统会自动将 HDPI 尺寸的图标缩小到 1/2 进行匹配。<br>下图为图标的各个屏幕密度的对应尺寸:</p><table><thead><tr><th>屏幕密度</th><th style="text-align:center">图标尺寸</th></tr></thead><tbody><tr><td>mdpi</td><td style="text-align:center">48x48px</td></tr><tr><td>hdpi</td><td style="text-align:center">72x72px</td></tr><tr><td>xhdpi</td><td style="text-align:center">96x96px</td></tr><tr><td>xxhdpi</td><td style="text-align:center">144x144px</td></tr><tr><td>xxxhdpi</td><td style="text-align:center">192x192px</td></tr></tbody></table><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="支持各种屏幕尺寸"><a href="#支持各种屏幕尺寸" class="headerlink" title="支持各种屏幕尺寸"></a>支持各种屏幕尺寸</h2><h4 id="使用wrap-content、match-parent、weight"><a href="#使用wrap-content、match-parent、weight" class="headerlink" title="使用wrap_content、match_parent、weight"></a>使用wrap_content、match_parent、weight</h4><p>要确保布局的灵活性并适应各种尺寸的屏幕，应使用 “wrap_content” 和 “match_parent” 控制某些视图组件的宽度和高度。<br>使用 “wrap_content”，系统就会将视图的宽度或高度设置成所需的最小尺寸以适应视图中的内容，而 “match_parent”（在低于 API 级别 8 的级别中称为 “fill_parent”）则会展开组件以匹配其父视图的尺寸。<br>weight是线性布局的一个独特的属性，我们可以使用这个属性来按照比例对界面进行分配，完成一些特殊的需求。<br><strong>但是，我们对于这个属性的计算应该如何理解呢？首先看下面的例子，我们在布局中这样设置我们的界面：</strong><br>我们在布局里面设置为线性布局，横向排列，然后放置两个宽度为0dp的按钮，分别设置weight为1和2，在效果图中，我们可以看到两个按钮按照1：2的宽度比例正常排列了，这也是我们经常使用到的场景，这是时候很好理解，Button1的宽度就是1/(1+2) = 1/3，Button2的宽度则是2/(1+2) = 2/3，我们可以很清楚的明白这种情景下的占比如何计算。<br>但是假如我们的宽度不是0dp(wrap_content和0dp的效果相同)，则是match_parent呢？<br>在这种情况下，占比和上面正好相反，这是怎么回事呢？说到这里，我们就不得不提一下weight的计算方法了。<br>android:layout_weight的真实含义是:如果View设置了该属性并且有效，那么该 View的宽度等于原有宽度(android:layout_width)加上剩余空间的占比。<br>从这个角度我们来解释一下上面的现象。在上面的代码中，我们设置每个Button的宽度都是match_parent，假设屏幕宽度为L，那么每个Button的宽度也应该都为L，剩余宽度就等于L-（L+L）= -L。<br>Button1的weight=1，剩余宽度占比为1/(1+2)= 1/3，所以最终宽度为L+1/3*(-L)=2/3L，Button2的计算类似，最终宽度为L+2/3(-L)=1/3L。<br>同时，垂直方向上的结论和水平是完全一样的。虽然说我们演示了match_parent的显示效果，并说明了原因，但是在真正用的时候，我们都是设置某一个属性为0dp，然后按照权重计算所占百分比。</p><h4 id="使用相对布局，禁用绝对布局"><a href="#使用相对布局，禁用绝对布局" class="headerlink" title="使用相对布局，禁用绝对布局"></a>使用相对布局，禁用绝对布局</h4><p>在开发中，我们大部分时候使用的都是线性布局、相对布局和帧布局，绝对布局由于适配性极差，所以极少使用。<br>由于各种布局的特点不一样，所以不能说哪个布局好用，到底应该使用什么布局只能根据实际需求来确定。我们可以使用 LinearLayout 的嵌套实例并结合 “wrap_content” 和 “match_parent”，以便构建相当复杂的布局。不过，我们无法通过 LinearLayout 精确控制子视图的特殊关系；系统会将 LinearLayout 中的视图直接并排列出。<br>如果我们需要将子视图排列出各种效果而不是一条直线，通常更合适的解决方法是使用 RelativeLayout，这样就可以根据各组件之间的特殊关系指定布局了。例如，我们可以将某个子视图对齐到屏幕左侧，同时将另一个视图对齐到屏幕右侧。</p><h2 id="使用限定符"><a href="#使用限定符" class="headerlink" title="使用限定符"></a>使用限定符</h2><h4 id="使用尺寸限定符"><a href="#使用尺寸限定符" class="headerlink" title="使用尺寸限定符"></a>使用尺寸限定符</h4><p>上面所提到的灵活布局或者是相对布局，可以为我们带来的优势就只有这么多了。虽然这些布局可以拉伸组件内外的空间以适应各种屏幕，但它们不一定能为每种屏幕都提供最佳的用户体验。因此，我们的应用不仅仅只实施灵活布局，还应该应针对各种屏幕配置提供一些备用布局。<br>如何做到这一点呢？我们可以通过使用配置限定符，在运行时根据当前的设备配置自动选择合适的资源了，例如根据各种屏幕尺寸选择不同的布局。<br>很多应用会在较大的屏幕上实施“双面板”模式，即在一个面板上显示项目列表，而在另一面板上显示对应内容。平板电脑和电视的屏幕已经大到可以同时容纳这两个面板了，但手机屏幕就需要分别显示。因此，我们可以使用以下文件以便实施这些布局：<br>res/layout/main.xml，单面板（默认）布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:orientation=&quot;vertical&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>res/layout-large/main.xml，双面板布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;400dp&quot;</span><br><span class="line">android:layout_marginRight=&quot;10dp&quot;/&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/article&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>请注意第二种布局名称目录中的 large 限定符。系统会在属于较大屏幕（例如 7 英寸或更大的平板电脑）的设备上选择此布局。系统会在较小的屏幕上选择其他布局（无限定符）。</p><h4 id="使用最小宽度限定符"><a href="#使用最小宽度限定符" class="headerlink" title="使用最小宽度限定符"></a>使用最小宽度限定符</h4><p>在版本低于 3.2 的 Android 设备上，开发人员遇到的问题之一是“较大”屏幕的尺寸范围，该问题会影响戴尔 Streak、早期的 Galaxy Tab 以及大部分 7 英寸平板电脑。即使这些设备的屏幕属于“较大”的尺寸，但很多应用可能会针对此类别中的各种设备显示不同的布局（“较大”的概念不清晰导致的）。这就是 Android 3.2 版在引入其他限定符的同时引入“最小宽度”限定符的原因。<br>最小宽度限定符可让您通过指定某个最小宽度（以 dp 为单位）来定位屏幕。例如，标准 7 英寸平板电脑的最小宽度为 600 dp，因此如果您要在此类屏幕上的用户界面中使用双面板（但在较小的屏幕上只显示列表），您可以使用上文中所述的单面板和双面板这两种布局，但您应使用 sw600dp 指明双面板布局仅适用于最小宽度为 600 dp 的屏幕，而不是使用 large 尺寸限定符。<br>res/layout/main.xml，单面板（默认）布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:orientation=&quot;vertical&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>res/layout-sw600dp/main.xml，双面板布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;400dp&quot;</span><br><span class="line">android:layout_marginRight=&quot;10dp&quot;/&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/article&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>也就是说，对于最小宽度大于等于 600 dp 的设备，系统会选择 layout-sw600dp/main.xml（双面板）布局，否则系统就会选择 layout/main.xml（单面板）布局。<br>但 Android 版本低于 3.2 的设备不支持此技术，原因是这些设备无法将 sw600dp 识别为尺寸限定符，因此我们仍需使用 large 限定符。这样一来，就会有一个名称为 res/layout-large/main.xml 的文件（与 res/layout-sw600dp/main.xml 一样）。但是没有太大关系，我们将马上学习如何避免此类布局文件出现的重复。</p><h4 id="使用布局别名"><a href="#使用布局别名" class="headerlink" title="使用布局别名"></a>使用布局别名</h4><p>最小宽度限定符仅适用于 Android 3.2 及更高版本。因此，如果我们仍需使用与较低版本兼容的概括尺寸范围（小、正常、大和特大）。例如，如果要将用户界面设计成在手机上显示单面板，但在 7 英寸平板电脑、电视和其他较大的设备上显示多面板，那么我们就需要提供以下文件：</p><ul><li>res/layout/main.xml: 单面板布局</li><li>res/layout-large: 多面板布局</li><li>res/layout-sw600dp: 多面板布局</li></ul><p>后两个文件是相同的，因为其中一个用于和 Android 3.2 设备匹配，而另一个则是为使用较低版本 Android 的平板电脑和电视准备的。<br>要避免平板电脑和电视的文件出现重复（以及由此带来的维护问题），您可以使用别名文件。例如，您可以定义以下布局：</p><ul><li>res/layout/main.xml，单面板布局</li><li>res/layout/main_twopanes.xml，双面板布局</li></ul><p>然后添加这两个文件：<br>res/values-large/layout.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>res/values-sw600dp/layout.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>后两个文件的内容相同，但它们并未实际定义布局。它们只是将 main 设置成了 main_twopanes 的别名。由于这些文件包含 large 和 sw600dp 选择器，因此无论 Android 版本如何，系统都会将这些文件应用到平板电脑和电视上（版本低于 3.2 的平板电脑和电视会匹配 large，版本高于 3.2 的平板电脑和电视则会匹配 sw600dp）。</p><h4 id="使用屏幕方向限定符"><a href="#使用屏幕方向限定符" class="headerlink" title="使用屏幕方向限定符"></a>使用屏幕方向限定符</h4><p>某些布局会同时支持横向模式和纵向模式，但我们可以通过调整优化其中大部分布局的效果。在新闻阅读器示例应用中，每种屏幕尺寸和屏幕方向下的布局行为方式如下所示：</p><ul><li>小屏幕，纵向：单面板，带徽标</li><li>小屏幕，横向：单面板，带徽标</li><li>7 英寸平板电脑，纵向：单面板，带操作栏</li><li>7 英寸平板电脑，横向：双面板，宽，带操作栏</li><li>10 英寸平板电脑，纵向：双面板，窄，带操作栏</li><li>10 英寸平板电脑，横向：双面板，宽，带操作栏</li><li>电视，横向：双面板，宽，带操作栏</li></ul><p>因此，这些布局中的每一种都定义在了 res/layout/ 目录下的某个 XML 文件中。为了继续将每个布局分配给各种屏幕配置，该应用会使用布局别名将两者相匹配：<br>res/layout/onepane.xml:(单面板)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:orientation=&quot;vertical&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>res/layout/onepane_with_bar.xml:(单面板带操作栏)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:orientation=&quot;vertical&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">&lt;LinearLayout android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:id=&quot;@+id/linearLayout1&quot;  </span><br><span class="line">android:gravity=&quot;center&quot;</span><br><span class="line">android:layout_height=&quot;50dp&quot;&gt;</span><br><span class="line">&lt;ImageView android:id=&quot;@+id/imageView1&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:src=&quot;@drawable/logo&quot;</span><br><span class="line">android:paddingRight=&quot;30dp&quot;</span><br><span class="line">android:layout_gravity=&quot;left&quot;</span><br><span class="line">android:layout_weight=&quot;0&quot; /&gt;</span><br><span class="line">&lt;View android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:id=&quot;@+id/view1&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_weight=&quot;1&quot; /&gt;</span><br><span class="line">&lt;Button android:id=&quot;@+id/categorybutton&quot;</span><br><span class="line">android:background=&quot;@drawable/button_bg&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;</span><br><span class="line">android:layout_weight=&quot;0&quot;</span><br><span class="line">android:layout_width=&quot;120dp&quot;</span><br><span class="line">style=&quot;@style/CategoryButtonStyle&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>res/layout/twopanes.xml:(双面板，宽布局)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;400dp&quot;</span><br><span class="line">android:layout_marginRight=&quot;10dp&quot;/&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/article&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>res/layout/twopanes_narrow.xml:(双面板，窄布局)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/headlines&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot;</span><br><span class="line">android:layout_width=&quot;200dp&quot;</span><br><span class="line">android:layout_marginRight=&quot;10dp&quot;/&gt;</span><br><span class="line">&lt;fragment android:id=&quot;@+id/article&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">android:name=&quot;com.example.android.newsreader.ArticleFragment&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>既然我们已定义了所有可能的布局，那就只需使用配置限定符将正确的布局映射到各种配置即可。<br>现在只需使用布局别名技术即可做到这一点：<br>res/values/layouts.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane_with_bar&lt;/item&gt;</span><br><span class="line">&lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>res/values-sw600dp-land/layouts.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes&lt;/item&gt;</span><br><span class="line">&lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>res/values-sw600dp-port/layouts.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane&lt;/item&gt;</span><br><span class="line">&lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>res/values-large-land/layouts.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes&lt;/item&gt;</span><br><span class="line">&lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>res/values-large-port/layouts.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes_narrow&lt;/item&gt;</span><br><span class="line">&lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><h2 id="使用自动拉伸位图-9图"><a href="#使用自动拉伸位图-9图" class="headerlink" title="使用自动拉伸位图(.9图)"></a>使用自动拉伸位图(.9图)</h2><p>在Android的设计过程中，为了适配不同的手机分辨率，图片大多需要拉伸或者压缩，这样就出现了可以任意调整大小的一种图片格式“.9.png”。<a href="http://blog.csdn.net/lastwarmth/article/details/49991445" target="_blank" rel="noopener">详细教程请参考这篇文章</a>。</p><h2 id="支持各种屏幕密度"><a href="#支持各种屏幕密度" class="headerlink" title="支持各种屏幕密度"></a>支持各种屏幕密度</h2><h4 id="使用密度无关像素"><a href="#使用密度无关像素" class="headerlink" title="使用密度无关像素"></a>使用密度无关像素</h4><p>由于各种屏幕的像素密度都有所不同，因此相同数量的像素在不同设备上的实际大小也有所差异，这样使用像素定义布局尺寸就会产生问题。因此，请务必使用 dp 或 sp 单位指定尺寸。dp 是一种非密度制约像素，其尺寸与 160 dpi 像素的实际尺寸相同。sp 也是一种基本单位，但它可根据用户的偏好文字大小进行调整（即尺度独立性像素），因此我们应将该测量单位用于定义文字大小。<br>例如，请使用 dp（而非 px）指定两个视图间的间距：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:text=&quot;@string/clickme&quot;</span><br><span class="line">android:layout_marginTop=&quot;20dp&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>请务必使用 sp 指定文字大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:textSize=&quot;20sp&quot; /&gt;</span><br></pre></td></tr></table></figure><p>除了介绍这些最基础的知识之外，我们下面再来讨论一下另外一个问题。<br>经过上面的介绍，我们都清楚，为了能够规避不同像素密度的陷阱，Google推荐使用dp来代替px作为控件长度的度量单位，但是我们来看下面的一个场景。<br>假如我们以Nexus5作为书写代码时查看效果的测试机型，Nexus5的总宽度为360dp，我们现在需要在水平方向上放置两个按钮，一个是150dp左对齐，另外一个是200dp右对齐，最后中间留有10dp间隔。<br>但是如果在Nexus S或者是Nexus One运行，两个按钮就发生了重叠。我们都已经用了dp了，为什么会出现这种情况呢？<br>虽然说dp可以去除不同像素密度的问题，使得1dp在不同像素密度上面的显示效果相同，但是还是由于Android屏幕设备的多样性，如果使用dp来作为度量单位，并不是所有的屏幕的宽度都是相同的dp长度，比如说，Nexus S和Nexus One属于hdpi，屏幕宽度是320dp，而Nexus 5属于xxhdpi，屏幕宽度是360dp，Galaxy Nexus属于xhdpi，屏幕宽度是384dp，Nexus 6 属于xxxhdpi，屏幕宽度是410dp。所以说，光Google自己一家的产品就已经有这么多的标准，而且屏幕宽度和像素密度没有任何关联关系，即使我们使用dp，在320dp宽度的设备和410dp的设备上，还是会有90dp的差别。<br>所以总结的结果是，我们要尽量使用match_parent和wrap_content，尽可能少的用dp来指定控件的具体长宽，再结合上权重，大部分的情况我们都是可以做到适配的。如果遇到上述情况的话，这里有一种方法就是，我们假设手机屏幕的宽度都是320某单位，那么我们将一个屏幕宽度的总像素数平均分成320份，每一份对应具体的像素就可以了。<a href="http://blog.csdn.net/lmj623565791/article/details/45460089" target="_blank" rel="noopener">具体介绍可以参考这篇文章。</a></p><h4 id="提供备用位图"><a href="#提供备用位图" class="headerlink" title="提供备用位图"></a>提供备用位图</h4><p>由于 Android 可在具有各种屏幕密度的设备上运行，因此我们提供的位图资源应始终可以满足各类普遍密度范围的要求：低密度、中等密度、高密度以及超高密度。这将有助于我们的图片在所有屏幕密度上都能得到出色的质量和效果。<br>要生成这些图片，我们应先提取矢量格式的原始资源，然后根据以下尺寸范围针对各密度生成相应的图片。</p><ul><li>xhdpi：2.0</li><li>hdpi：1.5</li><li>mdpi：1.0（最低要求）</li><li>ldpi：0.75</li></ul><p>也就是说，如果我们为 xhdpi 设备生成了 200x200 px尺寸的图片，就应该使用同一资源为 hdpi、mdpi 和 ldpi 设备分别生成 150x150、100x100 和 75x75 尺寸的图片。<a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650235875&amp;idx=1&amp;sn=add1f85f961b2e70164900cc287b1e66&amp;scene=38#wechat_redirect" target="_blank" rel="noopener">（实际开发的过程中，通常都会做三套配图，对应着drawable-hdpi、drawable-xhdpi、drawable-xxhdpi三个文件夹。当然时间赶的话，做一套也是可以的。）</a><br>然后，将生成的图片文件放在 res/ 下的相应子目录中(mdpi、hdpi、xhdpi、xxhdpi)，系统就会根据运行您应用的设备的屏幕密度自动选择合适的图片。<br>这样一来，只要我们引用 @drawable/id，系统都能根据相应屏幕的 dpi 选取合适的位图。<br>还记得我们上面提到的图标设计尺寸吗？和这个其实是一个意思。<br>但是还有个问题需要注意下，如果是.9图或者是不需要多个分辨率的图片，就放在drawable文件夹即可。</p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><h2 id="关于高清设计图尺寸"><a href="#关于高清设计图尺寸" class="headerlink" title="关于高清设计图尺寸"></a>关于高清设计图尺寸</h2><p>Google官方给出的高清设计图尺寸有两种方案，一种是以mdpi设计，然后对应放大得到更高分辨率的图片，另外一种则是以高分辨率作为设计大小，然后按照倍数对应缩小到小分辨率的图片。<br>根据经验，我更推荐第二种方法，因为小分辨率在生成高分辨率图片的时候，会出现像素丢失，我不知道是不是有方法可以阻止这种情况发生。<br>而分辨率可以以1280*720或者是1960*1080作为主要分辨率进行设计。</p><h2 id="ImageView的ScaleType属性"><a href="#ImageView的ScaleType属性" class="headerlink" title="ImageView的ScaleType属性"></a>ImageView的ScaleType属性</h2><p>设置不同的ScaleType会得到不同的显示效果，一般情况下，设置为centerCrop能获得较好的适配效果。</p><h2 id="动态设置"><a href="#动态设置" class="headerlink" title="动态设置"></a>动态设置</h2><p>有一些情况下，我们需要动态的设置控件大小或者是位置，比如说popwindow的显示位置和偏移量等，这个时候我们可以动态的获取当前的屏幕属性，然后设置合适的数值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ScreenSizeUtil &#123;</span><br><span class="line"></span><br><span class="line">public static int getScreenWidth(Activity activity) &#123;</span><br><span class="line">return activity.getWindowManager().getDefaultDisplay().getWidth();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int getScreenHeight(Activity activity) &#123;</span><br><span class="line">return activity.getWindowManager().getDefaultDisplay().getHeight();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考资料</strong><br><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/45419023" target="_blank" rel="noopener">Android屏幕适配全攻略(最权威的官方适配指导)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android的屏幕适配一直以来都在折磨着我们这些开发者，本篇文章将以Google的官方文档为基础，全面而深入的讲解Android屏幕适配的原因、重要概念、解决方案及最佳实践。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="屏幕适配" scheme="http://yoursite.com/tags/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android软键盘</title>
    <link href="http://yoursite.com/2017/07/01/Android%E8%BD%AF%E9%94%AE%E7%9B%98/"/>
    <id>http://yoursite.com/2017/07/01/Android软键盘/</id>
    <published>2017-07-01T08:45:15.000Z</published>
    <updated>2018-02-01T15:06:07.706Z</updated>
    
    <content type="html"><![CDATA[<p>说起Android软键盘，这里遇到的坑多数就是对它理解不够全面导致的，所以决定好好总结一下它。在避免自己二次掉坑的同时，如果能帮助到在这个知识区正疑惑的你，那就太好了。<a id="more"></a>本篇的讲解将分以下几个主题：</p><ol><li>操作软键盘</li><li>监听键盘的弹起与隐藏</li><li>如何避免键盘遮挡输入框</li></ol><h1 id="操作软键盘"><a href="#操作软键盘" class="headerlink" title="操作软键盘"></a>操作软键盘</h1><p>想要操作软键盘，需要使用到 InputMethodManager ，它是一个系统服务，可以使用 Context.getSystemService() 获取到它。</p><h4 id="显示软键盘"><a href="#显示软键盘" class="headerlink" title="显示软键盘"></a>显示软键盘</h4><p>在 InputMethodManager中，有两个方法showSoftInput()和showSoftInputFromInputMethod()，而实际上，只有showSoftInput()是有效的。<br><img src="http://chuantu.biz/t6/219/1517385812x-1376440126.jpg" alt=""><br>这里我们只需要传递两个参数。它首先需要一个View ，使用软键盘就是为了输入，而输入就需要有接收输入内容的View ，这里接收输入的View ，最好是一个EditText（但这不是必须的）。<br>而第二个参数flags就是个标志位，从上面截图的方法签名上的文档上可以看到，它接收0或者SHOW_INPYT_IMPLICIT 两个参数，但是实际上，它有第三个参数，另外一个是SHOW_FORCED。一般没有特别需要的话，我们直接传递0就好了(实际上SHOW_INPYT_IMPLICIT、SHOW_FORCED并不影响显示，只是在隐藏的时候，会有一些限制。而且我们一般的话，不管显示或者隐藏都将flag设置为0，特殊情况遇到再做分析)。<br>现在，简单总结一下调用showSoftInput()会生效的关键点：<br>1、第一个参数，最好是EditText或者它的子类。<br>考虑到软键盘就是为了输入，EditText就是一个接收输入的控件。而这不是绝对的，如果不是一个EditText ，就必须要求这个View有两个属性，分别是：android:focusable=”true” 和android:focusableInTouchMode=”true”。<br>2、第一个参数，必须是可获取焦点的，并且当前已经获取到焦点。<br>EditText默认是允许获取焦点的，但是假如布局中，存在多个可获取焦点的控件，就需要提前让我们传递进去的View获取到焦点。获取焦点可以使用requestFocus()方法。<br>3、布局必须加载完成。<br>在onCreate()中，如果立即调用showSoftInput()是不会生效的。想要在页面一启动的时候就弹出键盘，可以在Activity上，设置 android:windowSoftInputMode属性来完成，或者做一个延迟加载，View.postDelayed()也是一个解决方案。<br>所以最终，完整的显示软键盘的代码就如下所示了。<br><img src="http://chuantu.biz/t6/219/1517388117x-1566688473.jpg" alt=""></p><h4 id="隐藏软键盘"><a href="#隐藏软键盘" class="headerlink" title="隐藏软键盘"></a>隐藏软键盘</h4><p>虽然showSoftInput()方法是有效的，但是想要隐藏软键盘，就没有提供对应的hideSoftInput()方法，但是却有一个hideSoftInputFromWindow()方法，可以用来隐藏软键盘。<br>先来看看这个方法的签名，它同样有两个方法可以调用。<br><img src="http://chuantu.biz/t6/219/1517389975x-1566688473.jpg" alt=""><br>它接收两个参数，第一个参数是一个IBinder ，可以直接传递一个 View.getWindowToken()的windowToken对象就可以了。而第二个参数，就是隐藏软键盘的标志位，如果没有特殊要求的话，直接传递0就好了。</p><blockquote><p><strong>注意：</strong>这里虽然原则上需要传递一个之前弹出键盘传递的时候，传递的View的windowToken，但是实际情况是你只需要传递一个存在于当前布局ViewTree中，随意一个View的windowToken就可以了。</p></blockquote><p>最终隐藏软件的代码就是这样的。<br><img src="http://chuantu.biz/t6/219/1517390114x-1376440126.jpg" alt=""></p><h4 id="切换键盘的弹出和隐藏"><a href="#切换键盘的弹出和隐藏" class="headerlink" title="切换键盘的弹出和隐藏"></a>切换键盘的弹出和隐藏</h4><p>在InputMethodManager中，还提供了一个toggleSoftInput()方法，如同它的名字一样，它可以让软键盘在显示和隐藏之间切换。<br><img src="http://chuantu.biz/t6/219/1517390204x-1376440126.jpg" alt=""><br>该方法，接收两个flags ，分别是控制show和hide时候的标识，它们的含义和前面介绍的showSoftInput()和hideSoftInputFromWindow()一致，所以没有特殊要求，直接传递0就好了。<br>toggleSoftInput()方法不要求传递一个View或者windowToken，所以它并没有showSoftInput()中的一些限制，但是依然还有需要在布局绘制完成之后调用才会有效果。<br><img src="http://chuantu.biz/t6/219/1517390295x-1376440126.jpg" alt=""><br>虽然这个方法，限制很少，但是我们基本上不会使用它。主要原因在于，它是一个开关的方法，会根据当前的状态做相反的操作。这就导致很多时候，我们在代码中，无法直接根据InputMethodManager提供的方法判断当前软键盘的显示状态，这样也就无法确定调用它的时候的效果了。</p><h1 id="监听键盘的弹起与隐藏"><a href="#监听键盘的弹起与隐藏" class="headerlink" title="监听键盘的弹起与隐藏"></a>监听键盘的弹起与隐藏</h1><p>如果想要监听键盘的弹出和收起，可以使用<code>ViewTreeObserver.OnGlobalLayoutListener</code>这个监听，来监听布局的调整，从而判断出键盘的弹出和隐藏。下面是一个使用ViewTreeObserver.OnGlobalLayoutListener后获取屏幕中各个类型高度的例子，请注意代码中的注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getDecorView().getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onGlobalLayout() &#123;</span><br><span class="line">Log.d(&quot;sss_main&quot;, &quot;root.getHeight(): &quot; + root.getHeight());//当前所引用视图的高度</span><br><span class="line">Log.d(&quot;sss_main&quot;, &quot;root.getRootView().getHeight(): &quot; + root.getRootView().getHeight());//屏幕高度</span><br><span class="line">Log.d(&quot;sss_main&quot;, &quot;getWindow().getDecorView(): &quot; + getWindow().getDecorView().getHeight());//屏幕高度</span><br><span class="line">Rect r = new Rect();</span><br><span class="line">getWindow().getDecorView().getWindowVisibleDisplayFrame(r);</span><br><span class="line">Log.d(&quot;sss_main&quot;, &quot;r.top: &quot; + r.top);//状态栏高度</span><br><span class="line">Log.d(&quot;sss_main&quot;, &quot;r.bottom-r.top: &quot; + (r.bottom - r.top));//用户界面的可视高度（除去状态栏和底部导航）</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>代码中<code>r.bottom - r.top</code>代表了除去状态栏、底部导航栏后，手机屏幕剩余可视高度。注意，这个剩余可视高度也不包括输入法弹窗的高度（如果屏幕中有输入法弹窗的话）。有了以上的基础，我们就可以通过<code>getWindow().getDecorView().getHeight()-r.bottom&gt;100?键盘弹出：键盘隐藏</code>来判断键盘是否隐藏了。</p><blockquote><p><strong>注意：</strong>为什么要大于100呢？因为如果手机具备底部导航区域的话，要排除这个值的干扰。当然了，直接默认底部导航区域高度为100肯定是不精确的，实际应用中我们应该获取到真实的底部导航区域高度，具体如何获取底部导航区域高度可以<a href="http://blog.csdn.net/u012764110/article/details/49783465" target="_blank" rel="noopener">参考这篇文章</a>。</p></blockquote><h1 id="如何避免键盘遮挡输入框"><a href="#如何避免键盘遮挡输入框" class="headerlink" title="如何避免键盘遮挡输入框"></a>如何避免键盘遮挡输入框</h1><p>在开发中，经常会遇到键盘挡住输入框的情况，比如登录界面或注册界面，弹出的软键盘把登录或注册按钮挡住了，用户必须把软键盘收起，才能点击相应按钮，这样的用户体验非常不好。下面对几种在开发中常用的避免键盘遮挡输入框的方法进行总结。</p><h4 id="方法一：windowSoftInputMode-adjustResize和adjustPan"><a href="#方法一：windowSoftInputMode-adjustResize和adjustPan" class="headerlink" title="方法一：windowSoftInputMode:adjustResize和adjustPan"></a>方法一：windowSoftInputMode:adjustResize和adjustPan</h4><p>主要实现方法：在 AndroidManifest.xml 对应的Activity里添加 android:windowSoftInputMode=”adjustPan” 或是 android:windowSoftInputMode=”adjustResize”属性<br>这两种属性的区别，官方的解释是：<br><img src="http://chuantu.biz/t6/219/1517465893x-1404793363.jpg" alt=""><br>这两个属性作用都是为了调整界面使键盘不挡住输入框,这里对这两种属性使用场景、优缺点、注意事项进行了全方面总结。对于<code>fitsystemwindows</code>还比较懵逼的你，可以参考<a href="http://blog.csdn.net/u012885461/article/details/51068553" target="_blank" rel="noopener">这篇文章</a>。<br><img src="http://chuantu.biz/t6/219/1517467968x-1404793363.jpg" alt=""><br>最后附一张官方的截图。<br><img src="http://chuantu.biz/t6/220/1517474475x-1376440240.png" alt="该属性是在 API 级别 3 引入的。"></p><blockquote><p><strong>插播知识：</strong><br>这里再提一下clipToPadding和clipChildren这两个属性吧，虽然和本篇没有关系但是同样是有一定概率出现的，所以要讲一下。clipToPadding就是说控件的绘制区域是否在padding里面的，true的情况下如果你设置了padding那么绘制的区域就往里缩，clipToPadding主要应用在listview头部和尾部设置padding后希望可以在滑动item时能滑动到padding区域。clipChildren表示是否限制子View在所属父View的范围内，我们将其值设置为false后那么当子控件的高度高于父控件时也会完全显示,而不会被压缩。注意clipChildren一定是在布局文件的根节点设置，否则不起作用,具体请看<a href="http://blog.csdn.net/flymoon1201/article/details/44646473" target="_blank" rel="noopener">这篇文章</a>。</p></blockquote><h4 id="方法二：当键盘弹起时，让界面整体上移；键盘收起，让界面整体下移"><a href="#方法二：当键盘弹起时，让界面整体上移；键盘收起，让界面整体下移" class="headerlink" title="方法二：当键盘弹起时，让界面整体上移；键盘收起，让界面整体下移"></a>方法二：当键盘弹起时，让界面整体上移；键盘收起，让界面整体下移</h4><p>使用场景：针对界面全屏模式，输入框不会被键盘遮挡。主要用于一些登录界面，或是需要把界面整体都顶上去的场景。</p><h5 id="1､主要实现步骤"><a href="#1､主要实现步骤" class="headerlink" title="1､主要实现步骤"></a>1､主要实现步骤</h5><p>(1). 获取Activity布局xml的最外层控件，如xml文件如下：<br><img src="http://chuantu.biz/t6/219/1517470659x-1404758299.jpg" alt=""><br>先获取到最外层控件:<br>RelativeLayout main = (RelativeLayout) findViewById(R.id.main);<br>(2). 获取到最后一个控件，如上面的xml文件，最后一个控件是Button:<br>Button login_btn = (Button) findViewById(R.id.login_btn);<br>(3). 给最外层控件和最后一个控件添加监听事件:<br><img src="http://chuantu.biz/t6/219/1517470713x-1404758299.jpg" alt=""></p><h5 id="2､实现原理"><a href="#2､实现原理" class="headerlink" title="2､实现原理"></a>2､实现原理</h5><p>此方法通过监听 Activity 最外层布局控件来检测软键盘是否弹出，然后去手动调用控件的 scrollTo方法 达到调整布局目的。</p><hr><p><strong>参考资料</strong><br>1.<a href="https://segmentfault.com/a/1190000012279204" target="_blank" rel="noopener">Android软键盘的显示与隐藏</a><br>2.<a href="http://www.10tiao.com/html/227/201705/2650239474/1.html" target="_blank" rel="noopener">Android各种键盘挡住输入框解决办法</a><br>3.<a href="https://developer.android.com/guide/topics/manifest/activity-element.html?hl=zh-cn" target="_blank" rel="noopener">API指南</a><br>4.<a href="https://stackoverflow.com/questions/2150078/how-to-check-visibility-of-software-keyboard-in-android" target="_blank" rel="noopener">stackoverflow:监听软件的弹出与隐藏</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起Android软键盘，这里遇到的坑多数就是对它理解不够全面导致的，所以决定好好总结一下它。在避免自己二次掉坑的同时，如果能帮助到在这个知识区正疑惑的你，那就太好了。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="软键盘" scheme="http://yoursite.com/tags/%E8%BD%AF%E9%94%AE%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>GlobalDialog框架使用教程</title>
    <link href="http://yoursite.com/2017/06/10/GlobalDialog%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/06/10/GlobalDialog框架使用教程/</id>
    <published>2017-06-10T00:37:54.000Z</published>
    <updated>2017-12-29T11:35:38.162Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2109293-cdafa26ebd9bd991.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请勿模仿。"><br>GlobalDialog是由<a href="http://italkyou.bmob.site" target="_blank" rel="noopener">ITalk应用</a>开源的一款全局对话框库。相比于Android原生对话框的繁琐配置，GlobalDialog的优势在于能够快速实现<strong>全局对话框</strong>的功能（通知账号下线、通知账号异常等）。进一步了解，请访问笔者的<a href="https://github.com/tangxianming/global-dialog" target="_blank" rel="noopener">Github</a>。<br><a id="more"></a> </p><p>#集成方法<br>在Module的build.gradle文件中添加如下依赖即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.txm.topcodes.globaldialog:globaldialog:0.1.6&apos;</span><br></pre></td></tr></table></figure></p><p>#调用方式<br>常规方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new GlobalDialog.Builder()</span><br><span class="line">.setContext(context) </span><br><span class="line">.setDescription(&quot;hello world&quot;) //弹出框的提示信息。</span><br><span class="line">.setStyle(GlobalDialog.Style.SingleAlert) //弹窗的样式。有DoubleAlert、SingleAlert两种，默认为后者。</span><br><span class="line">.setForce(ture) //设置弹框销毁的策略。默认为true。</span><br><span class="line">.setDialogClickListener(new OnDialogClickListener() &#123; //设置回调，也可以不设置。</span><br><span class="line">@Override</span><br><span class="line">public void onSure() &#123;</span><br><span class="line">super.onSure();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).build().show();</span><br></pre></td></tr></table></figure></p><p>精简方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new GlobalDialog.Builder()</span><br><span class="line">.setContext(context) </span><br><span class="line">.setDescription(&quot;hello world&quot;) </span><br><span class="line">.build().show();</span><br></pre></td></tr></table></figure></p><p>#FAQ</p><hr><p><strong>我发现GlobalDialog还存在BUG？</strong><br>GlobalDialog是一个完全开源的框架，如果您在使用过程中发现问题，欢迎在笔者的GitHub创建一个<a href="https://github.com/tangxianming/global-dialog/issues" target="_blank" rel="noopener">Issue</a>。</p><p><strong>我是Eclipse用户，可以使用GlobalDialog么？</strong><br>不可以。</p><p><strong>我在Android studio中链接GlobalDialog库失败了？</strong><br>确保您的工程使用的远程仓库为jcenter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">jcenter()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2109293-cdafa26ebd9bd991.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;请勿模仿。&quot;&gt;&lt;br&gt;GlobalDialog是由&lt;a href=&quot;http://italkyou.bmob.site&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ITalk应用&lt;/a&gt;开源的一款全局对话框库。相比于Android原生对话框的繁琐配置，GlobalDialog的优势在于能够快速实现&lt;strong&gt;全局对话框&lt;/strong&gt;的功能（通知账号下线、通知账号异常等）。进一步了解，请访问笔者的&lt;a href=&quot;https://github.com/tangxianming/global-dialog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="我的Android框架" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84Android%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="View" scheme="http://yoursite.com/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Android实现阴影效果的三种方式</title>
    <link href="http://yoursite.com/2017/05/20/Android%E5%AE%9E%E7%8E%B0%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/05/20/Android实现阴影效果的三种方式/</id>
    <published>2017-05-20T09:27:38.000Z</published>
    <updated>2018-01-27T09:40:54.525Z</updated>
    
    <content type="html"><![CDATA[<p>实现Android阴影共有三种方式：使用.9图（略）、设置视图的高度、在layer-list资源文件中模拟阴影效果，本篇文章将对后两种方式做介绍。<a id="more"></a></p><h1 id="视图高度（Z值）实现阴影"><a href="#视图高度（Z值）实现阴影" class="headerlink" title="视图高度（Z值）实现阴影"></a>视图高度（Z值）实现阴影</h1><p>Material Design为UI元素引入了高度（Z值）概念，拥有较高 Z 值的视图将投射更大且更柔和的阴影，并将挡住拥有较低Z值的视图，不过视图的Z值并不影响视图的大小。阴影的效果是由被提升视图的父项所提供的，因此阴影裁剪也是受父视图影响的，<strong>值得注意的是，如果父视图没有提供额外的空间给被提升视图，则阴影效果不会被展现。</strong></p><h4 id="指定视图高度"><a href="#指定视图高度" class="headerlink" title="指定视图高度"></a>指定视图高度</h4><p>视图的Z值包含两个组件：</p><ul><li>高度：静态组件。</li><li>转换：用于动画的动态组件。</li></ul><p>Z = elevation + translationZ<br><img src="http://upload.ouliu.net/i/20180127163857w285w.png" alt="不同视图高度的阴影。"><br>如果要在布局定义中设置视图的高度，请使用 <code>android:elevation</code> 属性。如果要在Activity的代码中设置视图高度，请使用 <code>View.setElevation()</code> 方法。<br>如果要设置视图转换，请使用 <code>View.setTranslationZ()</code> 方法，同时，该方法可以通过<strong>属性动画</strong>为视图高度添加动画。</p><h4 id="自定义视图阴影"><a href="#自定义视图阴影" class="headerlink" title="自定义视图阴影"></a>自定义视图阴影</h4><p>视图的背景将决定其阴影的默认形状，下面举一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">android:id=&quot;@+id/myview&quot;</span><br><span class="line">...</span><br><span class="line">android:elevation=&quot;2dp&quot;</span><br><span class="line">android:background=&quot;@drawable/myrect&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>背景被定义为一个拥有圆角的矩形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- res/drawable/myrect.xml --&gt;</span><br><span class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:shape=&quot;rectangle&quot;&gt;</span><br><span class="line">&lt;solid android:color=&quot;#42000000&quot; /&gt;</span><br><span class="line">&lt;corners android:radius=&quot;5dp&quot; /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure></p><p>视图将投射一个带有圆角的阴影，因为背景将定义视图的轮廓。 如果提供一个自定义轮廓，则此轮廓将替换视图阴影的默认形状。</p><h1 id="layer-list模拟阴影效果"><a href="#layer-list模拟阴影效果" class="headerlink" title="layer-list模拟阴影效果"></a>layer-list模拟阴影效果</h1><p>使用layer-list可以将多个drawable按照顺序层叠在一起显示，默认情况下，所有的item中的drawable都会自动根据所依附view的大小而进行缩放，layer-list中的item是按照顺序从下往上叠加的，即先定义的item在下面，后面的依次往上面叠放。以下是带阴影的圆角矩形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">&lt;item</span><br><span class="line">android:left=&quot;2dp&quot;</span><br><span class="line">android:top=&quot;2dp&quot;&gt;</span><br><span class="line">&lt;shape&gt;</span><br><span class="line">&lt;corners android:radius=&quot;20dp&quot; /&gt;</span><br><span class="line">&lt;solid android:color=&quot;#acacac&quot; /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br><span class="line">&lt;/item&gt;</span><br><span class="line">&lt;item</span><br><span class="line">android:right=&quot;2dp&quot;</span><br><span class="line">android:bottom=&quot;2dp&quot;&gt;</span><br><span class="line">&lt;shape&gt;</span><br><span class="line">&lt;corners android:radius=&quot;20dp&quot; /&gt;</span><br><span class="line">&lt;solid android:color=&quot;#FFFFFF&quot; /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br><span class="line">&lt;/item&gt;</span><br><span class="line">&lt;/layer-list&gt;</span><br></pre></td></tr></table></figure></p><p>layer-list可以添加多个item子节点，每个item子节点对应一个drawable资源，按照item从上到下的顺序叠加在一起，再通过设置每个item的偏移量就可以看到阴影等效果了。layer-list的item可以通过下面四个属性设置偏移量：<br>android:top 顶部的偏移量<br>android:bottom 底部的偏移量<br>android:left 左边的偏移量<br>android:right 右边的偏移量<br>这四个偏移量和控件的margin设置差不多，都是外间距的效果。</p><h1 id="两种方式对比"><a href="#两种方式对比" class="headerlink" title="两种方式对比"></a>两种方式对比</h1><table><thead><tr><th>视图高度</th><th>layer-list资源</th></tr></thead><tbody><tr><td>只兼容Android 5.0以上版本</td><td>都兼容</td></tr><tr><td>效果逼真</td><td>效果不真实</td></tr><tr><td>需要额外的空间展示阴影</td><td>不需要额外的空间</td></tr></tbody></table><hr><p><strong>参考资料</strong><br>1.<a href="https://developer.android.com/training/material/shadows-clipping.html?hl=zh-cn" target="_blank" rel="noopener">定义阴影</a><br>2.<a href="http://blog.csdn.net/u014695188/article/details/52815444" target="_blank" rel="noopener">Android中layer-list使用详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现Android阴影共有三种方式：使用.9图（略）、设置视图的高度、在layer-list资源文件中模拟阴影效果，本篇文章将对后两种方式做介绍。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="layer-list" scheme="http://yoursite.com/tags/layer-list/"/>
    
      <category term="elevation" scheme="http://yoursite.com/tags/elevation/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceView使用教程</title>
    <link href="http://yoursite.com/2017/04/26/SurfaceView%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/04/26/SurfaceView使用教程/</id>
    <published>2017-04-26T14:53:28.000Z</published>
    <updated>2018-01-27T03:02:40.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>SurfaceView是视图(View)的继承类，这个视图里内嵌了一个专门用于绘制的Surface。你可以控制这个Surface的格式和尺寸。Surfaceview控制这个Surface的绘制位置。<a id="more"></a><br>Surface是纵深排序(Z-ordered)的，这表明它总在自己所在窗口的后面。Surfaceview提供了一个可见区域，只有在这个可见区域内Surface部分内容才可见，可见区域外的部分不可见。<br>Surface的排版显示受到视图层级关系的影响，它的兄弟视图结点会在顶端显示。这意味者 surface 的内容会被它的兄弟视图遮挡，这一特性可以用来放置遮盖物(overlays)(例如，文本和按钮等控件)。如果 surface 上面有透明控件，那么它的每次变化都会引起框架重新计算它和顶层控件之间的透明效果，这会影响性能。<br>你可以通过getHolder()返回的SurfaceHolder实例访问Surface。Surfaceview变得可见时，Surface被创建；Surfaceview隐藏前，Surface被销毁，这样能节省资源。如果你要查看Surface被创建和销毁的时机，可以重载surfaceCreated(SurfaceHolder)和 surfaceDestroyed(SurfaceHolder)。<br>这里应注意： </p><ol><li>所有SurfaceView和SurfaceHolder.Callback的方法都会在UI线程里调用，一般来说就是应用程序主线程。所以渲染线程所要访问的各种变量应该作同步处理。 </li><li>由于Surface可能被销毁，它只在SurfaceHolder.Callback.surfaceCreated()和SurfaceHolder.Callback.surfaceDestroyed()之间有效，所以要确保渲染线程访问的是合法有效的Surface。</li></ol><blockquote><p><strong>SurfaceView最终会和UI线程打交道：</strong><br>SurfaceView带有独立的Surface（独立与Window的Surface），这可以让子线程在独立的Surface上面绘制东西，进行SurfaceView的界面绘制，这个子线程就叫做渲染线程，但是要让独立的Surface上面的东西在View上面展示出来，需要post一个消息给主线程，目的是把该Surface中canvas 上的东西绘制到View的真正的画布上面（window的Surface的canvas上）。</p></blockquote><h1 id="SurfaceView和View的不同之处"><a href="#SurfaceView和View的不同之处" class="headerlink" title="SurfaceView和View的不同之处"></a>SurfaceView和View的不同之处</h1><table><thead><tr><th>View</th><th>SurfaceView</th></tr></thead><tbody><tr><td>适用于主动更新</td><td>适用于被动刷新</td></tr><tr><td>在主线程中进行画面更新</td><td>通常通过一个子线程来进行画面更新</td></tr><tr><td>绘图中没有使用双缓冲机制</td><td>在底层实现中就实现了双缓冲机制</td></tr></tbody></table><p>比较了上面的不同之处，显然可以发现，如果一个View需要频繁的刷新，或者在刷新时数据处理量大（可能引起卡顿），可以考虑使用SurfaceView来替代View。</p><h4 id="SurfaceView的双缓冲机制"><a href="#SurfaceView的双缓冲机制" class="headerlink" title="SurfaceView的双缓冲机制"></a>SurfaceView的双缓冲机制</h4><p>对于每一个SurfaceView对象而言，有两个独立的graphic buffer。在Android SurfaceView的双缓冲机制中是这样实现的：<br>在Buffer A中绘制内容，然后让屏幕显示Buffer A；在下一个循环中，在Buffer B中绘制内容，然后让屏幕显示Buffer B，如此往复。而由于这个双缓冲机制的存在，可能会引起闪屏现象。在第一个”lockCanvas-drawCanvas-unlockCanvasAndPost “循环中，更新的是buffer A的内容；到下一个”lockCanvas-drawCanvas-unlockCanvasAndPost”循环中，更新的是buffer B的内容。 如果buffer A与buffer B中某个buffer内容为空，当屏幕轮流显示它们时，就会出现画面黑屏闪烁现象。<br><strong>解决方法:</strong><br>当准备更新内容时，先判断内容是否为空，只有非空时才启动”lockCanvas-drawCanvas-unlockCanvasAndPost”这个流程。</p><h1 id="SurfaceView使用步骤"><a href="#SurfaceView使用步骤" class="headerlink" title="SurfaceView使用步骤"></a>SurfaceView使用步骤</h1><ol><li>获取到SurfaceView对应的SurfaceHolder，通过addCallback()方法设置SurfaceHolder.Callback用于监听Surface的创建和销毁。</li><li>创建渲染线程对象。</li><li>在子线程中使用SurfaceHolder的lockCanvas获取Surface上面指定区域的Canvas。</li><li>在该Canvas上绘制图形。绘制结束后，使用SurfaceHolder的unlockCanvasAndPost（）方法解锁Canvas，并且让UI线程把Surface上面的东西绘制到View的Canvas上面。</li></ol><h4 id="使用SurfaceHolder的例子"><a href="#使用SurfaceHolder的例子" class="headerlink" title="使用SurfaceHolder的例子"></a>使用SurfaceHolder的例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class GameUI extends SurfaceView implements SurfaceHolder.Callback &#123;</span><br><span class="line">private SurfaceHolder holder;</span><br><span class="line">private RenderThread renderThread;</span><br><span class="line">private boolean isDraw = false;</span><br><span class="line"></span><br><span class="line">public GameUI(Context context) &#123;</span><br><span class="line">super(context);</span><br><span class="line">holder = getHolder();</span><br><span class="line">holder.addCallback(this);</span><br><span class="line">renderThread = new RenderThread();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public GameUI(Context context, AttributeSet attrs) &#123;</span><br><span class="line">super(context, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public GameUI(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">super(context, attrs, defStyleAttr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void surfaceCreated(SurfaceHolder holder) &#123;</span><br><span class="line">isDraw = true;</span><br><span class="line">if (!renderThread.isAlive()) &#123;</span><br><span class="line">renderThread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void surfaceDestroyed(SurfaceHolder holder) &#123;</span><br><span class="line">isDraw = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class RenderThread extends Thread &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">super.run();</span><br><span class="line">while (isDraw) &#123;</span><br><span class="line">drawUI();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void drawUI() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Canvas canvas = holder.lockCanvas();</span><br><span class="line">drawCanvas(canvas);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">//由于双缓冲机制的存在，判断画布是否为空，从而避免黑屏情况。</span><br><span class="line">if(canvas!=null)&#123;</span><br><span class="line">holder.unlockCanvasAndPost(canvas);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void drawCanvas(Canvas canvas) &#123;</span><br><span class="line">// 在 canvas 上绘制需要的图形</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>参考资料</strong><br>1.<a href="https://developer.android.com/reference/android/view/SurfaceView.html" target="_blank" rel="noopener">SurfaceView</a><br>2.<a href="https://www.cnblogs.com/zhangyingai/p/7087371.html" target="_blank" rel="noopener">SurfaceView的基本使用</a><br>3.<a href="http://blog.csdn.net/zhaoyw2008/article/details/45825069" target="_blank" rel="noopener">SurfaceView基础用法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;SurfaceView是视图(View)的继承类，这个视图里内嵌了一个专门用于绘制的Surface。你可以控制这个Surface的格式和尺寸。Surfaceview控制这个Surface的绘制位置。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="SurfaceView" scheme="http://yoursite.com/tags/SurfaceView/"/>
    
  </entry>
  
  <entry>
    <title>WebView使用教程</title>
    <link href="http://yoursite.com/2017/03/10/WebView%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/03/10/WebView使用教程/</id>
    <published>2017-03-10T13:03:15.000Z</published>
    <updated>2018-01-27T03:07:22.213Z</updated>
    
    <content type="html"><![CDATA[<p>如果你想在将web页面作为APP的一部分，那么我们可以使用WebView。WebView在Android中继承了view类，作为承载网页的控件。但是我们应该知道它并没有继承web浏览器的所有特性，它所实现的也只是展示网页，以及一些基本的交互和监听功能。<a id="more"></a><br>WebView经常被使用的场景是，当你的APP需要向用户展示一个随时可更新的内容，比如用户条款、使用向导。那么这样的话，我们可以在一个Activity中包含一个WebView控件用来展示服务器维护的内容，这些内容可以在服务器随时更改。<br>WeblView另一个使用场景是，当我们需要在一个页面中请求所有用户的数据，一般的做法是写一个layout，然后利用网络请求所有所需数据，最后将这些数据填充到layout中。但最简洁的方式是，我们其实可以直接加载一个网页，这个网页包含了需要的数据。<br>这个教程将帮助你学会使用WebView，以及关于它高级一点的用法，比如页面跳转、js交互等。</p><h1 id="添加WebView到你的应用"><a href="#添加WebView到你的应用" class="headerlink" title="添加WebView到你的应用"></a>添加WebView到你的应用</h1><p>添加WebView到你的应用最简单的方式是在Layout中添加&lt; WebView &gt;标签，例如下面的例子表示一个全屏的WebView。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;WebView  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:id=&quot;@+id/webview&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><p>加载网页，调用loadUrl()方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.loadUrl(&quot;http://www.example.com&quot;);</span><br></pre></td></tr></table></figure></p><p>请求服务器网页时，别忘了要加网络请求权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest ... &gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure></p><p>以上就是最简单的加载网页方式。</p><h1 id="在WebView中使用JavaScript"><a href="#在WebView中使用JavaScript" class="headerlink" title="在WebView中使用JavaScript"></a>在WebView中使用JavaScript</h1><p>如果你在APP展示的网页中包含JS，那么请确保WebView支持JS的加载。在此之后，你还可以新建接口让WebView与Android代码交互。</p><h2 id="授权使用JavaScript"><a href="#授权使用JavaScript" class="headerlink" title="授权使用JavaScript"></a>授权使用JavaScript</h2><p>WebView默认不支持JS的加载，开启它需要调用WebSetting的setJavaScriptEnable()方法。WebSetting可以通过WebView的getSettings()方法获得。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">WebSettings webSettings = myWebView.getSettings();</span><br><span class="line">webSettings.setJavaScriptEnabled(true);</span><br></pre></td></tr></table></figure></p><p>WebSetting提供了许多使用性的功能，比如你想让你幸幸苦苦开发的web page只能在自己的android应用中展示，那么可以在客户端通过setUserAgentString()设置用户代理之后，在服务端遍历userAgentString字段是否是自己的客户端所设定的。</p><h2 id="在Android代码中绑定JavaScript代码"><a href="#在Android代码中绑定JavaScript代码" class="headerlink" title="在Android代码中绑定JavaScript代码"></a>在Android代码中绑定JavaScript代码</h2><p>通过接口的方式，你可以使你的Android代码和JavaScript代码进行交互。例如，你的JavaScript代码可以调用Android代码弹出一个提示框，而不是使用JavaScript的Alert（）方法。<br>让JavaScript和Android代码产生联系的关键是addJavaScriptInterface()方法，此方法包含两个参数，第一个是一个类对象，供JavaScript调用。第二个是接口名称，它用在JavaScript中作为调用Android方法的别名。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class WebAppInterface &#123;</span><br><span class="line">Context mContext;</span><br><span class="line"></span><br><span class="line">/** Instantiate the interface and set the context */</span><br><span class="line">WebAppInterface(Context c) &#123;</span><br><span class="line">mContext = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Show a toast from the web page */</span><br><span class="line">@JavascriptInterface</span><br><span class="line">public void showToast(String toast) &#123;</span><br><span class="line">Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>特别提醒：</strong>如果你的Android目标SDK版本在17或以上，你必须在那些将要在JavaScript中调用的方法体前使用@JavascriptInterface标识。否则，这些方法将不会被调用。</p></blockquote><p>在这个实例中，WebAppInterface允许JavaScript运行showToast方法弹出一个Toast。<br>你可以运行这段代码通过WebView的addJavaScriptInterface()方法，并指定接口的名称为“Android”，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView webView = (WebView) findViewById(R.id.webview);</span><br><span class="line">webView.addJavascriptInterface(new WebAppInterface(this), &quot;Android&quot;);</span><br></pre></td></tr></table></figure></p><p>这段代码为运行在WebView中的JavaScript创建了一个接口“Android”，那么现在你的JavaScript已经有能力访问WebAppInterface中的showToast方法了。下面的HTML和JS代码将调用showToast方法弹出Toast提示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;Say hello&quot; onClick=&quot;showAndroidToast(&apos;Hello Android!&apos;)&quot; /&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function showAndroidToast(toast) &#123;</span><br><span class="line">Android.showToast(toast);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>如你所看到的，在JS中使用“Android”这个接口时，并不需要初始化它，在此之前，WebView已经为你准备好了一些，你只需要通过它调用逻辑即可。</p><blockquote><p><strong>注意：</strong><br>1.WebAppInterface的实例将运行在另一个线程，并不在原来新建它的线程。<br>2.由于通过JS可以调用本地的Android代码，那么我们对于这点要非常的谨慎。对于不受信任的web链接，不应该使用addJavascriptInterface()，除非这个链接是自己本人写的或者其它应该充分信任它的理由。同时，对于不信任的网站，我们在处理它的跳转时应该非常小心，不应该在我们的WebView中直接接受链接的跳转。（默认情况，WebView网页中的链接会跳转到手机的Web浏览器，这是保证安全的前提下一种很好的处理方法。但是，在接下来会提到的serWebViewClient()方法中，你可以自定义链接的行为，这就需要小心了。）</p></blockquote><h1 id="页面导航"><a href="#页面导航" class="headerlink" title="页面导航"></a>页面导航</h1><p>当用户在WebView点击一个链接后，默认的行为是在web浏览器中打开该链接所指向的网页。正如上面所提及的一样，你是可以通过WebView的serWebViewClient方法自定义这个行为的。例如在自己的WebView中展示跳转的内容，而不是跳转到web浏览器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.setWebClient(new WebClient());</span><br></pre></td></tr></table></figure></p><p>当然你还可以做更多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private class MyWebViewClient extends WebViewClient &#123;</span><br><span class="line">@Override</span><br><span class="line">public boolean shouldOverrideUrlLoading(WebView view,String url)&#123;</span><br><span class="line">if (Uri.parse(url).getHost().equals(&quot;www.example.com&quot;)) &#123;</span><br><span class="line">// This is my web site, so do not override; let my WebView load the page</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">// Otherwise, the link is not for a page on my site, so launch another Activity that handles URLs</span><br><span class="line">Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));</span><br><span class="line">startActivity(intent);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后创建MyWebViewClient的实例作为setWebClient()的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.setWebClient(new MyWebViewClient());</span><br></pre></td></tr></table></figure></p><h2 id="导航web的浏览记录"><a href="#导航web的浏览记录" class="headerlink" title="导航web的浏览记录"></a>导航web的浏览记录</h2><p>在WebView中浏览网页时，我们可能会通过web中包含的外链跳转到其它的网页（在同一Webview页面中），那么这些跳转记录是可以来回切换的，这里主要涉及到goBack()和goForward()方法的使用。<br>例如下面的例子，我们通过设备的返回按钮让WebView回退到上一个页面，或者退出当前Activity。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onKeyDown(int keyCode, KeyEvent event) &#123;</span><br><span class="line">    // Check if the key event was the Back button and if there&apos;s history</span><br><span class="line">    if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; myWebView.canGoBack()) &#123;</span><br><span class="line">        myWebView.goBack());</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // If it wasn&apos;t the Back key or there&apos;s no web page history, bubble up to the default</span><br><span class="line">    // system behavior (probably exit the activity)</span><br><span class="line">    return super.onKeyDown(keyCode, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考资料</strong><br><a href="https://developer.android.com/guide/webapps/webview.html#HandlingNavigation" target="_blank" rel="noopener">Building Web Apps in WebView</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你想在将web页面作为APP的一部分，那么我们可以使用WebView。WebView在Android中继承了view类，作为承载网页的控件。但是我们应该知道它并没有继承web浏览器的所有特性，它所实现的也只是展示网页，以及一些基本的交互和监听功能。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="WebView" scheme="http://yoursite.com/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之Volatile和Automic</title>
    <link href="http://yoursite.com/2017/02/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BVolatile%E5%92%8CAutomic/"/>
    <id>http://yoursite.com/2017/02/21/Java并发编程之Volatile和Automic/</id>
    <published>2017-02-21T05:20:00.000Z</published>
    <updated>2018-01-22T12:09:24.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h1><p>当我们声明共享变量为volatile后，对这个变量的读/写将会很特别。理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步(实际上不是完全一样的，后面会提到)。下面我们通过具体的示例来说明，请看下面的示例代码：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class VolatileFeaturesExample &#123;</span><br><span class="line">//使用volatile声明64位的long型变量</span><br><span class="line">volatile long vl = 0L;</span><br><span class="line"></span><br><span class="line">public void set(long l) &#123;</span><br><span class="line">vl = l;   //单个volatile变量的写</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void getAndIncrement () &#123;</span><br><span class="line">vl++;    //复合（多个）volatile变量的读/写</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public long get() &#123;</span><br><span class="line">return vl;   //单个volatile变量的读</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设有多个线程分别调用上面程序的三个方法，这个程序在语义上和下面程序等价：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class VolatileFeaturesExample &#123;</span><br><span class="line">long vl = 0L;               // 64位的long型普通变量</span><br><span class="line"></span><br><span class="line">//对单个的普通 变量的写用同一个锁同步</span><br><span class="line">public synchronized void set(long l) &#123;             </span><br><span class="line">vl = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void getAndIncrement () &#123; //普通方法调用</span><br><span class="line">long temp = get();           //调用已同步的读方法</span><br><span class="line">temp += 1L;                  //普通写操作</span><br><span class="line">set(temp);                   //调用已同步的写方法</span><br><span class="line">&#125;</span><br><span class="line">public synchronized long get() &#123; </span><br><span class="line">//对单个的普通变量的读用同一个锁同步</span><br><span class="line">return vl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上面示例程序所示，对一个volatile变量的单个读/写操作，与对一个普通变量的读/写操作使用同一个锁来同步，它们之间的执行效果相同。<br>锁的<a href="http://www.baeldung.com/java-volatile" target="_blank" rel="noopener">happens-before规则</a>保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。<br>锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。<br>简而言之，volatile变量自身具有下列特性：<br>1.可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。<br>2.原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</p><h5 id="volatile-与-synchronized-的比较"><a href="#volatile-与-synchronized-的比较" class="headerlink" title="volatile 与 synchronized 的比较"></a>volatile 与 synchronized 的比较</h5><p>volatile主要用在多个线程感知实例变量被更改的场合，从而使得各个线程获得最新的值。比较：<br>①volatile轻量级，只能修饰变量。synchronized重量级，还可修饰方法。<br>②volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞。synchronized不仅保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。</p><h5 id="由锁释放和获取的内存语义引申volatile"><a href="#由锁释放和获取的内存语义引申volatile" class="headerlink" title="由锁释放和获取的内存语义引申volatile"></a>由锁释放和获取的内存语义引申volatile</h5><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须要“从主内存中去读取共享变量”。<strong><em>实际上，锁释放-获取的内存语义与volatile写-读的内存语义有着一一对应的关系，锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</em></strong><br>下面对锁释放和锁获取的内存语义做个总结（volatile的读、写类似）：</p><ol><li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</li><li>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</li><li>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</li></ol><h1 id="AtomicInteger介绍"><a href="#AtomicInteger介绍" class="headerlink" title="AtomicInteger介绍"></a>AtomicInteger介绍</h1><p>原子操作在多线程场景是很有必要的，它可以避免数据的二义性产生。下面的程序中我们新建了两个线程，每个线程对同一个数增加了4次，每次加1，最后的结果正确应该是8。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class JavaAtomic &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">ProcessingThread pt = new ProcessingThread();</span><br><span class="line">Thread t1 = new Thread(pt, &quot;t1&quot;);</span><br><span class="line">t1.start();</span><br><span class="line">Thread t2 = new Thread(pt, &quot;t2&quot;);</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(&quot;Processing count=&quot; + pt.getCount());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProcessingThread implements Runnable &#123;</span><br><span class="line">private int count;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">processSomething(i);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getCount() &#123;</span><br><span class="line">return this.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void processSomething(int i) &#123;</span><br><span class="line">// processing some job</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(i * 1000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行上面的程序后，你会发现最后的运行结果每次都不一样，可能是5，6，7或者8。原因就是count++不具备原子性，当一个线程读取了count的值并进行完加1操作时，另外一个线程还是引用的原来旧的count值，这样就导致了最后加1后的结果不符合预期的现象。<br>为了解决这个问题，我们除了可以使用Synchronized、Lock，还可以使用 Java 5 java.util.concurrent.atomic提供的AutomicInteger实现原子操作。并且在程序逻辑允许的情况下，我们应该优先使用atomic，<a href="https://www.callicoder.com/java-locks-and-atomic-variables-tutorial/" target="_blank" rel="noopener">它在执行速度、可读性、实用性方面均优于前两者</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class JavaAtomic &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">ProcessingThread pt = new ProcessingThread();</span><br><span class="line">Thread t1 = new Thread(pt, &quot;t1&quot;);</span><br><span class="line">t1.start();</span><br><span class="line">Thread t2 = new Thread(pt, &quot;t2&quot;);</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(&quot;Processing count=&quot; + pt.getCount());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProcessingThread implements Runnable &#123;</span><br><span class="line">private AtomicInteger count = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">processSomething(i);</span><br><span class="line">count.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getCount() &#123;</span><br><span class="line">return this.count.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void processSomething(int i) &#123;</span><br><span class="line">// processing some job</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(i * 1000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考资料</strong><br>1.<a href="http://ifeve.com/java-memory-model-4/" target="_blank" rel="noopener">并发编程网</a><br>2.<a href="https://www.journaldev.com/1095/atomicinteger-java" target="_blank" rel="noopener">AtomicInteger in Java</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;volatile的特性&quot;&gt;&lt;a href=&quot;#volatile的特性&quot; class=&quot;headerlink&quot; title=&quot;volatile的特性&quot;&gt;&lt;/a&gt;volatile的特性&lt;/h1&gt;&lt;p&gt;当我们声明共享变量为volatile后，对这个变量的读/写将会很特别。理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步(实际上不是完全一样的，后面会提到)。下面我们通过具体的示例来说明，请看下面的示例代码：&lt;br&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="并发编程" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之Lock</title>
    <link href="http://yoursite.com/2017/01/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BLock/"/>
    <id>http://yoursite.com/2017/01/14/Java并发编程之Lock/</id>
    <published>2017-01-14T11:35:01.000Z</published>
    <updated>2018-01-29T07:06:05.452Z</updated>
    
    <content type="html"><![CDATA[<p>相对于<a href="https://kimball325.github.io/2016/12/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Synchronized/" target="_blank" rel="noopener">Synchronized</a>,我们还可以使用更加人性化的Lock关键字作为线程同步的实现方案。本篇文章将详细介绍Lock的相关用法以及使用它的优势。<br><a id="more"></a></p><h1 id="使用Lock同步代码块"><a href="#使用Lock同步代码块" class="headerlink" title="使用Lock同步代码块"></a>使用Lock同步代码块</h1><p>Java提供另外的机制用来同步代码块。它比synchronized关键字更加强大、灵活。它是基于Lock接口和实现它的类（如ReentrantLock）。这种机制有如下优势：</p><ol><li>它允许以一种更灵活的方式来构建synchronized块。使用synchronized关键字，你必须以结构化方式得到释放synchronized代码块的控制权。Lock接口允许你获得更复杂的结构来实现你的临界区。</li><li>Lock接口比synchronized关键字提供更多额外的功能，新功能之一是它提供的tryLock()方法。这种方法试图获取锁的控制权并且如果它不能获取该锁是由于其他线程在使用这个锁，它将返回false。使用synchronized关键字，当线程A试图执行synchronized代码块，如果线程B正在执行它，那么线程A将阻塞直到线程B执行完synchronized代码块。使用Lock，你可以执行tryLock()方法，这个方法返回一个Boolean值表示是否有其他线程正在运行这个锁所保护的代码。</li><li>当有多个读者和一个写者时，Lock接口允许读写操作分离。</li><li>Lock接口提供了相比于wait更加灵活的<a href="http://ifeve.com/basic-thread-synchronization-8/" target="_blank" rel="noopener">await</a>关键字用于线程通信。</li><li>ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。</li></ol><blockquote><p><strong>注意：</strong><br>对于上面第5条优势中的提到的<code>可以被Interrupt的同步</code>是相对于进入同步块前的这个时间段来说的。另外在进入同步块后，如果调用了<code>synchronized概念中的wait()或Lock概念中的await()或者sleep（）</code>，那么该线程在等待唤醒的过程中是可以响应打断的（抛出异常后继续执行，而不是线程终止）；如果调用了<code>Lock概念中的awaitUninterruptibly()或耗时业务逻辑导致的延迟操作</code>，则不会响应打断。</p></blockquote><p>在下面的案例中，你将学习如何通过锁来同步代码块和通过Lock接口及其实现者ReentrantLock类来创建临界区，实现一个程序来模拟打印队列。<br>1.创建PrintQueue类，来实现打印队列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class PrintQueue &#123;</span><br></pre></td></tr></table></figure></p><p>2.声明一个Lock对象，并且使用ReentrantLock类的一个新对象来初始化它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Lock queueLock=new ReentrantLock();</span><br></pre></td></tr></table></figure></p><p>3.实现printJob()方法，它将接收Object对象作为参数，并且不会返回任何值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void printJob(Object document)&#123;</span><br></pre></td></tr></table></figure></p><p>4.在printJob()方法内部，通过调用lock()方法来获取Lock对象的控制权。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queueLock.lock();</span><br></pre></td></tr></table></figure></p><p>5.然后，包含以下代码来模拟文档的打印:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">System.out.printf(&quot;%s:print start!!!\n&quot;, Thread.currentThread().getName());</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">System.out.printf(&quot;%s:print end!!!\n&quot;, Thread.currentThread().getName());</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6.最后，通过调用unlock()方法来释放Lock对象的控制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finally &#123;</span><br><span class="line">queueLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7.创建一个Job类，并指定它实现Runnable接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Job implements Runnable &#123;</span><br></pre></td></tr></table></figure></p><p>8.声明一个PrintQueue类的对象，并通过实现类（Job类）的构造器来初始化这个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private PrintQueue printQueue;</span><br><span class="line">public Job(PrintQueue printQueue)&#123;</span><br><span class="line">this.printQueue=printQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>9.实现run()方法，它使用PrintQueue对象来发送一个打印任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">printQueue.printJob(new Object());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>10.通过创建类名为Main，且包括main（）方法来实现这个示例的主类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br></pre></td></tr></table></figure></p><p>11.创建一个共享的PrintQueue对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintQueue printQueue=new PrintQueue();</span><br></pre></td></tr></table></figure></p><p>12.创建5个Job对象，并且使用5个线程来运行它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread thread[]=new Thread[5];</span><br><span class="line">for (int i=0; i&lt;5; i++)&#123;</span><br><span class="line">thread[i]=new Thread(new Job(printQueue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>13.启动这5个线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0; i&lt;5; i++)&#123;</span><br><span class="line">thread[i].start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从以下截图，你可以看到执行这个示例的输出：<br><img src="http://chuantu.biz/t6/211/1516533234x-1404817814.jpg" alt=""><br>在 printJob()中，queueLock是这个示例的关键所在。当我们通过锁来实现一个临界区并且保证只有一个执行线程能运行一个代码块，我们必须创建一个ReentrantLock对象。在临界区的起始部分，我们必须通过使用lock()方法来获得锁的控制权。当一个线程A调用这个方法时，如果没有其他线程持有这个锁的控制权，那么这个方法就会给线程A分配这个锁的控制权并允许线程A执行这个临界区。否则，如果其他线程B正在执行由这个锁控制的临界区，lock()方法将会使线程A睡眠直到线程B完成这个临界区的执行。<br>在临界区的尾部，我们必须使用unlock()方法来释放锁的控制权，允许其他线程运行这个临界区。如果你在临界区的尾部没有调用unlock()方法，那么其他正在等待该代码块的线程将会永远等待，造成死锁情况。如果你在临界区使用try-catch代码块，别忘了在finally部分的内部包含unlock()方法的代码。</p><h5 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h5><p>Lock接口（和ReentrantLock类，以及后面要讲的ReadWriteLock接口和ReentrantReadWriteLock类）包含其他方法来获取锁的控制权，那就是tryLock()方法。这个方法与lock()方法的最大区别是，如果一个线程调用这个方法不能获取Lock接口的控制权时，将会立即返回并且不会使这个线程进入睡眠。这个方法返回一个boolean值，true表示这个线程获取了锁的控制权，false则表示没有。</p><blockquote><p><strong>小知识:</strong><br>预先考虑到tryLock()方法的结果，并采取相应的措施，这是程序员的责任。如果这个方法返回false值，预计你的程序不会执行这个临界区。如果是这样，你应该针对此错误结果做相应的处理。</p></blockquote><p>ReentrantLock类也允许递归调用（锁的可重入性），当一个线程有锁的控制权并且使用递归调用，它延续了锁的控制权，所以调用lock()方法将会立即返回并且继续递归调用的执行。</p><h5 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h5><p><code>lockInterruptibly()</code>是Lock提供的另一个用来获取锁的控制权的方法。它可以立即响应线程的interrupt,不伦当前线程是在等待锁的期间或是在已经获取锁的控制权期间。<code>lock()</code>相比于<code>lockInterruptibly()</code>来说没有那么及时，它要在获取锁的那一刻才能响应线程的interrupt事件。</p><h1 id="使用读-写锁同步数据访问"><a href="#使用读-写锁同步数据访问" class="headerlink" title="使用读/写锁同步数据访问"></a>使用读/写锁同步数据访问</h1><p>锁所提供的最重要的改进之一就是ReadWriteLock接口和唯一一个实现它的ReentrantReadWriteLock类。这个类提供两把锁，一把用于读操作和一把用于写操作。同时可以有多个线程执行读操作，但只有一个线程可以执行写操作。当一个线程正在执行一个写操作，不可能有任何线程执行读操作。<br>在下面的例子中，你将会学习如何使用ReadWriteLock接口实现一个程序，使用它来控制访问一个存储两个产品价格的对象。<br>1.创建PricesInfo类，用它来存储两个产品价格的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class PricesInfo &#123;</span><br></pre></td></tr></table></figure></p><p>2.声明两个double类型的属性，分别命名为price1和price2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private double price1;</span><br><span class="line">private double price2;</span><br></pre></td></tr></table></figure></p><p>3.声明一个名为lock的ReadWriteLock对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private ReadWriteLock lock;</span><br></pre></td></tr></table></figure></p><p>4.实现类的构造器，初始化这三个属性。其中，对于lock属性，我们创建一个新的ReentrantReadWriteLock对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public PricesInfo()&#123;</span><br><span class="line">price1=1.0;</span><br><span class="line">price2=2.0;</span><br><span class="line">lock=new ReentrantReadWriteLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.实现getPrice1()方法，用它来返回price1属性的值。它使用读锁来控制这个属性值的访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public double getPrice1() &#123;</span><br><span class="line">lock.readLock().lock();</span><br><span class="line">double value=price1;</span><br><span class="line">lock.readLock().unlock();</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6.实现getPrice2()方法，用它来返回price2属性的值。它使用读锁来控制这个属性值的访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public double getPrice2() &#123;</span><br><span class="line">lock.readLock().lock();</span><br><span class="line">double value=price2;</span><br><span class="line">lock.readLock().unlock();</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7.实现setPrices()方法，用来建立这两个属性的值。它使用写锁来控制对它们的访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void setPrices(double price1, double price2) &#123;</span><br><span class="line">lock.writeLock().lock();</span><br><span class="line">this.price1=price1;</span><br><span class="line">this.price2=price2;</span><br><span class="line">lock.writeLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>8.创建Reader类，并指定它实现Runnable接口。这个类实现了PricesInfo类属性值的读者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Reader implements Runnable &#123;</span><br></pre></td></tr></table></figure></p><p>9.声明一个PricesInfo对象，并且实现Reader类的构造器来初始化这个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private PricesInfo pricesInfo;</span><br><span class="line">public Reader (PricesInfo pricesInfo)&#123;</span><br><span class="line">this.pricesInfo=pricesInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>10.实现Reader类的run()方法，它读取10次两个价格的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i=0; i&lt;10; i++)&#123;</span><br><span class="line">System.out.printf(&quot;%s: Price 1: %f\n&quot;, Thread.</span><br><span class="line">currentThread().getName(),pricesInfo.getPrice1());</span><br><span class="line">System.out.printf(&quot;%s: Price 2: %f\n&quot;, Thread.</span><br><span class="line">currentThread().getName(),pricesInfo.getPrice2());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>11.创建Writer类，并指定它实现Runnable接口。这个类实现了PricesInfo类属性值的修改者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Writer implements Runnable &#123;</span><br></pre></td></tr></table></figure></p><p>12.声明一个PricesInfo对象，并且实现Writer类的构造器来初始化这个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private PricesInfo pricesInfo;</span><br><span class="line">public Writer(PricesInfo pricesInfo)&#123;</span><br><span class="line">this.pricesInfo=pricesInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>13.实现run()方法，它修改了三次两个价格的值，并且在每次修改之后睡眠2秒。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i=0; i&lt;3; i++) &#123;</span><br><span class="line">System.out.printf(&quot;Writer: Attempt to modify the</span><br><span class="line">prices.\n&quot;);</span><br><span class="line">pricesInfo.setPrices(Math.random()*10, Math.random()*8);</span><br><span class="line">System.out.printf(&quot;Writer: Prices have been modified.\n&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(2);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>14.通过创建类名为Main，且包括main（）方法来实现这个示例的主类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br></pre></td></tr></table></figure></p><p>15.创建一个PricesInfo对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PricesInfo pricesInfo=new PricesInfo();</span><br></pre></td></tr></table></figure></p><p>16.创建5个Reader对象，并且用5个线程来执行它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Reader readers[]=new Reader[5];</span><br><span class="line">Thread threadsReader[]=new Thread[5];</span><br><span class="line">for (int i=0; i&lt;5; i++)&#123;</span><br><span class="line">readers[i]=new Reader(pricesInfo);</span><br><span class="line">threadsReader[i]=new Thread(readers[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>17.创建一个Writer对象，并且用线程来执行它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Writer writer=new Writer(pricesInfo);</span><br><span class="line">Thread threadWriter=new Thread(writer);</span><br></pre></td></tr></table></figure></p><p>18.启动这些线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0; i&lt;5; i++)&#123;</span><br><span class="line">threadsReader[i].start();</span><br><span class="line">&#125;</span><br><span class="line">threadWriter.start();</span><br></pre></td></tr></table></figure></p><p>在以下截图中，你可以看到执行这个例子的一个部分输出:<br><img src="http://chuantu.biz/t6/212/1516582907x-1404817814.jpg" alt=""></p><h1 id="修改Lock的公平性"><a href="#修改Lock的公平性" class="headerlink" title="修改Lock的公平性"></a>修改Lock的公平性</h1><p>在ReentrantLock类和ReentrantReadWriteLock类的构造器中，允许一个名为fair的boolean类型参数，它允许你来控制这些类的行为。默认值为 false，这将启用非公平模式。在这个模式中，当有多个线程正在等待一把锁（ReentrantLock或者 ReentrantReadWriteLock），这个锁必须选择它们中间的一个来获得进入临界区，选择任意一个是没有任何标准的。true值将开启公平模式。在这个模式中，当有多个线程正在等待一把锁（ReentrantLock或者ReentrantReadWriteLock），这个锁必须选择它们中间的一个来获得进入临界区，它将选择等待时间最长的线程。由于tryLock()方法并不会使线程进入睡眠，即使Lock接口正在被使用，这个公平属性并不会影响它的功能。更多关于公平模式的介绍，请<a href="http://ifeve.com/basic-thread-synchronization-7/" target="_blank" rel="noopener">点击查阅</a>。</p><hr><p><strong>参考资料</strong><br><a href="http://ifeve.com/basic-thread-synchronization-5/" target="_blank" rel="noopener">并发编程网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相对于&lt;a href=&quot;https://kimball325.github.io/2016/12/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Synchronized/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Synchronized&lt;/a&gt;,我们还可以使用更加人性化的Lock关键字作为线程同步的实现方案。本篇文章将详细介绍Lock的相关用法以及使用它的优势。&lt;br&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="并发编程" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之Synchronized</title>
    <link href="http://yoursite.com/2016/12/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Synchronized/"/>
    <id>http://yoursite.com/2016/12/18/Java并发编程-Synchronized/</id>
    <published>2016-12-18T13:04:01.000Z</published>
    <updated>2018-01-29T00:30:43.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在并发编程中发生的最常见的一种情况是超过一个执行线程使用共享资源。在并发应用程序中，多个线程读或写相同的数据或访问同一文件或数据库连接这是正常的。这些共享资源会引发错误或数据不一致的情况，我们必须通过同步机制来避免这些错误。<br>解决这些问题从临界区的概念开始。临界区是访问一个共享资源在同一时间不能被超过一个线程执行的代码块。<a id="more"></a><br>Java(和几乎所有的编程语言)提供同步机制，帮助程序员实现临界区。当一个线程想要访问一个临界区,它使用其中的一个同步机制来找出是否有任何其他线程执行临界区。如果没有，这个线程就进入临界区。否则，这个线程通过同步机制暂停直到另一个线程执行完临界区。当多个线程正在等待一个线程完成执行的一个临界区，JVM选择其中一个线程执行，其余的线程会等待直到轮到它们。<br>这个系列的文章将逐一介绍Java提供的几个同步机制：Synchronized、Lock、Automic和Volatile。Synchronized可以标记以下四种类型的代码区域：</p><ol><li>Instance methods（普通方法）</li><li>Static methods（静态方法）</li><li>Code blocks inside instance methods（普通方法内的代码快）</li><li>Code blocks inside static methods（静态方法内的代码快)</li></ol><h1 id="普通同步方法"><a href="#普通同步方法" class="headerlink" title="普通同步方法"></a>普通同步方法</h1><p>下面是一个普通的同步方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void add(int value)&#123;</span><br><span class="line">this.count += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果此时A线程和B线程同时对同一个对象的add方法访问，那么只能有一个线程（假设是A线程）能够进入方法体内获得锁资源，此时B线程只能等待A线程执行完方法体后（释放锁资源）才能执行add方法体中的代码。<br>总结一下就是，在同一时刻只能有一个线程能对同一个对象的synchronized方法进行访问。如果一个线程A正在执行一个synchronized方法，而线程B想要执行同个实例对象的非静态synchronized方法，它将阻塞，直到线程A执行完。但是如果线程B访问相同类的不同实例对象，它们都不会被阻塞。</p><h5 id="再深入一点："><a href="#再深入一点：" class="headerlink" title="再深入一点："></a>再深入一点：</h5><p>CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。<br><img src="http://chuantu.biz/t6/211/1516520176x-1404817814.jpg" alt=""></p><h1 id="静态同步方法"><a href="#静态同步方法" class="headerlink" title="静态同步方法"></a>静态同步方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized void add(int value)&#123;</span><br><span class="line">count += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与普通同步方法不同，静态同步方法修饰的对象是整个class对象。只有一个执行线程能访问被synchronized关键字声明的静态方法，<strong>但另一个线程可以访问该类的一个对象中的其他非静态的方法。</strong>你必须非常小心这一点，因为两个线程可以访问两个不同的同步方法，如果其中一个是静态的而另一个不是。如果这两种方法改变相同的数据,你将会有数据不一致的错误。</p><h1 id="普通方法中的同步块"><a href="#普通方法中的同步块" class="headerlink" title="普通方法中的同步块"></a>普通方法中的同步块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void log2(String msg1, String msg2)&#123;</span><br><span class="line">synchronized(this)&#123;</span><br><span class="line">log.writeln(msg1);</span><br><span class="line">log.writeln(msg2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样调用和普通同步方法实现的效果其实是一样的。注意到“this”字段是一个Monitor对象，它和普通同步方法中锁定的对象是一个概念。</p><blockquote><p>小知识：<br>引用<a href="https://en.wikipedia.org/wiki/Monitor_(synchronization)" target="_blank" rel="noopener">维基百科</a>的说法，monitor是一种线程安全的class,object或者module，即monitor允许多个线程同时访问其内的方法或者属性而不会出现二义性。</p></blockquote><h1 id="静态方法中的同步块"><a href="#静态方法中的同步块" class="headerlink" title="静态方法中的同步块"></a>静态方法中的同步块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void log2(String msg1, String msg2)&#123;</span><br><span class="line">synchronized(MyClass.class)&#123;</span><br><span class="line">log.writeln(msg1);</span><br><span class="line">log.writeln(msg2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><p>以上内容就是对Synchronized关键字使用和触发场景的介绍，下面再从宏观上介绍一下关于锁的分类：（*）偏向锁、轻量锁、重量锁。<br>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。<br>如果在运行过程中，遇到了其他线程抢占锁，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁。偏向锁只能在单线程下起作用,主要解决无竞争下的锁性能问题。</p><h5 id="我们看下无竞争下锁存在什么问题"><a href="#我们看下无竞争下锁存在什么问题" class="headerlink" title="我们看下无竞争下锁存在什么问题:"></a>我们看下无竞争下锁存在什么问题:</h5><p>按照之前的HotSpot设计，每次加锁/解锁都会涉及到一些<a href="http://ifeve.com/compare-and-swap/" target="_blank" rel="noopener">CAS操作</a>（比如对等待队列的CAS操作），CAS操作会延迟本地调用，因此偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。<br>锁演变的流程是这样的：<a href="http://ifeve.com/java-synchronized/" target="_blank" rel="noopener">偏向锁-&gt;轻量级锁-&gt;重量级锁</a>。</p><h1 id="线程通信（wait、notify、notifyAll）"><a href="#线程通信（wait、notify、notifyAll）" class="headerlink" title="线程通信（wait、notify、notifyAll）"></a>线程通信（wait、notify、notifyAll）</h1><p>当一个线程进入wait之后，就必须等其他线程notify/notifyall,使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。注意，任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行synchronized中的代码，notifyall只是让处于wait的线程重新拥有锁的争夺权，但是只会有一个获得锁并执行。</p><blockquote><p><strong>注意：</strong><br>wait、notify、notifyAll必须都在同步块中调用，否者会抛出IllegalMonitorStateException异常。</p></blockquote><h4 id="深入了解notify与notifyAll的区别"><a href="#深入了解notify与notifyAll的区别" class="headerlink" title="深入了解notify与notifyAll的区别"></a>深入了解notify与notifyAll的区别</h4><p>先说两个概念：锁池和等待池。<br>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。<br>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中。<br>然后再来说notify和notifyAll的区别。</p><ol><li>如果线程调用了对象的wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li><li>当有线程调用了对象的notifyAll()方法（唤醒所有wait线程或notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</li><li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li></ol><p>综上，所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。</p><h1 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h1><p>在多线程同步机制中，试想一下会不会出现线程1和线程2互相需要对方所持有的锁的情况呢？答案是肯定的，这就是死锁。我们要避免死锁，需从以下三个方面入手：<br>1.加锁顺序<br>2.加锁时限<br>3.死锁检测</p><h5 id="加锁顺序"><a href="#加锁顺序" class="headerlink" title="加锁顺序"></a>加锁顺序</h5><p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。</p><h5 id="加锁时限"><a href="#加锁时限" class="headerlink" title="加锁时限"></a>加锁时限</h5><p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行。<br>这种机制存在一个问题，在Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的<a href="https://kimball325.github.io/2017/01/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BLock/" target="_blank" rel="noopener">工具</a>。</p><h5 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h5><p>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。<br>那么当检测出死锁时，这些线程该做些什么呢？<br>一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁。<br>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。</p><hr><p><strong>参考资料</strong><br>1.<a href="http://ifeve.com/basic-thread-synchronization-1/" target="_blank" rel="noopener">并发编程网</a><br>2.<a href="http://blog.csdn.net/qq_23835497/article/details/76462403" target="_blank" rel="noopener">Java Synchronized Blocks</a><br>3.<a href="https://www.zhihu.com/question/37601861" target="_blank" rel="noopener">java中的notify和notifyAll有什么区别？</a><br>4.<a href="http://ifeve.com/deadlock-prevention/" target="_blank" rel="noopener">避免死锁</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;在并发编程中发生的最常见的一种情况是超过一个执行线程使用共享资源。在并发应用程序中，多个线程读或写相同的数据或访问同一文件或数据库连接这是正常的。这些共享资源会引发错误或数据不一致的情况，我们必须通过同步机制来避免这些错误。&lt;br&gt;解决这些问题从临界区的概念开始。临界区是访问一个共享资源在同一时间不能被超过一个线程执行的代码块。
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="并发编程" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java正则表达式详解</title>
    <link href="http://yoursite.com/2016/11/10/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/11/10/Java正则表达式详解/</id>
    <published>2016-11-10T14:37:54.000Z</published>
    <updated>2018-01-23T16:36:16.602Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>为什么要使用正则表达式？</strong><br>节省代码，爱护队友。</p></blockquote><p>在正式介绍之前，先贴一段使用了正则表达式的代码吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String phoneNum = &quot;16510758936&quot;;</span><br><span class="line">String patternString = &quot;\\d&#123;11&#125;&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString);</span><br><span class="line">Matcher matcher = pattern.matcher(phoneNum);</span><br><span class="line">System.out.println(&quot;matches = &quot;+matcher.matches());</span><br></pre></td></tr></table></figure></p><a id="more"></a> <p>仅这段代码就可以简单判断字符串（代码中的“phoneNum”字符串）是否为手机号格式。是不是很高效呢？事实上正则表达式还可以做很多很酷的事情，所以我们很有必要认真的学一下它。本文将从<strong>API、语法</strong>两个维度介绍该主题。</p><h1 id="API使用"><a href="#API使用" class="headerlink" title="API使用"></a>API使用</h1><p>类 java.util.regex.Pattern 简称 Pattern, 是Java正则表达式API中的主要入口，无论何时,需要使用正则表达式,从Pattern 类开始</p><h3 id="Pattern-matches"><a href="#Pattern-matches" class="headerlink" title="Pattern.matches()"></a>Pattern.matches()</h3><p>这是检测正则表达式的模式是否匹配一段文本的最直接方法，eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;This is the text to be searched &quot; +</span><br><span class="line">&quot;for occurrences of the pattern.&quot;;</span><br><span class="line">String pattern = &quot;.*is.*&quot;;</span><br><span class="line">boolean matches = Pattern.matches(pattern, text);</span><br><span class="line">System.out.println(&quot;matches = &quot; + matches);</span><br></pre></td></tr></table></figure></p><p>“.”表示任意字符，“*”表示0或者多个，“.*”组合表示0或者多个任意字符。显然， “.*is.*“代表一个字符串中包含“is”字段，上面代码返回结果是true。<br>Pattern.matches() 方法适用于检查 一个模式在一个文本中出现一次的情况，或适用于Pattern类的默认设置。<br>如果需要匹配多次出现,甚至输出不同的匹配文本，或者只是需要非默认设置。需要通过Pattern.compile() 方法得到一个Pattern 实例。</p><h3 id="Pattern-compile"><a href="#Pattern-compile" class="headerlink" title="Pattern.compile()"></a>Pattern.compile()</h3><p>如果需要匹配一个正则表达式在文本中多次出现，需要通过Pattern.compile() 方法创建一个Pattern对象。示例如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;This is the text to be searched &quot; +</span><br><span class="line">&quot;for occurrences of the http:// pattern.&quot;;</span><br><span class="line">String patternString = &quot;.*http://.*&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString);</span><br></pre></td></tr></table></figure></p><p>可以在Compile 方法中，指定一个特殊标志：<br>Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);<br>Pattern 类包含多个标志(int 类型),这些标志可以控制Pattern 匹配模式的方式。上面代码中的标志使模式匹配是忽略大小写</p><h3 id="pattern-matcher"><a href="#pattern-matcher" class="headerlink" title="pattern.matcher()"></a>pattern.matcher()</h3><p>一旦获得了Pattern对象，接着可以获得Matcher对象。Matcher 示例用于匹配文本中的模式.示例如下<br>Matcher matcher = pattern.matcher(text);<br>Matcher类有一个matches()方法，可以检查文本是否匹配模式。以下是关于Matcher的一个完整例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;This is the text to be searched &quot; +</span><br><span class="line">&quot;for occurrences of the http:// pattern.&quot;;</span><br><span class="line">String patternString = &quot;.*http://.*&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);</span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br><span class="line">boolean matches = matcher.matches();</span><br><span class="line">System.out.println(&quot;matches = &quot; + matches);</span><br></pre></td></tr></table></figure></p><h3 id="pattern-split"><a href="#pattern-split" class="headerlink" title="pattern.split()"></a>pattern.split()</h3><p>Pattern 类的 split()方法，可以用正则表达式作为分隔符，把文本分割为String类型的数组。示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String text = &quot;A sep Text sep With sep Many sep Separators&quot;;</span><br><span class="line">String patternString = &quot;sep&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString);</span><br><span class="line">String[] split = pattern.split(text);</span><br><span class="line">System.out.println(&quot;split.length = &quot; + split.length);</span><br><span class="line">for(String element : split)&#123;</span><br><span class="line">System.out.println(&quot;element = &quot; + element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上例中把text 文本分割为一个包含5个字符串的数组。</p><h3 id="pattern-pattern"><a href="#pattern-pattern" class="headerlink" title="pattern.pattern()"></a>pattern.pattern()</h3><p>Pattern 类的 pattern 返回用于创建Pattern 对象的正则表达式。</p><h3 id="Matcher-java-util-regex-Matcher"><a href="#Matcher-java-util-regex-Matcher" class="headerlink" title="Matcher (java.util.regex.Matcher)"></a>Matcher (java.util.regex.Matcher)</h3><p>java.util.regex.Matcher 类用于匹配一段文本中多次出现一个正则表达式，Matcher 也适用于多文本中匹配同一个正则表达式。</p><h5 id="创建Matcher"><a href="#创建Matcher" class="headerlink" title="创建Matcher"></a>创建Matcher</h5><p>通过Pattern 的matcher() 方法创建一个Matcher。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;This is the text to be searched &quot; +</span><br><span class="line">&quot;for occurrences of the http:// pattern.&quot;;</span><br><span class="line">String patternString = &quot;.*http://.*&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString);</span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br></pre></td></tr></table></figure></p><h5 id="matches"><a href="#matches" class="headerlink" title="matches()"></a>matches()</h5><p>Matcher 类的 matches() 方法用于在文本中匹配正则表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean matches = matcher.matches();</span><br></pre></td></tr></table></figure></p><p>如果文本匹配正则表达式，matches() 方法返回true。否则返回false。matches() 方法不能用于查找正则表达式多次出现。如果需要，要使用find(), start() 和 end() 方法。</p><h5 id="lookingAt"><a href="#lookingAt" class="headerlink" title="lookingAt()"></a>lookingAt()</h5><p>lookingAt() 与matches() 方法类似，最大的不同是，lookingAt()方法对文本的开头匹配正则表达式；而matches() 对整个文本匹配正则表达式。换句话说，如果正则表达式匹配文本开头而不匹配整个文本,lookingAt() 返回true,而matches() 返回false。 示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;This is the text to be searched &quot; +</span><br><span class="line">&quot;for occurrences of the http:// pattern.&quot;;</span><br><span class="line">String patternString = &quot;This is the&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);</span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br><span class="line">System.out.println(&quot;lookingAt = &quot; + matcher.lookingAt());</span><br><span class="line">System.out.println(&quot;matches   = &quot; + matcher.matches());</span><br></pre></td></tr></table></figure></p><p>上面的例子分别对文本开头和整个文本匹配正则表达式 “this is the”, 匹配文本开头的方法(lookingAt()) 返回true。<br>对整个文本匹配正则表达式的方法 (matches()) 返回false，因为整个文本包含多余的字符,而正则表达式要求文本精确匹配”this is the”,前后又不能有额外字符。</p><h5 id="find-start-end"><a href="#find-start-end" class="headerlink" title="find() + start() + end()"></a>find() + start() + end()</h5><p>find() 方法用于在文本中查找出现的正则表达式，文本是创建Matcher时，通过 Pattern.matcher(text) 方法传入的。如果在文本中多次匹配，find() 方法返回第一个，之后每次调用 find() 都会返回下一个。<br>start() 和 end() 返回每次匹配的字串在整个文本中的开始和结束位置。实际上, end() 返回的是字符串末尾的后一位，这样，可以在把 start() 和 end() 的返回值直接用在String.substring() 里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;This is the text which is to be searched &quot; +</span><br><span class="line">&quot;for occurrences of the word &apos;is&apos;.&quot;;</span><br><span class="line">String patternString = &quot;is&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString);</span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br><span class="line">int count = 0;</span><br><span class="line">while(matcher.find()) &#123;</span><br><span class="line">count++;</span><br><span class="line">System.out.println(&quot;found: &quot; + count + &quot; : &quot;  + matcher.start() + &quot; - &quot; + matcher.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子在文本中找到模式 “is” 4次，输出如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">found: 1 : 2 - 4</span><br><span class="line">found: 2 : 5 - 7</span><br><span class="line">found: 3 : 23 - 25</span><br><span class="line">found: 4 : 70 - 72</span><br></pre></td></tr></table></figure></p><h5 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h5><p>reset() 方法会重置Matcher 内部的 匹配状态。当find() 方法开始匹配时,Matcher 内部会记录截至当前查找的距离。调用 reset() 会重新从文本开头查找。<br>也可以调用 reset(CharSequence) 方法. 这个方法重置Matcher,同时把一个新的字符串作为参数传入，用于代替创建 Matcher 的原始字符串。</p><blockquote><p><strong>补充：</strong><br>如果在程序中多次使用同一个正则表达式，一定要用Pattern.compile()编译，代替直接使用Pattern.matches()。如果一次次对同一个正则表达式使用Pattern.matches()，例如在循环中，没有编译的正则表达式消耗比较大。因为matches()方法每次都会预编译使用的表达式。另外，记住你可以通过调用reset()方法对不同的输入字符串重复使用Matcher对象。</p></blockquote><h5 id="group"><a href="#group" class="headerlink" title="group()"></a>group()</h5><p>假设想在一个文本中查找URL链接，并且想把找到的链接提取出来。当然可以通过 start()和 end()方法完成。但是用group()方法更容易些。<br>分组在正则表达式中用括号表示，例如:<br>(John)<br>此正则表达式匹配John, 括号不属于要匹配的文本。括号定义了一个分组。当正则表达式匹配到文本后，可以访问分组内的部分。<br>使用group(int groupNo) 方法访问一个分组。一个正则表达式可以有多个分组。每个分组由一对括号标记。想要访问正则表达式中某分组匹配的文本，可以把分组编号传入 group(int groupNo)方法。<br>group(0) 表示整个正则表达式，要获得一个有括号标记的分组，分组编号应该从1开始计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String text    =  &quot;John writes about this, and John writes about that,&quot; +</span><br><span class="line">&quot; and John writes about everything. &quot;  ;</span><br><span class="line">String patternString1 = &quot;(John)&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString1);</span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br><span class="line">while(matcher.find()) &#123;</span><br><span class="line">System.out.println(&quot;found: &quot; + matcher.group(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以上代码在文本中搜索单词John.从每个匹配文本中，提取分组1，就是由括号标记的部分。输出：</span><br><span class="line">found: John</span><br><span class="line">found: John</span><br><span class="line">found: John</span><br></pre></td></tr></table></figure><h5 id="多分组"><a href="#多分组" class="headerlink" title="多分组"></a>多分组</h5><p>上面提到，一个正则表达式可以有多个分组，例如：<br>(John) (.+?)<br>这个表达式匹配文本”John” 后跟一个空格,然后跟1个或多个字符，最后跟一个空格。你可能看不到最后的空格。<br>这个表达式包括一些字符有特别意义。字符 点 . 表示任意字符。 字符 + 表示出现一个或多个，和. 在一起表示 任何字符,出现一次或多次。字符? 表示 匹配尽可能短的文本。<br>完整代码如下：<br>String text    =<br>“John writes about this, and John Doe writes about that,” +<br>“ and John Wayne writes about everything.”<br>;<br>String patternString1 = “(John) (.+?) “;<br>Pattern pattern = Pattern.compile(patternString1);<br>Matcher matcher = pattern.matcher(text);<br>while(matcher.find()) {<br>System.out.println(“found: “ + matcher.group(1) +<br>“ “       + matcher.group(2));<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意代码中引用分组的方式。代码输出如下:</span><br><span class="line">found: John writes</span><br><span class="line">found: John Doe</span><br><span class="line">found: John Wayne</span><br></pre></td></tr></table></figure></p><h5 id="嵌套分组"><a href="#嵌套分组" class="headerlink" title="嵌套分组"></a>嵌套分组</h5><p>在正则表达式中分组可以嵌套分组，例如:<br>((John) (.+?))<br>这是之前的例子，现在放在一个大分组里.(表达式末尾有一个空格)。<br>当遇到嵌套分组时, 分组编号是由左括号的顺序确定的。上例中，分组1 是那个大分组。分组2 是包括John的分组，分组3 是包括 .+? 的分组。当需要通过groups(int groupNo) 引用分组时，了解这些非常重要。<br>以下代码演示如何使用嵌套分组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;John writes about this, and John Doe writes about that,&quot; +</span><br><span class="line">&quot; and John Wayne writes about everything.&quot;</span><br><span class="line">;</span><br><span class="line">String patternString1 = &quot;((John) (.+?)) &quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString1);</span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br><span class="line">while(matcher.find()) &#123;</span><br><span class="line">System.out.println(&quot;found:   &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出如下</span><br><span class="line">found:</span><br><span class="line">found:</span><br><span class="line">found:</span><br></pre></td></tr></table></figure><h5 id="replaceAll-replaceFirst"><a href="#replaceAll-replaceFirst" class="headerlink" title="replaceAll() + replaceFirst()"></a>replaceAll() + replaceFirst()</h5><p>replaceAll() 和 replaceFirst() 方法可以用于替换Matcher搜索字符串中的一部分。replaceAll() 方法替换全部匹配的正则表达式，replaceFirst() 只替换第一个匹配的。<br>在处理之前，Matcher 会先重置。所以这里的匹配表达式从文本开头开始计算。<br>示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;John writes about this, and John Doe writes about that,&quot; +</span><br><span class="line">&quot; and John Wayne writes about everything.&quot;</span><br><span class="line">;</span><br><span class="line">String patternString1 = &quot;((John) (.+?)) &quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString1);</span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br><span class="line">String replaceAll = matcher.replaceAll(&quot;Joe Blocks &quot;);</span><br><span class="line">System.out.println(&quot;replaceAll   = &quot; + replaceAll);</span><br><span class="line">String replaceFirst = matcher.replaceFirst(&quot;Joe Blocks &quot;);</span><br><span class="line">System.out.println(&quot;replaceFirst = &quot; + replaceFirst);</span><br></pre></td></tr></table></figure></p><p>输出如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">replaceAll = Joe Blocks about this, and Joe Blocks writes about that,</span><br><span class="line">and Joe Blocks writes about everything.</span><br><span class="line">replaceFirst = Joe Blocks about this, and John Doe writes about that,</span><br><span class="line">and John Wayne writes about everything.</span><br></pre></td></tr></table></figure></p><h5 id="appendReplacement-appendTail"><a href="#appendReplacement-appendTail" class="headerlink" title="appendReplacement() + appendTail()"></a>appendReplacement() + appendTail()</h5><p>appendReplacement() 和 appendTail() 方法用于替换输入文本中的字符串短语，同时把替换后的字符串附加到一个 StringBuffer 中。<br>当find() 方法找到一个匹配项时，可以调用 appendReplacement() 方法，这会导致输入字符串被增加到StringBuffer 中，而且匹配文本被替换。 从上一个匹配文本结尾处开始，直到本次匹配文本会被拷贝。<br>appendReplacement() 会记录拷贝StringBuffer 中的内容，可以持续调用find(),直到没有匹配项。<br>直到最后一个匹配项目，输入文本中剩余一部分没有拷贝到 StringBuffer. 这部分文本是从最后一个匹配项结尾，到文本末尾部分。通过调用 appendTail() 方法，可以把这部分内容拷贝到 StringBuffer 中.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;John writes about this, and John Doe writes about that,&quot; +</span><br><span class="line">&quot; and John Wayne writes about everything.&quot;</span><br><span class="line">;</span><br><span class="line">String patternString1 = &quot;((John) (.+?)) &quot;;</span><br><span class="line">Pattern      pattern      = Pattern.compile(patternString1);</span><br><span class="line">Matcher      matcher      = pattern.matcher(text);</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">while(matcher.find())&#123;</span><br><span class="line">matcher.appendReplacement(stringBuffer, &quot;Joe Blocks &quot;);</span><br><span class="line">System.out.println(stringBuffer.toString());</span><br><span class="line">&#125;</span><br><span class="line">matcher.appendTail(stringBuffer);</span><br><span class="line">System.out.println(stringBuffer.toString());</span><br></pre></td></tr></table></figure></p><p>注意我们在while循环中调用appendReplacement() 方法。在循环完毕后调用appendTail()。代码输出如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Joe Blocks</span><br><span class="line">Joe Blocks about this, and Joe Blocks</span><br><span class="line">Joe Blocks about this, and Joe Blocks writes about that, and Joe Blocks</span><br><span class="line">Joe Blocks about this, and Joe Blocks writes about that, and Joe Blocks</span><br><span class="line">writes about everything.</span><br></pre></td></tr></table></figure></p><h1 id="Java-正则表达式语法"><a href="#Java-正则表达式语法" class="headerlink" title="Java 正则表达式语法"></a>Java 正则表达式语法</h1><p>为了更有效的使用正则表达式，需要了解正则表达式语法。正则表达式语法很复杂，可以写出非常高级的表达式。只有通过大量的练习才能掌握这些语法规则。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>在介绍高级功能前，我们先快速浏览下正则表达式的基本语法。</p><h5 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h5><p>是正则表达式中最经常使用的的一个表达式，作用是简单的匹配一个确定的字符。例如：John<br>这个简单的表达式将会在一个输入文本中匹配John文本。<br>可以在表达式中使用任意英文字符。也可以使用字符对于的8进制，16进制或unicode编码表示。例如：<br>101<br>\x41<br>\u0041<br>以上3个表达式 都表示大写字符A。第一个是8进制编码(101),第2个是16进制编码(41),第3个是unicode编码(0041).</p><h5 id="字符分类"><a href="#字符分类" class="headerlink" title="字符分类"></a>字符分类</h5><p>字符分类是一种结构，可以针对多个字符匹配而不只是一个字符。换句话说，一个字符分类匹配输入文本中的一个字符，对应字符分类中多个允许字符。例如，你想匹配字符 a,b 或c，表达式如下：<br>[abc]<br>用一对方括号[] 表示字符分类。方括号本身并不是要匹配的一部分。<br>可以用字符分类完成很多事。例如想要匹配单词John，首字母可以为大写和小写J.<br>[Jj]ohn<br>字符分类[Jj] 匹配J或j，剩余的 ohn 会准确匹配字符ohn.</p><h5 id="预定义字符分类"><a href="#预定义字符分类" class="headerlink" title="预定义字符分类"></a>预定义字符分类</h5><p>正则表达式中有一些预定义的字符分类可以使用。例如, \d 表示任意数字, \s 表示任意空白字符,\w 表示任意单词字符。<br>预定义字符分类不需要括在方括号里，当然也可以组合使用<br>\d<br>[\d\s]<br>第1个匹配任意数字，第2个匹配任意数字或空白符。<br>完整的预定义字符分类列表，在本文最后列出。</p><h5 id="边界匹配"><a href="#边界匹配" class="headerlink" title="边界匹配"></a>边界匹配</h5><p>正则表达式支持匹配边界，例如单词边界，文本的开头或末尾。例如，\w 匹配一个单词，^匹配行首,$ 匹配行尾。<br>^This is a single line$<br>上面的表达式匹配一行文本，只有文本 This is a single line。注意其中的行首和行尾标志，表示不能有任何文本在文本的前面后后面，只能是行首和行尾。<br>完整的匹配边界列表，在本文最后列出。</p><h5 id="量词匹配"><a href="#量词匹配" class="headerlink" title="量词匹配"></a>量词匹配</h5><p>量词可以匹配一个表达式多次出现。例如下列表达式匹配字母A 出现0次或多次。<br>A*<br>量词 * 表示0次或多次。+ 表示1次或多次。? 表示0次或1次。还有些其他量词，参见本文后面的列表。<br>量词匹配分为：饥饿模式,贪婪模式,独占模式。饥饿模式 匹配尽可能少的文本。贪婪模式匹配尽可能多的文本。独占模式匹配尽可能多的文本，甚至导致剩余表达式匹配失败。<br>以下演示饥饿模式,贪婪模式,独占模式区别。假设以下文本：<br>John went for a walk, and John fell down, and John hurt his knee.<br>饥饿模式下 表达式：<br>John.*?<br>这个表达式匹配John 后跟0个或多个字符。 . 表示任意字符。* 表示0或多次。? 跟在 * 后面，表示 * 采用饥饿模式。<br>饥饿模式下，量词只会匹配尽可能少的字符，即0个字符。上例中的表达式将会匹配单词John,在输入文本中出现3次。<br>如果改为贪婪模式，表达式如下：<br>John.*<br>贪婪模式下，量词会匹配尽可能多的字符。现在表达式会匹配第一个出现的John，以及在贪婪模式下 匹配剩余的所有字符。这样，只有一个匹配项。<br>最后，我们改为独占模式：<br>John.*+hurt<br>*后跟+ 表示独占模式量词。<br>这个表达式在输入文本中没有匹配项，尽管文本中包括 John 和 hurt. 为什么会这样? 因为 .*+ 是独占模式。与贪婪模式下，尽可能多的匹配文本，以使整个表达式匹配不同。独占模式会尽可能的多的匹配，但不考虑表达式剩余部分是否能匹配上。<br>.*+ 将会匹配第一个John之后的所有字符，这会导致表达式中剩余的 hurt 没有匹配项。如果改为贪婪模式，会有一个匹配项。表达式如下：<br>John.*hurt</p><h5 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h5><p>正则表达式支持少量的逻辑运算(与，或，非)。<br>与操作是默认的，表达式 John ,意味着J 与 o与h与n。<br>或操作需要显示指定，用 | 表示。例如表达式 John|hurt 意味着John 或 hurt 。</p><h5 id="特殊操作"><a href="#特殊操作" class="headerlink" title="?!特殊操作"></a>?!特殊操作</h5><p> ?!帮我们解决了字符串“不包含”匹配的问题，例如表达式 ^(?!.<em>went).</em>$ 意味着匹配的字符串中不能包含“went”字符串。</p><h3 id="字符-1"><a href="#字符-1" class="headerlink" title="字符"></a>字符</h3><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>.</td><td>除换行以外的任意字符</td></tr><tr><td>\\</td><td>反斜杠, 单独的反斜杠做为转义字符,与其他特殊字符一起使用。如果想匹配反斜杠本身,需要转义。两个反斜杠实际匹配一个反斜杠。</td></tr><tr><td>nn</td><td>字符的8进制表示.n 在0至7之间取值</td></tr><tr><td>mnn</td><td>字符的8进制表示. m 在0至3之间取值, n 在0至7之间取值</td></tr><tr><td>\xhh</td><td>字符的16进制表示.</td></tr><tr><td>\uhhhh</td><td>字符的16进制表示 0xhhhh. 对应unicode 编码字符</td></tr><tr><td>\t</td><td>缩进符.</td></tr><tr><td>\n</td><td>换行符 (unicode: ‘\u000A’)</td></tr><tr><td>\r</td><td>回车符 (unicode: ‘\u000D’)</td></tr><tr><td>\f</td><td>制表符 (unicode: ‘\u000C’)</td></tr><tr><td>\a</td><td>警报（铃声）字符 (unicode: ‘\u0007’)</td></tr><tr><td>\e</td><td>转义符 (unicode: ‘\u001B’)</td></tr><tr><td>\cx</td><td>控制符 x</td></tr></tbody></table><h3 id="字符分类-1"><a href="#字符分类-1" class="headerlink" title="字符分类"></a>字符分类</h3><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>[abc]</td><td>匹配 a, 或 b 或 c</td></tr><tr><td>[^abc]</td><td>匹配不是a,b,c 的字符，是否定匹配</td></tr><tr><td>[a-zA-Z]</td><td>匹配a 到 z ，A到Z 直接的字符，是范围匹配</td></tr><tr><td>[a-d[m-p]]</td><td>匹配a到d之间字符或 m到p之间字符，是并集匹配</td></tr><tr><td>[a-z&amp;&amp;[def]]</td><td>匹配 d, e, 或 f. 是交集匹配 (这里是在范围 a-z和字符def之间取交集).</td></tr><tr><td>[a-z&amp;&amp;[^bc]]</td><td>匹配a-z 之间所有字符，排除bc的字符。是减法匹配</td></tr><tr><td>[a-z&amp;&amp;[^m-p]]</td><td>匹配a-z 之间所有字符,排除m-p之间的字符是减法匹配</td></tr></tbody></table><h3 id="内置字符分类"><a href="#内置字符分类" class="headerlink" title="内置字符分类"></a>内置字符分类</h3><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>.</td><td>匹配任意一个字符,根据创建Pattern是传入的标志,可能匹配行结尾符</td></tr><tr><td>\d</td><td>匹配任意数字 [0-9]</td></tr><tr><td>\D</td><td>匹配任意非数字 [^0-9]</td></tr><tr><td>\s</td><td>匹配任意空白符 (空格, 缩进, 换行,回车)</td></tr><tr><td>\S</td><td>匹配任意非空白符</td></tr><tr><td>\w</td><td>匹配任意单词</td></tr><tr><td>\W</td><td>匹配任意非单词</td></tr></tbody></table><h3 id="边界匹配-1"><a href="#边界匹配-1" class="headerlink" title="边界匹配"></a>边界匹配</h3><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>^</td><td>匹配行首</td></tr><tr><td>$</td><td>匹配行尾</td></tr><tr><td>\b</td><td>匹配单词边界</td></tr><tr><td>\B</td><td>匹配非单词边界</td></tr><tr><td>\A</td><td>匹配文本开头</td></tr><tr><td>\G</td><td>匹配前一匹配项结尾【不知其用法和用意。】</td></tr><tr><td>\Z</td><td>输入的结束，但是对于最终终止符，如果有的话</td></tr><tr><td>\z</td><td>输入的结束</td></tr></tbody></table><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><table><thead><tr><th>贪婪模式</th><th style="text-align:center">饥饿模式</th><th style="text-align:right">独占模式</th><th style="text-align:right"></th></tr></thead><tbody><tr><td>X?</td><td style="text-align:center">X??</td><td style="text-align:right">X?+</td><td style="text-align:right">匹配0或1次</td></tr><tr><td>X*</td><td style="text-align:center">X*?</td><td style="text-align:right">X*+</td><td style="text-align:right">匹配0或多次</td></tr><tr><td>X+</td><td style="text-align:center">X+?</td><td style="text-align:right">X++</td><td style="text-align:right">匹配1或多次</td></tr><tr><td>X{n}</td><td style="text-align:center">X{n}?</td><td style="text-align:right">X{n}+</td><td style="text-align:right">匹配n次</td></tr><tr><td>X{n,}</td><td style="text-align:center">X{n,}?</td><td style="text-align:right">X{n,}+</td><td style="text-align:right">匹配最少n次</td></tr><tr><td>X{n, m}</td><td style="text-align:center">X{n, m}?</td><td style="text-align:right">X{n, m}+</td><td style="text-align:right">匹配最少n次，最多m次</td></tr></tbody></table><hr><p><strong>参考资料</strong><br>1.<a href="http://ifeve.com/java-regex/" target="_blank" rel="noopener">Java正则表达式</a><br>2.<a href="http://www.importnew.com/26560.html" target="_blank" rel="noopener">Java 正则表达式 StackOverflowError 问题及其优化</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么要使用正则表达式？&lt;/strong&gt;&lt;br&gt;节省代码，爱护队友。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在正式介绍之前，先贴一段使用了正则表达式的代码吧。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String phoneNum = &amp;quot;16510758936&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String patternString = &amp;quot;\\d&amp;#123;11&amp;#125;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Pattern pattern = Pattern.compile(patternString);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Matcher matcher = pattern.matcher(phoneNum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(&amp;quot;matches = &amp;quot;+matcher.matches());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="正则表达式" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>AutoCache高性能缓存框架使用教程</title>
    <link href="http://yoursite.com/2016/10/23/AutoCache%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/10/23/AutoCache高性能缓存框架使用教程/</id>
    <published>2016-10-22T23:00:20.000Z</published>
    <updated>2018-01-29T12:49:20.976Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2109293-d934024b5cb541e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一只正在设计AutoCache的攻城狮"></p><blockquote><p><strong>读者可能会问在下：</strong></p><ol><li>为什么要使用AutoCache？<br>简洁、高性能。</li><li>现在市面上有那么多缓存的框架，像piccso等都很优秀，那笔者是不是在重复造车？<br>AutoCache是为那些追求轻量级缓存的APP而生的。目的是让开发者既能快速完成APP缓存功能的开发，又能保证上线后性能的稳定。</li></ol></blockquote><a id="more"></a> <p><a href="https://github.com/tangxianming/auto-cache" target="_blank" rel="noopener">AutoCache</a> 能够让你高效地编写app缓存代码 ，保证你的数据流被安全、准确地存储到SDcard私有目录。参考下列核心调用代码来开始你的 AutoCache 之旅：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.MediaCache.getInstance(context).asyncCache(&quot;url&quot;, new CallBack() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onStart() &#123;</span><br><span class="line">//Run in UI thread.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void save2DataBase(String cachePath) &#123;</span><br><span class="line">//Run in io thread,</span><br><span class="line">//You can sava the  cachPath to database or sharepreference.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onSuccess(byte[] bytes) &#123;</span><br><span class="line">//Run in UI thread.</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onErro(Throwable e) &#123;</span><br><span class="line">//Run in UI thread.</span><br><span class="line">&#125;</span><br><span class="line">&#125;, FILE_TYPE, &quot;filename&quot;);</span><br></pre></td></tr></table></figure></p><p>#集成方法<br>在Module的build.gradle文件中添加如下依赖即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.txm.topcodes.autocache:autocache:0.1.2&apos;</span><br></pre></td></tr></table></figure></p><p>#调用方式<br>为方便开发者，AutoCache提供统一调用入口，调用方式十分简洁。下面先给大家看一张思维导图，该图罗列了框架的主体功能及其构成。</p><p><img src="http://upload-images.jianshu.io/upload_images/2109293-8b44b4cfd957789e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AutoCache功能结构图"></p><p>从结构图不难看出，<strong>AutoCache类</strong>就是调用框架的入口类。当我们需要从本地获取流文件时，调用方式是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.Media.get…();</span><br></pre></td></tr></table></figure></p><p>缓存网络文件时，调用方式是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.MediaCache.getInstance(context).asyncCache();</span><br></pre></td></tr></table></figure></p><p>缓存内存文件时，调用方式是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.MediaCache.getInstance(context).cache();</span><br></pre></td></tr></table></figure></p><p>当需要指定文件文件类型时，使用方式是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.DIRECTORY_PICTURES</span><br></pre></td></tr></table></figure></p><p>「如需获取详细信息，请在 <a href="https://github.com/tangxianming/auto-cache" target="_blank" rel="noopener">GitHub 的 auto-cache页面</a>查看源代码.」</p><p>#文件类型<br>AutoCache支持缓存以下泛媒体类型：Podcasts,Pictures,Movies,Music,Documents,Download。<em>其中Download比较特殊，用它可以指定未知的文件类型。</em></p><p>#使用场景<br>当我们的APP从网络获取文件流时，往往会有这样的需求「也可能是其中之一」：</p><ol><li>网络请求时，要可以自动将文件保存到APP本地。</li><li>网络请求时，将网络图片的本地路径存储到SQLite或其它数据持久化中，以方便逻辑处理。</li><li>网络请求时，直接使用从网络获取到文件流。</li><li>网络请求时，方便添加进度条功能。</li><li>网络请求时，全局捕获异常。</li><li>本次请求之后，根据文件名、文件类型从本地获取文件流。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/2109293-7880687895d6e259.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>对于需求1。</strong>AutoCache完全是在后台<em>IO线程</em>中完成的，不需要调用者主动去操作。</p><blockquote><p>IO线程：I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io线程比Thread线程更有效率。</p></blockquote><p><strong>对于需求2。</strong>save2DataBase(String cachePath)回调方法自动就被指定在IO线程中运行。「所以，save2DataBase既是一个非阻塞的方法，又具备IO线程的高效性。」</p><p><strong>对于需求3。</strong>onSuccess(byte[] bytes)回调方法被指定自动运行在UI线程中。</p><p><strong>对于需求4。</strong>AutoCache提供了onstart()回调方法作为调用开始的标志，onSuccess(byte[] bytes)或onErro(Throwable e)作为调用结束点。</p><p><strong>对于需求5。</strong>全局捕获异常指的是：onErro(Throwable e)不仅可以捕获网络异常、本地缓存媒体时发生的异常，而且还可以捕获发生在onStart、save2DataBase、onSuccess中的异常。</p><p><strong>对于需求6。</strong>AutoCache.Media类提供了4种同步方式来获取本地的媒体流。</p><p>#最佳实践</p><hr><p>####防止OOM<br>AutoCache.Media类中提供了getSoftBmp(~)，getWeakBmp(~)，getBmp(~)，getFile(~)四种方式来获取流。如果是图片文件，笔者建议使用前两种方式，具体可参考<a href="http://www.cnblogs.com/dolphin0520/p/3784171.html" target="_blank" rel="noopener">善于利用软引用和弱引用。</a></p><p>####定制回调方法<br>AutoCache框架提供了CallBackAdapter接口用于替换CallBack接口。可以通过它实现自由定制自己需要的回调方法。「这样是为了代码看上去简洁。」<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.MediaCache.getInstance(context).asyncCache(&quot;url&quot;, new CallBackAdapter() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void save2DataBase(String cachePath) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void onSuccess(byte[] bytes) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//you can add other callback function here.</span><br><span class="line">&#125;,FILE_TYPE,&quot;filename&quot;);</span><br></pre></td></tr></table></figure></p><p>#FAQ</p><hr><p><strong>我发现AutoCache还存在BUG？</strong><br>AutoCache是一个完全开源的框架，如果您在使用过程中发现问题，请在<a href="https://github.com/tangxianming/auto-cache/issues" target="_blank" rel="noopener">GitHub</a>创建一个问题。</p><p><strong>我是Eclipse用户，可以使用AutoCache么？</strong><br>不可以。</p><p><strong>AutoCache用到了哪些第三方框架？</strong><br>是的。AutoCache是在RXjava+Okhttp基础之上封装的一个轻量级缓存框架。</p><p><strong>AutoCache提供缓存文件路径到SQLite数据库的方法了吗？</strong><br>没有。AutoCache缓存的重心是将流文件缓存到本地目录。如果需要将文件路径缓存到SQLite或其他持久化数据层中，开发者需要自行在save2DataBase(cachePath)回调方法中实现逻辑。</p><p><strong>我在android studio中链接AutoCache库失败了？</strong><br>确保您的工程使用的远程仓库为jcenter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">jcenter()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2109293-d934024b5cb541e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;一只正在设计AutoCache的攻城狮&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;读者可能会问在下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么要使用AutoCache？&lt;br&gt;简洁、高性能。&lt;/li&gt;
&lt;li&gt;现在市面上有那么多缓存的框架，像piccso等都很优秀，那笔者是不是在重复造车？&lt;br&gt;AutoCache是为那些追求轻量级缓存的APP而生的。目的是让开发者既能快速完成APP缓存功能的开发，又能保证上线后性能的稳定。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的Android框架" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84Android%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Cache" scheme="http://yoursite.com/tags/Cache/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio NDK开发全攻略</title>
    <link href="http://yoursite.com/2016/08/14/NDK%E5%BC%80%E5%8F%91%E5%85%A8%E6%94%BB%E7%95%A5/"/>
    <id>http://yoursite.com/2016/08/14/NDK开发全攻略/</id>
    <published>2016-08-14T07:56:00.000Z</published>
    <updated>2017-12-29T12:15:16.462Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2109293-2f486474306a0eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><strong>读完本章，你可以：</strong></p><ul><li><em>在Android Studio上轻松搭建NDK开发环境。</em></li><li><em>掌握最快捷的JNI开发方式。</em></li><li><em>掌握使用.so文件开发Android程序的技巧。</em></li></ul></blockquote><a id="more"></a> <h3 id="一、-NDK环境搭建"><a href="#一、-NDK环境搭建" class="headerlink" title="一、 NDK环境搭建"></a>一、 NDK环境搭建</h3><ol><li>开发工具准备<br>要进行Android NDK开发，首先要下载Android NDK开发工具。可以在AndroidStudio上面下载，也可以自己下载好了，然后将NDK的路径设置为自己下载的Android NDK开发工具的路径。<br><img src="http://upload-images.jianshu.io/upload_images/2109293-935b1d5e7af0abb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android Studio中设置NDK路径"></li><li>Gradle的相关配置<br>1) 我们来配置Project的build.gradle。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*gradle插件不支持NDK，我们需要使用gradle-experimental插件。 */</span><br><span class="line">dependencies &#123;</span><br><span class="line">classpath &apos;com.android.tools.build:gradle-experimental:0.7.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2) 我们来配置Module的build.gradle。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.model.application&apos;</span><br><span class="line">model &#123;</span><br><span class="line">android &#123;</span><br><span class="line">compileSdkVersion = 23</span><br><span class="line">buildToolsVersion = &quot;23.0.2&quot;</span><br><span class="line">defaultConfig &#123;</span><br><span class="line">applicationId &quot;com.lavor.ndklearning&quot;</span><br><span class="line">minSdkVersion.apiLevel 15</span><br><span class="line">targetSdkVersion.apiLevel 23</span><br><span class="line">versionCode 4</span><br><span class="line">versionName &quot;1.0.1&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">android.ndk &#123;</span><br><span class="line">moduleName &quot;lavor&quot;</span><br><span class="line">ldLibs.addAll([&apos;log&apos;])</span><br><span class="line">cppFlags.add(&quot;-std=c++11&quot;)</span><br><span class="line">cppFlags.add(&quot;-fexceptions&quot;)</span><br><span class="line">platformVersion 15</span><br><span class="line">stl &apos;gnustl_shared&apos;</span><br><span class="line">&#125;</span><br><span class="line">android.buildTypes &#123;</span><br><span class="line">release &#123;</span><br><span class="line">minifyEnabled = false</span><br><span class="line">proguardFiles.add(file(&quot;proguard-rules.txt&quot;))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">compile &apos;com.android.support:appcompat-v7:23.1.1&apos;</span><br><span class="line">compile &apos;com.android.support:recyclerview-v7:23.1.1&apos;</span><br><span class="line">compile &apos;com.android.support:design:23.1.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>小提示</strong> </p><ul><li>首先，在apply的时候我们引入的插件名称由’com.android.application’变成了’com.android.model.application’。</li><li>其次，在原来android的外层加入了一个model层次。</li><li>再次，原来在android的里面的块，除了defaultConfig外，全部移除android块放入model块中与android并列，并且前面的名字加上android.。</li><li>然后，compileSdkVersion 23与 buildToolsVersion “23.0.2”改成 compileSdkVersion = 23和 buildToolsVersion = “23.0.2”，中间加上了=。</li><li>其次，添加上android.ndk块，块中的moduleName表示C/C++代码打包成so文件的名字。</li><li>再次，android.buildTypes块中的proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’改成proguardFiles.add(file(“proguard-rules.txt”))。</li><li>最后，注意dependencies块依然在最外层，它不在model块中。</li></ul></blockquote><h3 id="二、-使用NDK开发第一个JNI程序"><a href="#二、-使用NDK开发第一个JNI程序" class="headerlink" title="二、 使用NDK开发第一个JNI程序"></a>二、 使用NDK开发第一个JNI程序</h3><ol><li>在Android程序中新建一个包含native（本地）方法的NDKTest类。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.lavor.ndklearning;</span><br><span class="line">public class NDKTest &#123;</span><br><span class="line">static &#123;</span><br><span class="line">//加载.so库文件</span><br><span class="line">System.loadLibrary(&quot;lavor&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public native String getString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>小知识</strong> </p><ul><li>程序中static{}称为静态代码块，它在类初始化的时候执行。<a href="http://www.2cto.com/kf/201204/127350.html" target="_blank" rel="noopener">不懂请猛击&gt;&gt;</a></li></ul><ol><li>将鼠标移动到方法名getString上，然后按下Alt+Enter快捷键，弹出一些解决的方法建议，点击第一个Create Function…<br><img src="http://upload-images.jianshu.io/upload_images/2109293-b72c498ba03487b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自动生成.c文件"></li><li>此时会自动建立一个与java目录同级的jni目录，在jni目录自动建立一个c文件，在c文件中实现了刚才的native方法。<br><img src="http://upload-images.jianshu.io/upload_images/2109293-45dae37602388281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=".c文件"></li><li>然后，稍稍修改一下.c文件中实现的native方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_lavor_ndklearning_NDKTest_getString(JNIEnv *env, jobject instance) &#123;</span><br><span class="line">// TODO</span><br><span class="line">return (*env)-&gt;NewStringUTF(env, &quot;AndroidStudio NDK开发最佳入门实践&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>补充说明</strong> </p><ul><li>仔细观察可以看到c文件的方法名是遵循“Java_包名类名本地方法名”来组织的（了解到这些后，我们就可以脱离编译器的帮助，直接去写.c文件啦）。</li></ul><ol><li>最后在Android程序中调用JNI接口。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">private android.widget.TextView text;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">this.text = (TextView) findViewById(R.id.text);</span><br><span class="line">NDKTest NDK=new NDKTest();</span><br><span class="line">text.setText(NDK.getString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>运行程序后界面如下：<br><img src="http://upload-images.jianshu.io/upload_images/2109293-adee2cd57d50fdf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p><blockquote><p><strong>深度总结</strong> </p><ul><li>讲道理，我们在正式开发时，不会像这样子去开发。因为这样的话就会把我们的c代码也暴露了出来。这明显与JNI的安全保密机制相违背，所以，正式开发的时候，我们会使用.so文件进行全保密式的开发。</li></ul></blockquote><h3 id="三、-使用-so文件开发Android程序"><a href="#三、-使用-so文件开发Android程序" class="headerlink" title="三、 使用.so文件开发Android程序"></a>三、 使用.so文件开发Android程序</h3><p>不知道大家有没有记得<a href="http://www.jianshu.com/p/cd8893549238" target="_blank" rel="noopener">上一章</a>说过，使用JNI有个好处就是安全性高，JNI部分的代码很难被反编译。这其实是要归功于.so文件。下图为.so文件的生成位置。<br><img src="http://upload-images.jianshu.io/upload_images/2109293-bb1e5e5126c27518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android Studio中生成的.so文件位置"><br>具体的使用步骤是怎样的呢？</p><ol><li>新建一个Android工程，命名为：AndroidApplication。（工程名、包名、组织名任意）<br><img src="http://upload-images.jianshu.io/upload_images/2109293-216c5583d760f537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个随意的Android工程"></li><li>导入.so文件至app/libs中。<br><img src="http://upload-images.jianshu.io/upload_images/2109293-c5b1fcba143015f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入.so文件至Android工程"></li><li><p>为了能够调用libs文件夹下的.so资源，需在app的build.gradle的android节点下设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sourceSets&#123;</span><br><span class="line">main&#123;</span><br><span class="line">jniLibs.srcDirs = [&apos;libs&apos;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建相关类结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.lavor.ndklearning;</span><br><span class="line">public class NDKTest &#123;</span><br><span class="line">static &#123;</span><br><span class="line">//加载.so库文件</span><br><span class="line">System.loadLibrary(&quot;lavor&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public native String getString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>补充说明</strong> </p><ul><li>Android端声明native code的代码需要严格按照JNI接口来组织。（也就是说，包名、类名都要和.so文件中JNI名称一致）<a href="http://billhoo.blog.51cto.com/2337751/1125559" target="_blank" rel="noopener">不懂就点击这里吧&gt;&gt;</a></li></ul><ol><li>函数调用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DemoActivity extends AppCompatActivity &#123;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_demo);</span><br><span class="line">Log.d(&quot;NDK&quot;,new NDKTest().getString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>运行结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/2109293-9974de0ded907081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p><blockquote><p> 注意啦！<em>此文并非原创，算是对一波优秀文章的总结吧。笔者希望通过这种方式激励自己学习，也期待可以帮到正在学习NDK的你。欢迎指出本文的BUG，共勉！！！！！</em></p></blockquote><hr><p><strong>参考资料</strong></p><ol><li><a href="https://github.com/lavor-zl/NDKLearning" target="_blank" rel="noopener">AndroidStudio NDK开发最佳入门实践</a></li><li><a href="http://billhoo.blog.51cto.com/2337751/1125559" target="_blank" rel="noopener">如何在Android中使用编译好的.so库</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2109293-2f486474306a0eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;读完本章，你可以：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;在Android Studio上轻松搭建NDK开发环境。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;掌握最快捷的JNI开发方式。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;掌握使用.so文件开发Android程序的技巧。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NDK" scheme="http://yoursite.com/categories/NDK/"/>
    
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
      <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>七夕前，我认识了NDK</title>
    <link href="http://yoursite.com/2016/08/06/%E4%B8%83%E5%A4%95%E5%89%8D%EF%BC%8C%E6%88%91%E8%AE%A4%E8%AF%86%E4%BA%86NDK/"/>
    <id>http://yoursite.com/2016/08/06/七夕前，我认识了NDK/</id>
    <published>2016-08-06T10:57:00.000Z</published>
    <updated>2017-12-29T12:19:39.103Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2109293-3952aad8fb71012c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NDK妹子生活照"></p><blockquote><p><strong>看前必读</strong></p><ul><li><em>读完本章，你可以掌握NDK、JNI的概念及其开发流程。</em></li><li><em>阅读时，不必纠结于读不懂的代码结构，后面的教程 都会讲到的。</em></li></ul></blockquote><a id="more"></a> <h3 id="一、为何要学习NDK？"><a href="#一、为何要学习NDK？" class="headerlink" title="一、为何要学习NDK？"></a>一、为何要学习NDK？</h3><ol><li>代码的保护。Android APK的Java层代码很容易被反编译，但C/C++库反编译难度较大。</li><li>可以方便地使用现存的开源库。大部分现存的开源库都是用C/C++代码编写的。</li><li>提高程序的执行效率。将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。</li><li>便于移植。用C/C++写的库可以方便在其他的嵌入式平台上再次使用。</li></ol><h3 id="二、先知道什么是JNI"><a href="#二、先知道什么是JNI" class="headerlink" title="二、先知道什么是JNI"></a>二、先知道什么是JNI</h3><p>JNI（Java Native Interface）是Java语言提供的Java和C/C++互相沟通的机制，可以实现：</p><ol><li>java调用本地的C/C++代码</li><li>本地的C/C++代码也可以调用java代码</li></ol><h3 id="三、开发JNI程序的简化流程"><a href="#三、开发JNI程序的简化流程" class="headerlink" title="三、开发JNI程序的简化流程"></a>三、开发JNI程序的简化流程</h3><ol><li><p>编写Java Code，如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 加载lavor本地共享库到内存中</span><br><span class="line">*/</span><br><span class="line">static &#123;</span><br><span class="line">System.loadLibrary(&quot;lavor&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 定义本地方法对应的Java方法</span><br><span class="line">*</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public native String getString();</span><br></pre></td></tr></table></figure></li><li><p>编写C/C++，如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_lavor_ndklearning_MainActivity_getString(JNIEnv *env, jobject instance) &#123;</span><br><span class="line"></span><br><span class="line">return (*env)-&gt;NewStringUTF(env, &quot;这是我的c程序代码&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译 C/C++ Code，成功并得到本地共享库。</p><blockquote><p><strong>小知识</strong> </p><ul><li>本地共享库是Linux下的叫法，文件扩展名是.so，windows下叫动态链接库，文件扩展名是.dll。</li><li><a name="001" id="001">C /C++的跨平台性是以牺牲编译时间以及编译难度为代价的。（<em>这里的编译难度是指为适应不同平台而做的编译过程的调整）</em></a></li><li>Java的一次编译到处运行，是以牺牲运行效率为代价的。</li></ul></blockquote></li><li><p>编译并打包Java。<br>把本地共享库<em>（.so文件）</em>放置到Java项目的指定目录，一般是libs文件夹。然后编译Java代码即可打包运行。</p><blockquote><p><strong>小知识</strong></p><ul><li>Android项目中，.so文件存放地址为libs/armeabi。<em>(armeabi是对应的平台，下一章将会详细介绍)</em></li></ul></blockquote></li></ol><h3 id="四、NDK概述"><a href="#四、NDK概述" class="headerlink" title="四、NDK概述"></a>四、NDK概述</h3><p>NDK<em>(Native  Development Kit)</em>是Google为Android进行本地开发而放出的一个本地开发工具， 包括Android的Native API、公共库以及编译工具。其实说白就是Google为方便Android程序猿开发JNI程序，而提供的便捷工具。</p><blockquote><p><strong>补充两点</strong></p><ul><li>NDK处在JNI开发流程中的编译环节<em>（第三、四步）</em>。针对不同的平台，NDK可以全自动编译出对应可运行的本地共享库，并可将对应的.so文件和应用程序一起打包成apk发布。<em>（这时，跨平台编译C/C++的难度指数降为0。<a href="#001">不明白请猛击</a>）</em></li><li>NDK需要Android 1.5版本以上的支持。</li></ul></blockquote><h3 id="五、开发NDK程序的流程"><a href="#五、开发NDK程序的流程" class="headerlink" title="五、开发NDK程序的流程"></a>五、开发NDK程序的流程</h3><p>这个开发流程大致与JNI的开发流程差不多：</p><ol><li>SDK开发。编写Java代码，调用各种Android的API实现功能，编写含有native关键字的代码开始JNI。</li><li>JNI开发。按照 JNI编码规范，编写与Java交互的本地代码<em>（一般就是数据类型的转换，把 C/C++的数据类转换成Java能识别的，或反过来）</em>。</li><li>C/C++开发。编码实现业务逻辑，或调用NDK提供的本地API或库，完成Android平台上特定功能的开发、封装。</li><li>NDK编译，编写.mk文件，编译调试，最后修改.mk文件，针对特定的平台（ARM/x86）做编译结果的优化。</li><li>最后就是SDK编译、打包，上真机调试了…</li></ol><blockquote><p> 注意啦！<em>此文并非原创，算是对一波优秀文章的总结吧。笔者希望通过这种方式激励自己学习，也期待可以帮到正在学习NDK的你。欢迎指出本文的BUG，共勉！！！！！</em></p></blockquote><hr><p><strong>参考资料</strong><br><a href="http://www.cnblogs.com/devinzhang/archive/2012/02/29/2373729.html" target="_blank" rel="noopener">Android之NDK开发</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2109293-3952aad8fb71012c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;NDK妹子生活照&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;看前必读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;读完本章，你可以掌握NDK、JNI的概念及其开发流程。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;阅读时，不必纠结于读不懂的代码结构，后面的教程 都会讲到的。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NDK" scheme="http://yoursite.com/categories/NDK/"/>
    
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
      <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
</feed>
