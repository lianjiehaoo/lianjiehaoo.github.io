<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TXM</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-16T15:02:28.593Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>TXM</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/01/16/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/16/Java正则表达式详解/</id>
    <published>2018-01-15T16:00:00.000Z</published>
    <updated>2018-01-16T15:02:28.593Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>为什么要使用正则表达式？</strong><br>节省代码，爱护队友。</p></blockquote><p>在正式介绍之前，先贴一段使用了正则表达式的代码吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String phoneNum = &quot;16510758936&quot;;</span><br><span class="line">String patternString = &quot;\\d&#123;11&#125;&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString);</span><br><span class="line">Matcher matcher = pattern.matcher(phoneNum);</span><br><span class="line">System.out.println(&quot;matches = &quot;+matcher.matches());</span><br></pre></td></tr></table></figure></p><p>仅这段代码就可以简单判断字符串（代码中的“phoneNum”字符串）是否为手机号格式。是不是很高效呢？事实上正则表达式还可以做很多很酷的事情，所以我们很有必要认真的学一下它。本文将从API、语法两个维度介绍该主题。</p><p>#API使用<br>类 java.util.regex.Pattern 简称 Pattern, 是Java正则表达式API中的主要入口，无论何时,需要使用正则表达式,从Pattern 类开始</p><p>###Pattern.matches()<br>这是检测正则表达式的模式是否匹配一段文本的最直接方法，eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;This is the text to be searched &quot; +</span><br><span class="line">&quot;for occurrences of the pattern.&quot;;</span><br><span class="line">String pattern = &quot;.*is.*&quot;;</span><br><span class="line">boolean matches = Pattern.matches(pattern, text);</span><br><span class="line">System.out.println(&quot;matches = &quot; + matches);</span><br></pre></td></tr></table></figure></p><p>“.”表示任意字符，“*”表示0或者多个，“.*”组合表示0或者多个任意字符。显然， “.*is.*“代表一个字符串中包含“is”字段，上面代码返回结果是true。<br>Pattern.matches() 方法适用于检查 一个模式在一个文本中出现一次的情况，或适用于Pattern类的默认设置。<br>如果需要匹配多次出现,甚至输出不同的匹配文本，或者只是需要非默认设置。需要通过Pattern.compile() 方法得到一个Pattern 实例。</p><p>###Pattern.compile()<br>如果需要匹配一个正则表达式在文本中多次出现，需要通过Pattern.compile() 方法创建一个Pattern对象。示例如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;This is the text to be searched &quot; +</span><br><span class="line">&quot;for occurrences of the http:// pattern.&quot;;</span><br><span class="line">String patternString = &quot;.*http://.*&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString);</span><br></pre></td></tr></table></figure></p><p>可以在Compile 方法中，指定一个特殊标志：<br>Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);<br>Pattern 类包含多个标志(int 类型),这些标志可以控制Pattern 匹配模式的方式。上面代码中的标志使模式匹配是忽略大小写</p><p>###pattern.matcher()<br>一旦获得了Pattern对象，接着可以获得Matcher对象。Matcher 示例用于匹配文本中的模式.示例如下<br>Matcher matcher = pattern.matcher(text);<br>Matcher类有一个matches()方法，可以检查文本是否匹配模式。以下是关于Matcher的一个完整例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;This is the text to be searched &quot; +</span><br><span class="line">&quot;for occurrences of the http:// pattern.&quot;;</span><br><span class="line">String patternString = &quot;.*http://.*&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);</span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br><span class="line">boolean matches = matcher.matches();</span><br><span class="line">System.out.println(&quot;matches = &quot; + matches);</span><br></pre></td></tr></table></figure></p><p>###pattern.split()<br>Pattern 类的 split()方法，可以用正则表达式作为分隔符，把文本分割为String类型的数组。示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String text = &quot;A sep Text sep With sep Many sep Separators&quot;;</span><br><span class="line">String patternString = &quot;sep&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString);</span><br><span class="line">String[] split = pattern.split(text);</span><br><span class="line">System.out.println(&quot;split.length = &quot; + split.length);</span><br><span class="line">for(String element : split)&#123;</span><br><span class="line">System.out.println(&quot;element = &quot; + element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上例中把text 文本分割为一个包含5个字符串的数组。</p><p>###pattern.pattern()<br>Pattern 类的 pattern 返回用于创建Pattern 对象的正则表达式。</p><p>###Matcher (java.util.regex.Matcher)<br>java.util.regex.Matcher 类用于匹配一段文本中多次出现一个正则表达式，Matcher 也适用于多文本中匹配同一个正则表达式。<br><strong>创建Matcher</strong><br>通过Pattern 的matcher() 方法创建一个Matcher。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;This is the text to be searched &quot; +</span><br><span class="line">&quot;for occurrences of the http:// pattern.&quot;;</span><br><span class="line">String patternString = &quot;.*http://.*&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString);</span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br></pre></td></tr></table></figure></p><p><strong>matches()</strong><br>Matcher 类的 matches() 方法用于在文本中匹配正则表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean matches = matcher.matches();</span><br></pre></td></tr></table></figure></p><p>如果文本匹配正则表达式，matches() 方法返回true。否则返回false。matches() 方法不能用于查找正则表达式多次出现。如果需要，要使用find(), start() 和 end() 方法。<br><strong>lookingAt()</strong><br>lookingAt() 与matches() 方法类似，最大的不同是，lookingAt()方法对文本的开头匹配正则表达式；而matches() 对整个文本匹配正则表达式。换句话说，如果正则表达式匹配文本开头而不匹配整个文本,lookingAt() 返回true,而matches() 返回false。 示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;This is the text to be searched &quot; +</span><br><span class="line">&quot;for occurrences of the http:// pattern.&quot;;</span><br><span class="line">String patternString = &quot;This is the&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);</span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br><span class="line">System.out.println(&quot;lookingAt = &quot; + matcher.lookingAt());</span><br><span class="line">System.out.println(&quot;matches   = &quot; + matcher.matches());</span><br></pre></td></tr></table></figure></p><p>上面的例子分别对文本开头和整个文本匹配正则表达式 “this is the”, 匹配文本开头的方法(lookingAt()) 返回true。<br>对整个文本匹配正则表达式的方法 (matches()) 返回false，因为整个文本包含多余的字符,而正则表达式要求文本精确匹配”this is the”,前后又不能有额外字符。<br><strong>find() + start() + end()</strong><br>find() 方法用于在文本中查找出现的正则表达式，文本是创建Matcher时，通过 Pattern.matcher(text) 方法传入的。如果在文本中多次匹配，find() 方法返回第一个，之后每次调用 find() 都会返回下一个。<br>start() 和 end() 返回每次匹配的字串在整个文本中的开始和结束位置。实际上, end() 返回的是字符串末尾的后一位，这样，可以在把 start() 和 end() 的返回值直接用在String.substring() 里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;This is the text which is to be searched &quot; +</span><br><span class="line">&quot;for occurrences of the word &apos;is&apos;.&quot;;</span><br><span class="line">String patternString = &quot;is&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString);</span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br><span class="line">int count = 0;</span><br><span class="line">while(matcher.find()) &#123;</span><br><span class="line">count++;</span><br><span class="line">System.out.println(&quot;found: &quot; + count + &quot; : &quot;  + matcher.start() + &quot; - &quot; + matcher.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子在文本中找到模式 “is” 4次，输出如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">found: 1 : 2 - 4</span><br><span class="line">found: 2 : 5 - 7</span><br><span class="line">found: 3 : 23 - 25</span><br><span class="line">found: 4 : 70 - 72</span><br></pre></td></tr></table></figure></p><p><strong>reset()</strong><br>reset() 方法会重置Matcher 内部的 匹配状态。当find() 方法开始匹配时,Matcher 内部会记录截至当前查找的距离。调用 reset() 会重新从文本开头查找。<br>也可以调用 reset(CharSequence) 方法. 这个方法重置Matcher,同时把一个新的字符串作为参数传入，用于代替创建 Matcher 的原始字符串。</p><blockquote><p><strong>补充：</strong><br>如果在程序中多次使用同一个正则表达式，一定要用Pattern.compile()编译，代替直接使用Pattern.matches()。如果一次次对同一个正则表达式使用Pattern.matches()，例如在循环中，没有编译的正则表达式消耗比较大。因为matches()方法每次都会预编译使用的表达式。另外，记住你可以通过调用reset()方法对不同的输入字符串重复使用Matcher对象。</p></blockquote><p><strong>group()</strong><br>假设想在一个文本中查找URL链接，并且想把找到的链接提取出来。当然可以通过 start()和 end()方法完成。但是用group()方法更容易些。<br>分组在正则表达式中用括号表示，例如:<br>(John)<br>此正则表达式匹配John, 括号不属于要匹配的文本。括号定义了一个分组。当正则表达式匹配到文本后，可以访问分组内的部分。<br>使用group(int groupNo) 方法访问一个分组。一个正则表达式可以有多个分组。每个分组由一对括号标记。想要访问正则表达式中某分组匹配的文本，可以把分组编号传入 group(int groupNo)方法。<br>group(0) 表示整个正则表达式，要获得一个有括号标记的分组，分组编号应该从1开始计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String text    =  &quot;John writes about this, and John writes about that,&quot; +</span><br><span class="line">&quot; and John writes about everything. &quot;  ;</span><br><span class="line">String patternString1 = &quot;(John)&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString1);</span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br><span class="line">while(matcher.find()) &#123;</span><br><span class="line">System.out.println(&quot;found: &quot; + matcher.group(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以上代码在文本中搜索单词John.从每个匹配文本中，提取分组1，就是由括号标记的部分。输出：</span><br><span class="line">found: John</span><br><span class="line">found: John</span><br><span class="line">found: John</span><br></pre></td></tr></table></figure><p><strong>多分组</strong><br>上面提到，一个正则表达式可以有多个分组，例如：<br>(John) (.+?)<br>这个表达式匹配文本”John” 后跟一个空格,然后跟1个或多个字符，最后跟一个空格。你可能看不到最后的空格。<br>这个表达式包括一些字符有特别意义。字符 点 . 表示任意字符。 字符 + 表示出现一个或多个，和. 在一起表示 任何字符,出现一次或多次。字符? 表示 匹配尽可能短的文本。<br>完整代码如下：<br>String text    =<br>“John writes about this, and John Doe writes about that,” +<br>“ and John Wayne writes about everything.”<br>;<br>String patternString1 = “(John) (.+?) “;<br>Pattern pattern = Pattern.compile(patternString1);<br>Matcher matcher = pattern.matcher(text);<br>while(matcher.find()) {<br>System.out.println(“found: “ + matcher.group(1) +<br>“ “       + matcher.group(2));<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意代码中引用分组的方式。代码输出如下:</span><br><span class="line">found: John writes</span><br><span class="line">found: John Doe</span><br><span class="line">found: John Wayne</span><br></pre></td></tr></table></figure></p><p><strong>嵌套分组</strong><br>在正则表达式中分组可以嵌套分组，例如:<br>((John) (.+?))<br>这是之前的例子，现在放在一个大分组里.(表达式末尾有一个空格)。<br>当遇到嵌套分组时, 分组编号是由左括号的顺序确定的。上例中，分组1 是那个大分组。分组2 是包括John的分组，分组3 是包括 .+? 的分组。当需要通过groups(int groupNo) 引用分组时，了解这些非常重要。<br>以下代码演示如何使用嵌套分组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;John writes about this, and John Doe writes about that,&quot; +</span><br><span class="line">&quot; and John Wayne writes about everything.&quot;</span><br><span class="line">;</span><br><span class="line">String patternString1 = &quot;((John) (.+?)) &quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString1);</span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br><span class="line">while(matcher.find()) &#123;</span><br><span class="line">System.out.println(&quot;found:   &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出如下</span><br><span class="line">found:</span><br><span class="line">found:</span><br><span class="line">found:</span><br></pre></td></tr></table></figure><p><strong>replaceAll() + replaceFirst()</strong><br>replaceAll() 和 replaceFirst() 方法可以用于替换Matcher搜索字符串中的一部分。replaceAll() 方法替换全部匹配的正则表达式，replaceFirst() 只替换第一个匹配的。<br>在处理之前，Matcher 会先重置。所以这里的匹配表达式从文本开头开始计算。<br>示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;John writes about this, and John Doe writes about that,&quot; +</span><br><span class="line">&quot; and John Wayne writes about everything.&quot;</span><br><span class="line">;</span><br><span class="line">String patternString1 = &quot;((John) (.+?)) &quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString1);</span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br><span class="line">String replaceAll = matcher.replaceAll(&quot;Joe Blocks &quot;);</span><br><span class="line">System.out.println(&quot;replaceAll   = &quot; + replaceAll);</span><br><span class="line">String replaceFirst = matcher.replaceFirst(&quot;Joe Blocks &quot;);</span><br><span class="line">System.out.println(&quot;replaceFirst = &quot; + replaceFirst);</span><br></pre></td></tr></table></figure></p><p>输出如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">replaceAll = Joe Blocks about this, and Joe Blocks writes about that,</span><br><span class="line">and Joe Blocks writes about everything.</span><br><span class="line">replaceFirst = Joe Blocks about this, and John Doe writes about that,</span><br><span class="line">and John Wayne writes about everything.</span><br></pre></td></tr></table></figure></p><p><strong>appendReplacement() + appendTail()</strong><br>appendReplacement() 和 appendTail() 方法用于替换输入文本中的字符串短语，同时把替换后的字符串附加到一个 StringBuffer 中。<br>当find() 方法找到一个匹配项时，可以调用 appendReplacement() 方法，这会导致输入字符串被增加到StringBuffer 中，而且匹配文本被替换。 从上一个匹配文本结尾处开始，直到本次匹配文本会被拷贝。<br>appendReplacement() 会记录拷贝StringBuffer 中的内容，可以持续调用find(),直到没有匹配项。<br>直到最后一个匹配项目，输入文本中剩余一部分没有拷贝到 StringBuffer. 这部分文本是从最后一个匹配项结尾，到文本末尾部分。通过调用 appendTail() 方法，可以把这部分内容拷贝到 StringBuffer 中.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String text    =</span><br><span class="line">&quot;John writes about this, and John Doe writes about that,&quot; +</span><br><span class="line">&quot; and John Wayne writes about everything.&quot;</span><br><span class="line">;</span><br><span class="line">String patternString1 = &quot;((John) (.+?)) &quot;;</span><br><span class="line">Pattern      pattern      = Pattern.compile(patternString1);</span><br><span class="line">Matcher      matcher      = pattern.matcher(text);</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">while(matcher.find())&#123;</span><br><span class="line">matcher.appendReplacement(stringBuffer, &quot;Joe Blocks &quot;);</span><br><span class="line">System.out.println(stringBuffer.toString());</span><br><span class="line">&#125;</span><br><span class="line">matcher.appendTail(stringBuffer);</span><br><span class="line">System.out.println(stringBuffer.toString());</span><br></pre></td></tr></table></figure></p><p>注意我们在while循环中调用appendReplacement() 方法。在循环完毕后调用appendTail()。代码输出如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Joe Blocks</span><br><span class="line">Joe Blocks about this, and Joe Blocks</span><br><span class="line">Joe Blocks about this, and Joe Blocks writes about that, and Joe Blocks</span><br><span class="line">Joe Blocks about this, and Joe Blocks writes about that, and Joe Blocks</span><br><span class="line">writes about everything.</span><br></pre></td></tr></table></figure></p><p>#Java 正则表达式语法<br>为了更有效的使用正则表达式，需要了解正则表达式语法。正则表达式语法很复杂，可以写出非常高级的表达式。只有通过大量的练习才能掌握这些语法规则。</p><p>###基本语法<br>在介绍高级功能前，我们先快速浏览下正则表达式的基本语法。<br><strong>字符</strong><br>是正则表达式中最经常使用的的一个表达式，作用是简单的匹配一个确定的字符。例如：John<br>这个简单的表达式将会在一个输入文本中匹配John文本。<br>可以在表达式中使用任意英文字符。也可以使用字符对于的8进制，16进制或unicode编码表示。例如：<br>101<br>\x41<br>\u0041<br>以上3个表达式 都表示大写字符A。第一个是8进制编码(101),第2个是16进制编码(41),第3个是unicode编码(0041).<br><strong>字符分类</strong><br>字符分类是一种结构，可以针对多个字符匹配而不只是一个字符。换句话说，一个字符分类匹配输入文本中的一个字符，对应字符分类中多个允许字符。例如，你想匹配字符 a,b 或c，表达式如下：<br>[abc]<br>用一对方括号[] 表示字符分类。方括号本身并不是要匹配的一部分。<br>可以用字符分类完成很多事。例如想要匹配单词John，首字母可以为大写和小写J.<br>[Jj]ohn<br>字符分类[Jj] 匹配J或j，剩余的 ohn 会准确匹配字符ohn.<br><strong>预定义字符分类</strong><br>正则表达式中有一些预定义的字符分类可以使用。例如, \d 表示任意数字, \s 表示任意空白字符,\w 表示任意单词字符。<br>预定义字符分类不需要括在方括号里，当然也可以组合使用<br>\d<br>[\d\s]<br>第1个匹配任意数字，第2个匹配任意数字或空白符。<br>完整的预定义字符分类列表，在本文最后列出。<br><strong>边界匹配</strong><br>正则表达式支持匹配边界，例如单词边界，文本的开头或末尾。例如，\w 匹配一个单词，^匹配行首,$ 匹配行尾。<br>^This is a single line$<br>上面的表达式匹配一行文本，只有文本 This is a single line。注意其中的行首和行尾标志，表示不能有任何文本在文本的前面后后面，只能是行首和行尾。<br>完整的匹配边界列表，在本文最后列出。<br><strong>量词匹配</strong><br>量词可以匹配一个表达式多次出现。例如下列表达式匹配字母A 出现0次或多次。<br>A*<br>量词 * 表示0次或多次。+ 表示1次或多次。? 表示0次或1次。还有些其他量词，参见本文后面的列表。<br>量词匹配分为：饥饿模式,贪婪模式,独占模式。饥饿模式 匹配尽可能少的文本。贪婪模式匹配尽可能多的文本。独占模式匹配尽可能多的文本，甚至导致剩余表达式匹配失败。<br>以下演示饥饿模式,贪婪模式,独占模式区别。假设以下文本：<br>John went for a walk, and John fell down, and John hurt his knee.<br>饥饿模式下 表达式：<br>John.*?<br>这个表达式匹配John 后跟0个或多个字符。 . 表示任意字符。* 表示0或多次。? 跟在 * 后面，表示 * 采用饥饿模式。<br>饥饿模式下，量词只会匹配尽可能少的字符，即0个字符。上例中的表达式将会匹配单词John,在输入文本中出现3次。<br>如果改为贪婪模式，表达式如下：<br>John.*<br>贪婪模式下，量词会匹配尽可能多的字符。现在表达式会匹配第一个出现的John，以及在贪婪模式下 匹配剩余的所有字符。这样，只有一个匹配项。<br>最后，我们改为独占模式：<br>John.*+hurt<br>*后跟+ 表示独占模式量词。<br>这个表达式在输入文本中没有匹配项，尽管文本中包括 John 和 hurt. 为什么会这样? 因为 .*+ 是独占模式。与贪婪模式下，尽可能多的匹配文本，以使整个表达式匹配不同。独占模式会尽可能的多的匹配，但不考虑表达式剩余部分是否能匹配上。<br>.*+ 将会匹配第一个John之后的所有字符，这会导致表达式中剩余的 hurt 没有匹配项。如果改为贪婪模式，会有一个匹配项。表达式如下：<br>John.*hurt<br><strong>逻辑操作符</strong><br>正则表达式支持少量的逻辑运算(与，或，非)。<br>与操作是默认的，表达式 John ,意味着J 与 o与h与n。<br>或操作需要显示指定，用 | 表示。例如表达式 John|hurt 意味着John 或 hurt 。</p><p>###字符<br>| Type| Description |<br>|————- |————-|<br>| .      | 除换行以外的任意字符        |<br>| \\      | 反斜杠, 单独的反斜杠做为转义字符,与其他特殊字符一起使用。如果想匹配反斜杠本身,需要转义。两个反斜杠实际匹配一个反斜杠。<br>| nn      | 字符的8进制表示.n 在0至7之间取值       |<br>| mnn      | 字符的8进制表示. m 在0至3之间取值, n 在0至7之间取值|<br>| \xhh          | 字符的16进制表示.|<br>| \uhhhh      | 字符的16进制表示 0xhhhh. 对应unicode 编码字符|<br>| \t      | 缩进符.|<br>| \n     | 换行符 (unicode: ‘\u000A’)|<br>| \r      | 回车符 (unicode: ‘\u000D’)|<br>| \f         | 制表符 (unicode: ‘\u000C’)|<br>| \a          | 警报（铃声）字符 (unicode: ‘\u0007’)|<br>| \e      | 转义符 (unicode: ‘\u001B’)|<br>| \cx          | 控制符 x|</p><p>###字符分类</p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>[abc]</td><td>匹配 a, 或 b 或 c</td></tr><tr><td>[^abc]</td><td>匹配不是a,b,c 的字符，是否定匹配</td></tr><tr><td>[a-zA-Z]</td><td>匹配a 到 z ，A到Z 直接的字符，是范围匹配</td></tr><tr><td>[a-d[m-p]]</td><td>匹配a到d之间字符或 m到p之间字符，是并集匹配</td></tr><tr><td>[a-z&amp;&amp;[def]]</td><td>匹配 d, e, 或 f. 是交集匹配 (这里是在范围 a-z和字符def之间取交集).</td></tr><tr><td>[a-z&amp;&amp;[^bc]]</td><td>匹配a-z 之间所有字符，排除bc的字符。是减法匹配</td></tr><tr><td>[a-z&amp;&amp;[^m-p]]</td><td>匹配a-z 之间所有字符,排除m-p之间的字符是减法匹配</td></tr></tbody></table><p>###内置字符分类</p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>.</td><td>匹配任意一个字符,根据创建Pattern是传入的标志,可能匹配行结尾符</td></tr><tr><td>\d</td><td>匹配任意数字 [0-9]</td></tr><tr><td>\D</td><td>匹配任意非数字 [^0-9]</td></tr><tr><td>\s</td><td>匹配任意空白符 (空格, 缩进, 换行,回车)</td></tr><tr><td>\S</td><td>匹配任意非空白符</td></tr><tr><td>\w</td><td>匹配任意单词</td></tr><tr><td>\W</td><td>匹配任意非单词</td></tr></tbody></table><p>###边界匹配</p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>^</td><td>匹配行首</td></tr><tr><td>$</td><td>匹配行尾</td></tr><tr><td>\b</td><td>匹配单词边界</td></tr><tr><td>\B</td><td>匹配非单词边界</td></tr><tr><td>\A</td><td>匹配文本开头</td></tr><tr><td>\G</td><td>匹配前一匹配项结尾【不知其用法和用意。】</td></tr><tr><td>\Z</td><td>输入的结束，但是对于最终终止符，如果有的话</td></tr><tr><td>\z</td><td>输入的结束</td></tr></tbody></table><p>###量词</p><table><thead><tr><th>贪婪模式</th><th style="text-align:center">饥饿模式</th><th style="text-align:right">独占模式</th><th style="text-align:right"></th></tr></thead><tbody><tr><td>X?</td><td style="text-align:center">X??</td><td style="text-align:right">X?+</td><td style="text-align:right">匹配0或1次</td></tr><tr><td>X*</td><td style="text-align:center">X*?</td><td style="text-align:right">X*+</td><td style="text-align:right">匹配0或多次</td></tr><tr><td>X+</td><td style="text-align:center">X+?</td><td style="text-align:right">X++</td><td style="text-align:right">匹配1或多次</td></tr><tr><td>X{n}</td><td style="text-align:center">X{n}?</td><td style="text-align:right">X{n}+</td><td style="text-align:right">匹配n次</td></tr><tr><td>X{n,}</td><td style="text-align:center">X{n,}?</td><td style="text-align:right">X{n,}+</td><td style="text-align:right">匹配最少n次</td></tr><tr><td>X{n, m}</td><td style="text-align:center">X{n, m}?</td><td style="text-align:right">X{n, m}+</td><td style="text-align:right">匹配最少n次，最多m次</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么要使用正则表达式？&lt;/strong&gt;&lt;br&gt;节省代码，爱护队友。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在正式介绍之前，先贴一段使用了正则表达式的代码吧。&lt;br&gt;&lt;figure class=&quot;highlight plain
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GlobalDialog框架使用教程</title>
    <link href="http://yoursite.com/2017/06/10/GlobalDialog%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/06/10/GlobalDialog框架使用教程/</id>
    <published>2017-06-10T00:37:54.000Z</published>
    <updated>2017-12-29T11:35:38.162Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2109293-cdafa26ebd9bd991.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请勿模仿。"><br>GlobalDialog是由<a href="http://italkyou.bmob.site" target="_blank" rel="noopener">ITalk应用</a>开源的一款全局对话框库。相比于Android原生对话框的繁琐配置，GlobalDialog的优势在于能够快速实现<strong>全局对话框</strong>的功能（通知账号下线、通知账号异常等）。进一步了解，请访问笔者的<a href="https://github.com/tangxianming/global-dialog" target="_blank" rel="noopener">Github</a>。<br><a id="more"></a> </p><p>#集成方法<br>在Module的build.gradle文件中添加如下依赖即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.txm.topcodes.globaldialog:globaldialog:0.1.6&apos;</span><br></pre></td></tr></table></figure></p><p>#调用方式<br>常规方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new GlobalDialog.Builder()</span><br><span class="line">.setContext(context) </span><br><span class="line">.setDescription(&quot;hello world&quot;) //弹出框的提示信息。</span><br><span class="line">.setStyle(GlobalDialog.Style.SingleAlert) //弹窗的样式。有DoubleAlert、SingleAlert两种，默认为后者。</span><br><span class="line">.setForce(ture) //设置弹框销毁的策略。默认为true。</span><br><span class="line">.setDialogClickListener(new OnDialogClickListener() &#123; //设置回调，也可以不设置。</span><br><span class="line">@Override</span><br><span class="line">public void onSure() &#123;</span><br><span class="line">super.onSure();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).build().show();</span><br></pre></td></tr></table></figure></p><p>精简方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new GlobalDialog.Builder()</span><br><span class="line">.setContext(context) </span><br><span class="line">.setDescription(&quot;hello world&quot;) </span><br><span class="line">.build().show();</span><br></pre></td></tr></table></figure></p><p>#FAQ</p><hr><p><strong>我发现GlobalDialog还存在BUG？</strong><br>GlobalDialog是一个完全开源的框架，如果您在使用过程中发现问题，欢迎在笔者的GitHub创建一个<a href="https://github.com/tangxianming/global-dialog/issues" target="_blank" rel="noopener">Issue</a>。</p><p><strong>我是Eclipse用户，可以使用GlobalDialog么？</strong><br>不可以。</p><p><strong>我在Android studio中链接GlobalDialog库失败了？</strong><br>确保您的工程使用的远程仓库为jcenter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">jcenter()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2109293-cdafa26ebd9bd991.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;请勿模仿。&quot;&gt;&lt;br&gt;GlobalDialog是由&lt;a href=&quot;http://italkyou.bmob.site&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ITalk应用&lt;/a&gt;开源的一款全局对话框库。相比于Android原生对话框的繁琐配置，GlobalDialog的优势在于能够快速实现&lt;strong&gt;全局对话框&lt;/strong&gt;的功能（通知账号下线、通知账号异常等）。进一步了解，请访问笔者的&lt;a href=&quot;https://github.com/tangxianming/global-dialog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="我的Android框架" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84Android%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="View" scheme="http://yoursite.com/tags/View/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>AutoCache高性能缓存框架使用教程</title>
    <link href="http://yoursite.com/2016/10/23/AutoCache%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/10/23/AutoCache高性能缓存框架使用教程/</id>
    <published>2016-10-22T23:00:20.000Z</published>
    <updated>2017-12-29T11:36:43.187Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2109293-d934024b5cb541e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一只正在设计AutoCache的攻城狮"></p><blockquote><p><strong>读者可能会问在下：</strong></p><ol><li>为什么要使用AutoCache？<br>简洁、高性能。</li><li>现在市面上有那么多缓存的框架，像piccso等都很优秀，那笔者是不是在重复造车？<br>AutoCache是为那些追求轻量级缓存的APP而生的。目的是让开发者既能快速完成APP缓存功能的开发，又能保证上线后性能的稳定。</li></ol></blockquote><a id="more"></a> <p><a href="https://github.com/tangxianming/auto-cache" target="_blank" rel="noopener">AutoCache</a> 能够让你高效地编写app缓存代码 ，保证你的数据流被安全、准确地存储到SDcard私有目录。参考下列核心调用代码来开始你的 AutoCache 之旅：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.MediaCache.getInstance(context).asyncCache(&quot;url&quot;, new CallBack() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onStart() &#123;</span><br><span class="line">//Run in UI thread.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void save2DataBase(String cachePath) &#123;</span><br><span class="line">//Run in io thread,</span><br><span class="line">//You can sava the  cachPath to database or sharepreference.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onSuccess(byte[] bytes) &#123;</span><br><span class="line">//Run in UI thread.</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onErro(Throwable e) &#123;</span><br><span class="line">//Run in UI thread.</span><br><span class="line">&#125;</span><br><span class="line">&#125;, FILE_TYPE, &quot;filename&quot;);</span><br></pre></td></tr></table></figure></p><p>#集成方法<br>在Module的build.gradle文件中添加如下依赖即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.txm.topcodes.autocache:autocache:0.1.2&apos;</span><br></pre></td></tr></table></figure></p><p>#调用方式<br>为方便开发者，AutoCache提供统一调用入口，调用方式十分简洁。下面先给大家看一张思维导图，该图罗列了框架的主体功能及其构成。</p><p><img src="http://upload-images.jianshu.io/upload_images/2109293-8b44b4cfd957789e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AutoCache功能结构图"></p><p>从结构图不难看出，<strong>AutoCache类</strong>就是调用框架的入口类。当我们需要从本地获取流文件时，调用方式是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.Media.get…();</span><br></pre></td></tr></table></figure></p><p>缓存网络文件时，调用方式是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.MediaCache.getInstance(context).asyncCache();</span><br></pre></td></tr></table></figure></p><p>缓存内存文件时，调用方式是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.MediaCache.getInstance(context).cache();</span><br></pre></td></tr></table></figure></p><p>当需要指定文件文件类型时，使用方式是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.DIRECTORY_PICTURES</span><br></pre></td></tr></table></figure></p><p>「如需获取详细信息，请在 <a href="https://github.com/tangxianming/auto-cache" target="_blank" rel="noopener">GitHub 的 auto-cache页面</a>查看源代码.」</p><p>#文件类型<br>AutoCache支持缓存以下泛媒体类型：Podcasts,Pictures,Movies,Music,Documents,Download。<em>其中Download比较特殊，用它可以指定未知的文件类型。</em></p><p>#使用场景<br>当我们的APP从网络获取文件流时，往往会有这样的需求「也可能是其中之一」：</p><ol><li>网络请求时，要可以自动将文件保存到APP本地。</li><li>网络请求时，将网络图片的本地路径存储到SQLite或其它数据持久化中，以方便逻辑处理。</li><li>网络请求时，直接使用从网络获取到文件流。</li><li>网络请求时，方便添加进度条功能。</li><li>网络请求时，全局捕获异常。</li><li>本次请求之后，根据文件名、文件类型从本地获取文件流。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/2109293-7880687895d6e259.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>对于需求1。</strong>AutoCache完全是在后台<em>IO线程</em>中完成的，不需要调用者主动去操作。</p><blockquote><p>IO线程：I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io线程比Thread线程更有效率。</p></blockquote><p><strong>对于需求2。</strong>save2DataBase(String cachePath)回调方法自动就被指定在IO线程中运行。「所以，save2DataBase既是一个非阻塞的方法，又具备IO线程的高效性。」</p><p><strong>对于需求3。</strong>onSuccess(byte[] bytes)回调方法被指定自动运行在UI线程中。</p><p><strong>对于需求4。</strong>AutoCache提供了onstart()回调方法作为调用开始的标志，onSuccess(byte[] bytes)或onErro(Throwable e)作为调用结束点。</p><p><strong>对于需求5。</strong>全局捕获异常指的是：onErro(Throwable e)不仅可以捕获网络异常、本地缓存媒体时发生的异常，而且还可以捕获发生在onStart、save2DataBase、onSuccess中的异常。</p><p><strong>对于需求6。</strong>AutoCache.Media类提供了4种同步方式来获取本地的媒体流。</p><p>#最佳实践</p><hr><p>####防止OOM<br>AutoCache.Media类中提供了getSoftBmp(~)，getWeakBmp(~)，getBmp(~)，getFile(~)四种方式来获取流。如果是图片文件，笔者建议使用前两种方式，具体可参考<a href="http://www.cnblogs.com/dolphin0520/p/3784171.html" target="_blank" rel="noopener">善于利用软引用和弱引用。</a></p><p>####定制回调方法<br>AutoCache框架提供了CallBackAdapter接口用于替换CallBack接口。可以通过它实现自由定制自己需要的回调方法。「这样是为了代码看上去简洁。」<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.MediaCache.getInstance(context).asyncCache(&quot;url&quot;, new CallBackAdapter() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void save2DataBase(String cachePath) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void onSuccess(byte[] bytes) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//you can add other callback function here.</span><br><span class="line">&#125;,FILE_TYPE,&quot;filename&quot;);</span><br></pre></td></tr></table></figure></p><p>#FAQ</p><hr><p><strong>我发现AutoCache还存在BUG？</strong><br>AutoCache是一个完全开源的框架，如果您在使用过程中发现问题，请在<a href="https://github.com/tangxianming/auto-cache/issues" target="_blank" rel="noopener">GitHub</a>创建一个问题。</p><p><strong>我是Eclipse用户，可以使用AutoCache么？</strong><br>不可以。</p><p><strong>AutoCache用到了哪些第三方框架？</strong><br>是的。AutoCache是在RXjava+Okhttp基础之上封装的一个轻量级缓存框架。</p><p><strong>AutoCache提供缓存文件路径到SQLite数据库的方法了吗？</strong><br>没有。AutoCache缓存的重心是将流文件缓存到本地目录。如果需要将文件路径缓存到SQLite或其他持久化数据层中，开发者需要自行在save2DataBase(cachePath)回调方法中实现逻辑。</p><p><strong>我在android studio中链接AutoCache库失败了？</strong><br>确保您的工程使用的远程仓库为jcenter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">jcenter()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>————–我是一条萌萌哒的分割线，表示教程结束—————-</p><p><img src="http://upload-images.jianshu.io/upload_images/2109293-f58c2a709b60c8f3.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2109293-d934024b5cb541e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;一只正在设计AutoCache的攻城狮&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;读者可能会问在下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么要使用AutoCache？&lt;br&gt;简洁、高性能。&lt;/li&gt;
&lt;li&gt;现在市面上有那么多缓存的框架，像piccso等都很优秀，那笔者是不是在重复造车？&lt;br&gt;AutoCache是为那些追求轻量级缓存的APP而生的。目的是让开发者既能快速完成APP缓存功能的开发，又能保证上线后性能的稳定。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的Android框架" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84Android%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Cache" scheme="http://yoursite.com/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio NDK开发全攻略</title>
    <link href="http://yoursite.com/2016/08/14/NDK%E5%BC%80%E5%8F%91%E5%85%A8%E6%94%BB%E7%95%A5/"/>
    <id>http://yoursite.com/2016/08/14/NDK开发全攻略/</id>
    <published>2016-08-14T07:56:00.000Z</published>
    <updated>2017-12-29T12:15:16.462Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2109293-2f486474306a0eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><strong>读完本章，你可以：</strong></p><ul><li><em>在Android Studio上轻松搭建NDK开发环境。</em></li><li><em>掌握最快捷的JNI开发方式。</em></li><li><em>掌握使用.so文件开发Android程序的技巧。</em></li></ul></blockquote><a id="more"></a> <h3 id="一、-NDK环境搭建"><a href="#一、-NDK环境搭建" class="headerlink" title="一、 NDK环境搭建"></a>一、 NDK环境搭建</h3><ol><li>开发工具准备<br>要进行Android NDK开发，首先要下载Android NDK开发工具。可以在AndroidStudio上面下载，也可以自己下载好了，然后将NDK的路径设置为自己下载的Android NDK开发工具的路径。<br><img src="http://upload-images.jianshu.io/upload_images/2109293-935b1d5e7af0abb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android Studio中设置NDK路径"></li><li>Gradle的相关配置<br>1) 我们来配置Project的build.gradle。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*gradle插件不支持NDK，我们需要使用gradle-experimental插件。 */</span><br><span class="line">dependencies &#123;</span><br><span class="line">classpath &apos;com.android.tools.build:gradle-experimental:0.7.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2) 我们来配置Module的build.gradle。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.model.application&apos;</span><br><span class="line">model &#123;</span><br><span class="line">android &#123;</span><br><span class="line">compileSdkVersion = 23</span><br><span class="line">buildToolsVersion = &quot;23.0.2&quot;</span><br><span class="line">defaultConfig &#123;</span><br><span class="line">applicationId &quot;com.lavor.ndklearning&quot;</span><br><span class="line">minSdkVersion.apiLevel 15</span><br><span class="line">targetSdkVersion.apiLevel 23</span><br><span class="line">versionCode 4</span><br><span class="line">versionName &quot;1.0.1&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">android.ndk &#123;</span><br><span class="line">moduleName &quot;lavor&quot;</span><br><span class="line">ldLibs.addAll([&apos;log&apos;])</span><br><span class="line">cppFlags.add(&quot;-std=c++11&quot;)</span><br><span class="line">cppFlags.add(&quot;-fexceptions&quot;)</span><br><span class="line">platformVersion 15</span><br><span class="line">stl &apos;gnustl_shared&apos;</span><br><span class="line">&#125;</span><br><span class="line">android.buildTypes &#123;</span><br><span class="line">release &#123;</span><br><span class="line">minifyEnabled = false</span><br><span class="line">proguardFiles.add(file(&quot;proguard-rules.txt&quot;))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">compile &apos;com.android.support:appcompat-v7:23.1.1&apos;</span><br><span class="line">compile &apos;com.android.support:recyclerview-v7:23.1.1&apos;</span><br><span class="line">compile &apos;com.android.support:design:23.1.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>小提示</strong> </p><ul><li>首先，在apply的时候我们引入的插件名称由’com.android.application’变成了’com.android.model.application’。</li><li>其次，在原来android的外层加入了一个model层次。</li><li>再次，原来在android的里面的块，除了defaultConfig外，全部移除android块放入model块中与android并列，并且前面的名字加上android.。</li><li>然后，compileSdkVersion 23与 buildToolsVersion “23.0.2”改成 compileSdkVersion = 23和 buildToolsVersion = “23.0.2”，中间加上了=。</li><li>其次，添加上android.ndk块，块中的moduleName表示C/C++代码打包成so文件的名字。</li><li>再次，android.buildTypes块中的proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’改成proguardFiles.add(file(“proguard-rules.txt”))。</li><li>最后，注意dependencies块依然在最外层，它不在model块中。</li></ul></blockquote><h3 id="二、-使用NDK开发第一个JNI程序"><a href="#二、-使用NDK开发第一个JNI程序" class="headerlink" title="二、 使用NDK开发第一个JNI程序"></a>二、 使用NDK开发第一个JNI程序</h3><ol><li>在Android程序中新建一个包含native（本地）方法的NDKTest类。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.lavor.ndklearning;</span><br><span class="line">public class NDKTest &#123;</span><br><span class="line">static &#123;</span><br><span class="line">//加载.so库文件</span><br><span class="line">System.loadLibrary(&quot;lavor&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public native String getString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>小知识</strong> </p><ul><li>程序中static{}称为静态代码块，它在类初始化的时候执行。<a href="http://www.2cto.com/kf/201204/127350.html" target="_blank" rel="noopener">不懂请猛击&gt;&gt;</a></li></ul><ol><li>将鼠标移动到方法名getString上，然后按下Alt+Enter快捷键，弹出一些解决的方法建议，点击第一个Create Function…<br><img src="http://upload-images.jianshu.io/upload_images/2109293-b72c498ba03487b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自动生成.c文件"></li><li>此时会自动建立一个与java目录同级的jni目录，在jni目录自动建立一个c文件，在c文件中实现了刚才的native方法。<br><img src="http://upload-images.jianshu.io/upload_images/2109293-45dae37602388281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=".c文件"></li><li>然后，稍稍修改一下.c文件中实现的native方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_lavor_ndklearning_NDKTest_getString(JNIEnv *env, jobject instance) &#123;</span><br><span class="line">// TODO</span><br><span class="line">return (*env)-&gt;NewStringUTF(env, &quot;AndroidStudio NDK开发最佳入门实践&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>补充说明</strong> </p><ul><li>仔细观察可以看到c文件的方法名是遵循“Java_包名类名本地方法名”来组织的（了解到这些后，我们就可以脱离编译器的帮助，直接去写.c文件啦）。</li></ul><ol><li>最后在Android程序中调用JNI接口。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">private android.widget.TextView text;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">this.text = (TextView) findViewById(R.id.text);</span><br><span class="line">NDKTest NDK=new NDKTest();</span><br><span class="line">text.setText(NDK.getString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>运行程序后界面如下：<br><img src="http://upload-images.jianshu.io/upload_images/2109293-adee2cd57d50fdf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p><blockquote><p><strong>深度总结</strong> </p><ul><li>讲道理，我们在正式开发时，不会像这样子去开发。因为这样的话就会把我们的c代码也暴露了出来。这明显与JNI的安全保密机制相违背，所以，正式开发的时候，我们会使用.so文件进行全保密式的开发。</li></ul></blockquote><h3 id="三、-使用-so文件开发Android程序"><a href="#三、-使用-so文件开发Android程序" class="headerlink" title="三、 使用.so文件开发Android程序"></a>三、 使用.so文件开发Android程序</h3><p>不知道大家有没有记得<a href="http://www.jianshu.com/p/cd8893549238" target="_blank" rel="noopener">上一章</a>说过，使用JNI有个好处就是安全性高，JNI部分的代码很难被反编译。这其实是要归功于.so文件。下图为.so文件的生成位置。<br><img src="http://upload-images.jianshu.io/upload_images/2109293-bb1e5e5126c27518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android Studio中生成的.so文件位置"><br>具体的使用步骤是怎样的呢？</p><ol><li>新建一个Android工程，命名为：AndroidApplication。（工程名、包名、组织名任意）<br><img src="http://upload-images.jianshu.io/upload_images/2109293-216c5583d760f537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个随意的Android工程"></li><li>导入.so文件至app/libs中。<br><img src="http://upload-images.jianshu.io/upload_images/2109293-c5b1fcba143015f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入.so文件至Android工程"></li><li><p>为了能够调用libs文件夹下的.so资源，需在app的build.gradle的android节点下设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sourceSets&#123;</span><br><span class="line">main&#123;</span><br><span class="line">jniLibs.srcDirs = [&apos;libs&apos;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建相关类结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.lavor.ndklearning;</span><br><span class="line">public class NDKTest &#123;</span><br><span class="line">static &#123;</span><br><span class="line">//加载.so库文件</span><br><span class="line">System.loadLibrary(&quot;lavor&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public native String getString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>补充说明</strong> </p><ul><li>Android端声明native code的代码需要严格按照JNI接口来组织。（也就是说，包名、类名都要和.so文件中JNI名称一致）<a href="http://billhoo.blog.51cto.com/2337751/1125559" target="_blank" rel="noopener">不懂就点击这里吧&gt;&gt;</a></li></ul><ol><li>函数调用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DemoActivity extends AppCompatActivity &#123;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_demo);</span><br><span class="line">Log.d(&quot;NDK&quot;,new NDKTest().getString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>运行结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/2109293-9974de0ded907081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p><blockquote><p> 注意啦！<em>此文并非原创，算是对一波优秀文章的总结吧。笔者希望通过这种方式激励自己学习，也期待可以帮到正在学习NDK的你。欢迎指出本文的BUG，共勉！！！！！</em></p></blockquote><hr><p><strong>参考资料</strong></p><ol><li><a href="https://github.com/lavor-zl/NDKLearning" target="_blank" rel="noopener">AndroidStudio NDK开发最佳入门实践</a></li><li><a href="http://billhoo.blog.51cto.com/2337751/1125559" target="_blank" rel="noopener">如何在Android中使用编译好的.so库</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2109293-2f486474306a0eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;读完本章，你可以：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;在Android Studio上轻松搭建NDK开发环境。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;掌握最快捷的JNI开发方式。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;掌握使用.so文件开发Android程序的技巧。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NDK" scheme="http://yoursite.com/categories/NDK/"/>
    
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
      <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>七夕前，我认识了NDK</title>
    <link href="http://yoursite.com/2016/08/06/%E4%B8%83%E5%A4%95%E5%89%8D%EF%BC%8C%E6%88%91%E8%AE%A4%E8%AF%86%E4%BA%86NDK/"/>
    <id>http://yoursite.com/2016/08/06/七夕前，我认识了NDK/</id>
    <published>2016-08-06T10:57:00.000Z</published>
    <updated>2017-12-29T12:19:39.103Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2109293-3952aad8fb71012c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NDK妹子生活照"></p><blockquote><p><strong>看前必读</strong></p><ul><li><em>读完本章，你可以掌握NDK、JNI的概念及其开发流程。</em></li><li><em>阅读时，不必纠结于读不懂的代码结构，后面的教程 都会讲到的。</em></li></ul></blockquote><a id="more"></a> <h3 id="一、为何要学习NDK？"><a href="#一、为何要学习NDK？" class="headerlink" title="一、为何要学习NDK？"></a>一、为何要学习NDK？</h3><ol><li>代码的保护。Android APK的Java层代码很容易被反编译，但C/C++库反编译难度较大。</li><li>可以方便地使用现存的开源库。大部分现存的开源库都是用C/C++代码编写的。</li><li>提高程序的执行效率。将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。</li><li>便于移植。用C/C++写的库可以方便在其他的嵌入式平台上再次使用。</li></ol><h3 id="二、先知道什么是JNI"><a href="#二、先知道什么是JNI" class="headerlink" title="二、先知道什么是JNI"></a>二、先知道什么是JNI</h3><p>JNI（Java Native Interface）是Java语言提供的Java和C/C++互相沟通的机制，可以实现：</p><ol><li>java调用本地的C/C++代码</li><li>本地的C/C++代码也可以调用java代码</li></ol><h3 id="三、开发JNI程序的简化流程"><a href="#三、开发JNI程序的简化流程" class="headerlink" title="三、开发JNI程序的简化流程"></a>三、开发JNI程序的简化流程</h3><ol><li><p>编写Java Code，如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 加载lavor本地共享库到内存中</span><br><span class="line">*/</span><br><span class="line">static &#123;</span><br><span class="line">System.loadLibrary(&quot;lavor&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 定义本地方法对应的Java方法</span><br><span class="line">*</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public native String getString();</span><br></pre></td></tr></table></figure></li><li><p>编写C/C++，如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_lavor_ndklearning_MainActivity_getString(JNIEnv *env, jobject instance) &#123;</span><br><span class="line"></span><br><span class="line">return (*env)-&gt;NewStringUTF(env, &quot;这是我的c程序代码&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译 C/C++ Code，成功并得到本地共享库。</p><blockquote><p><strong>小知识</strong> </p><ul><li>本地共享库是Linux下的叫法，文件扩展名是.so，windows下叫动态链接库，文件扩展名是.dll。</li><li><a name="001" id="001">C /C++的跨平台性是以牺牲编译时间以及编译难度为代价的。（<em>这里的编译难度是指为适应不同平台而做的编译过程的调整）</em></a></li><li>Java的一次编译到处运行，是以牺牲运行效率为代价的。</li></ul></blockquote></li><li><p>编译并打包Java。<br>把本地共享库<em>（.so文件）</em>放置到Java项目的指定目录，一般是libs文件夹。然后编译Java代码即可打包运行。</p><blockquote><p><strong>小知识</strong></p><ul><li>Android项目中，.so文件存放地址为libs/armeabi。<em>(armeabi是对应的平台，下一章将会详细介绍)</em></li></ul></blockquote></li></ol><h3 id="四、NDK概述"><a href="#四、NDK概述" class="headerlink" title="四、NDK概述"></a>四、NDK概述</h3><p>NDK<em>(Native  Development Kit)</em>是Google为Android进行本地开发而放出的一个本地开发工具， 包括Android的Native API、公共库以及编译工具。其实说白就是Google为方便Android程序猿开发JNI程序，而提供的便捷工具。</p><blockquote><p><strong>补充两点</strong></p><ul><li>NDK处在JNI开发流程中的编译环节<em>（第三、四步）</em>。针对不同的平台，NDK可以全自动编译出对应可运行的本地共享库，并可将对应的.so文件和应用程序一起打包成apk发布。<em>（这时，跨平台编译C/C++的难度指数降为0。<a href="#001">不明白请猛击</a>）</em></li><li>NDK需要Android 1.5版本以上的支持。</li></ul></blockquote><h3 id="五、开发NDK程序的流程"><a href="#五、开发NDK程序的流程" class="headerlink" title="五、开发NDK程序的流程"></a>五、开发NDK程序的流程</h3><p>这个开发流程大致与JNI的开发流程差不多：</p><ol><li>SDK开发。编写Java代码，调用各种Android的API实现功能，编写含有native关键字的代码开始JNI。</li><li>JNI开发。按照 JNI编码规范，编写与Java交互的本地代码<em>（一般就是数据类型的转换，把 C/C++的数据类转换成Java能识别的，或反过来）</em>。</li><li>C/C++开发。编码实现业务逻辑，或调用NDK提供的本地API或库，完成Android平台上特定功能的开发、封装。</li><li>NDK编译，编写.mk文件，编译调试，最后修改.mk文件，针对特定的平台（ARM/x86）做编译结果的优化。</li><li>最后就是SDK编译、打包，上真机调试了…</li></ol><blockquote><p> 注意啦！<em>此文并非原创，算是对一波优秀文章的总结吧。笔者希望通过这种方式激励自己学习，也期待可以帮到正在学习NDK的你。欢迎指出本文的BUG，共勉！！！！！</em></p></blockquote><hr><p><strong>参考资料</strong><br><a href="http://www.cnblogs.com/devinzhang/archive/2012/02/29/2373729.html" target="_blank" rel="noopener">Android之NDK开发</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2109293-3952aad8fb71012c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;NDK妹子生活照&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;看前必读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;读完本章，你可以掌握NDK、JNI的概念及其开发流程。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;阅读时，不必纠结于读不懂的代码结构，后面的教程 都会讲到的。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NDK" scheme="http://yoursite.com/categories/NDK/"/>
    
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
      <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
</feed>
