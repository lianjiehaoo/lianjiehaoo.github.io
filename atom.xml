<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唐先明de博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-19T02:56:29.414Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>TXM</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解读 Hander 机制</title>
    <link href="http://yoursite.com/2020/07/16/%E8%A7%A3%E8%AF%BBHander%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/07/16/解读Hander机制/</id>
    <published>2020-07-16T07:47:38.000Z</published>
    <updated>2020-07-19T02:56:29.414Z</updated>
    
    <content type="html"><![CDATA[<p>Handler机制是Android中相当经典的异步消息机制，本篇将从实用的角度来分析它。<br><a id="more"></a></p><p>Handler中有几个重要的类，由他们共同完成了这套消息机制的搭建，分别是：Handler、Looper、Message、MessageQueue。</p><p>下面来看一个使用案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    lateinit var handler: Handler</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        Thread &#123;</span><br><span class="line">            Looper.prepare()</span><br><span class="line">            handler = object : Handler() &#123;</span><br><span class="line">                override fun handleMessage(msg: Message) &#123;</span><br><span class="line">                    super.handleMessage(msg)</span><br><span class="line">                    Log.d(&quot;TAG&quot;, msg.what.toString())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Looper.loop()</span><br><span class="line">            Log.d(&quot;TAG&quot;, &quot;Thread End.&quot;)</span><br><span class="line">        &#125;.start()</span><br><span class="line">        </span><br><span class="line">        btnSend.setOnClickListener &#123;</span><br><span class="line">            val message = Message.obtain(handler, 1)</span><br><span class="line">            handler.sendMessage(message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，我们通过 <code>Log.d(&quot;TAG&quot;, msg.what.toString())</code> 成功打印了从主线程传递过来的数据。同时， <code>Log.d(&quot;TAG&quot;, &quot;Thread End.&quot;)</code> 一直都没有执行。</p><h3 id="问题1：为什么运行在子线程的Handler可以拿到主线程中发送的数据？"><a href="#问题1：为什么运行在子线程的Handler可以拿到主线程中发送的数据？" class="headerlink" title="问题1：为什么运行在子线程的Handler可以拿到主线程中发送的数据？"></a>问题1：为什么运行在子线程的Handler可以拿到主线程中发送的数据？</h3><p>首先，我们看下Looper.prepare里面做了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void prepare() &#123;</span><br><span class="line">    prepare(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进入<code>prepare</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>if 语句保证了每个线程只能存在一个Looper，sThreadLocal 在 Looper 中的定义如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure></p><p>可以看到 sThreadLocal 是一个静态变量，<code>sThreadLocal.set(new Looper(quitAllowed));</code>这行的作用是让 sThreadLocal 保存当前线程所对应的 Looper 。</p><p>回到 MainActivity ，之后我们重写了 Handler 的 handleMessage 方法，在方法中执行打印操作，那么 handleMessage 方法是什么时候被调用的呢？这个疑问先放着，我们之后再拐回来。</p><p>我们来看看 <code>Looper.loop()</code> 的 loop 方法实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">       final Looper me = myLooper();</span><br><span class="line"></span><br><span class="line">       if (me == null) &#123;</span><br><span class="line">           throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final MessageQueue queue = me.mQueue;// mQueue 是什么赋值的？这个等下再分析，现在把它看成一个 MessageQueue 队列就行。</span><br><span class="line"></span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           Message msg = queue.next(); // 这里会阻塞，直到 queue 中有消息加入。</span><br><span class="line">           if (msg == null) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           try &#123;</span><br><span class="line">               msg.target.dispatchMessage(msg); //发送消息到 handler 中。</span><br><span class="line">             </span><br><span class="line">           &#125; catch (Exception exception) &#123;</span><br><span class="line"></span><br><span class="line">           &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           msg.recycleUnchecked(); //回收消息</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这里只保留了主干代码。首先，拿到当前线程的 Looper 对象，不存在则抛出异常。然后，从 Looper 拿到它对应的 MessageQueue 对象，之后轮询 MessageQueue 的 next 方法，该方法是一个阻塞方法。拿到消息后通过 <code>msg.target.dispatchMessage(msg)</code> 将消息发送到 handler。最后释放消息。</p><p>下面我们看下 dispatchMessage 对消息是怎么处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(@NonNull Message msg) &#123;</span><br><span class="line">    if (msg.callback != null) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback != null) &#123;</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先判断 msg.callback 是否为空，该例的场景为null，所以就到了 else 代码块中 ，由于这里 mCallback 为空，该消息最终传到了位于 Looper 线程中的 Handler 对象的 handleMessage 回调方法中。</p><p>那么这个消息是怎么被 add 到 Looper 所持有的 MessageQueue 上的呢？答案就在 <code>handler.sendMessage(message)</code> 调用过程中。该过程经过层层调用，最终来到了 MessageQueue 的 enqueueMessage 方法中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">       if (msg.target == null) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (msg.isInUse()) &#123;</span><br><span class="line">           throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           if (mQuitting) &#123;</span><br><span class="line">               IllegalStateException e = new IllegalStateException(</span><br><span class="line">                       msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">               Log.w(TAG, e.getMessage(), e);</span><br><span class="line">               msg.recycle();</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           msg.markInUse();</span><br><span class="line">           msg.when = when;</span><br><span class="line">           Message p = mMessages;</span><br><span class="line">           boolean needWake;</span><br><span class="line">           if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">               msg.next = p;</span><br><span class="line">               mMessages = msg;</span><br><span class="line">               needWake = mBlocked;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">               Message prev;</span><br><span class="line">               for (;;) &#123;</span><br><span class="line">                   prev = p;</span><br><span class="line">                   p = p.next;</span><br><span class="line">                   if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                       needWake = false;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               msg.next = p; // invariant: p == prev.next</span><br><span class="line">               prev.next = msg;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">           if (needWake) &#123;</span><br><span class="line">               nativeWake(mPtr);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这里保证了队列的结构，即按时间排列和先进先出原则，最后依据 needWake 的值决定是否唤醒队列。</p><p><strong>以上就是对于问题的回答。</strong></p><p>回答完问题，下面我们来分析下 next 方法实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">final long ptr = mPtr;</span><br><span class="line">        if (ptr == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int pendingIdleHandlerCount = -1;</span><br><span class="line">        int nextPollTimeoutMillis = 0;</span><br><span class="line">        </span><br><span class="line">        for (;;) &#123;</span><br><span class="line"></span><br><span class="line">if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">//步骤1</span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis); // might block</span><br><span class="line"></span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                final long now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = null;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">//步骤2</span><br><span class="line">                if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">//步骤3</span><br><span class="line">                if (msg != null) &#123;</span><br><span class="line">                    if (now &lt; msg.when) &#123;</span><br><span class="line">                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mBlocked = false;</span><br><span class="line">                        if (prevMsg != null) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = null;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        return msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    nextPollTimeoutMillis = -1;</span><br><span class="line">                &#125;</span><br><span class="line">//步骤4</span><br><span class="line">                if (mQuitting) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">//步骤5</span><br><span class="line">                if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                    // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                    mBlocked = true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = null; </span><br><span class="line">                boolean keep = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    keep = idler.queueIdle();</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!keep) &#123;</span><br><span class="line">                    synchronized (this) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pendingIdleHandlerCount = 0;</span><br><span class="line"></span><br><span class="line">            nextPollTimeoutMillis = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>步骤 1</strong><br><code>nativePollOnce(ptr, nextPollTimeoutMillis);</code> 是一个 Native 方法，当代码运行于此时，则阻塞，直到有逻辑调用 <code>nativeWake(ptr)</code>方法唤醒，类似于 java 中的 IO 机制。</p><p><strong>步骤 2</strong><br>msg.target==null时，表示该消息是一个屏障消息，于是之后找到队列中的第一个异步消息。</p><p><strong>步骤 3</strong><br>消息不为空并且 when 不超过当前时间点，则返回该消息，否则，则继续进行到步骤 4。</p><p><strong>步骤4</strong><br>mQuitting 变量是标识是否退出 loop 循环的，调用 <code>quit(boolean safe)</code> 方法会设置其值为 true 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void quit(boolean safe) &#123;</span><br><span class="line">        if (!mQuitAllowed) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            mQuitting = true;</span><br><span class="line"></span><br><span class="line">            if (safe) &#123;</span><br><span class="line">                removeAllFutureMessagesLocked();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                removeAllMessagesLocked();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // We can assume mPtr != 0 because mQuitting was previously false.</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>方法最后调用<code>nativeWake</code>通知<code>next</code>方法往下执行。</p><p><strong>步骤5</strong><br>判断是否有闲时消息，有则处理之。所以，闲时消息在CPU空闲的时候会调用，用于页面启动时加载滞后数据，加快页面启动速度。用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val messageQueue = Looper.myQueue()</span><br><span class="line">messageQueue.addIdleHandler(MessageQueue.IdleHandler &#123;</span><br><span class="line">    Log.d(&quot;hhhh&quot;, &quot;thread=$&#123;Thread.currentThread().name&#125;,idle&quot;)</span><br><span class="line">    false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>返回 false 表示该闲时消息在每次到达空闲时都会执行一次，true 表示执行一次后抛弃就该消息。</p><h3 id="问题2：-Message-obtain-方法是用来干什么的？"><a href="#问题2：-Message-obtain-方法是用来干什么的？" class="headerlink" title="问题2： Message.obtain()方法是用来干什么的？"></a>问题2： Message.obtain()方法是用来干什么的？</h3><p>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//android.os.Message</span><br><span class="line"></span><br><span class="line">public static final Object sPoolSync = new Object();</span><br><span class="line"></span><br><span class="line">   private static Message sPool;</span><br><span class="line">   private static int sPoolSize = 0;</span><br><span class="line"></span><br><span class="line">   private static final int MAX_POOL_SIZE = 50;</span><br><span class="line"></span><br><span class="line">   public static Message obtain() &#123;</span><br><span class="line">       synchronized (sPoolSync) &#123;</span><br><span class="line">           if (sPool != null) &#123;</span><br><span class="line">               Message m = sPool;</span><br><span class="line">               sPool = m.next;</span><br><span class="line">               m.next = null;</span><br><span class="line">               m.flags = 0; // clear in-use flag</span><br><span class="line">               sPoolSize--;</span><br><span class="line">               return m;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return new Message();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>sPool 就是缓冲池的头节点，当 sPool 不为 null 时，复用该 Message 即可。当 sPool 为 null 时，则新建 Message 。这样以达到节省内存空间的目的。</p><p>缓冲池里的 Message 一定是可复用的，也就是使用完的 Message 。那么我们在哪里去将使用完的 Message 放入缓冲池呢？答案就是 <code>recycleUnchecked</code> 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//android.os.Message</span><br><span class="line"></span><br><span class="line">   void recycleUnchecked() &#123;</span><br><span class="line">       // Mark the message as in use while it remains in the recycled object pool.</span><br><span class="line">       // Clear out all other details.</span><br><span class="line">       flags = FLAG_IN_USE;</span><br><span class="line">       what = 0;</span><br><span class="line">       arg1 = 0;</span><br><span class="line">       arg2 = 0;</span><br><span class="line">       obj = null;</span><br><span class="line">       replyTo = null;</span><br><span class="line">       sendingUid = UID_NONE;</span><br><span class="line">       workSourceUid = UID_NONE;</span><br><span class="line">       when = 0;</span><br><span class="line">       target = null;</span><br><span class="line">       callback = null;</span><br><span class="line">       data = null;</span><br><span class="line"></span><br><span class="line">       synchronized (sPoolSync) &#123;</span><br><span class="line">           if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">               next = sPool;</span><br><span class="line">               sPool = this;</span><br><span class="line">               sPoolSize++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>当 sPoolSize 小于 MAX_POOL_SIZE 时，将已使用完的 Message 作为缓冲池的头指针，同时缓冲池其它的 Message 往后移。</p><h3 id="问题3-Handler消息创建和处理在同一个线程时是同步还是异步的？"><a href="#问题3-Handler消息创建和处理在同一个线程时是同步还是异步的？" class="headerlink" title="问题3:Handler消息创建和处理在同一个线程时是同步还是异步的？"></a>问题3:Handler消息创建和处理在同一个线程时是同步还是异步的？</h3><p>请看下面的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Main2Activity : AppCompatActivity() &#123;</span><br><span class="line">    lateinit var handler: Handler</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main2)</span><br><span class="line"></span><br><span class="line">        handler = object : Handler() &#123;</span><br><span class="line">            override fun handleMessage(msg: Message) &#123;</span><br><span class="line">                super.handleMessage(msg)</span><br><span class="line">                Log.d(&quot;TAG&quot;, &quot;thread=$&#123;Thread.currentThread().name&#125;,$&#123;msg.what&#125;&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btnSend.setOnClickListener &#123;</span><br><span class="line">            val message1 = Message.obtain(handler, 101)</span><br><span class="line">            handler.sendMessage(message1)</span><br><span class="line">            Log.d(&quot;TAG&quot;, &quot;thread=$&#123;Thread.currentThread().name&#125;,start 1&quot;)</span><br><span class="line">            val message2 = Message.obtain(handler, 102)</span><br><span class="line">            handler.sendMessage(message2)</span><br><span class="line">            Log.d(&quot;TAG&quot;, &quot;thread=$&#123;Thread.currentThread().name&#125;,start 2&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//这段代码的运行结果:</span><br><span class="line">thread=main,start 1</span><br><span class="line">thread=main,start 2</span><br><span class="line">thread=main,101</span><br><span class="line">thread=main,102</span><br></pre></td></tr></table></figure></p><p>运行结果可以发现，同一线程消息的发送和处理也是异步的，并不是发送一个消息后立马就处理，原因是此时 MessageQueue 的 mBlocked==false ，于是消息加入队列后不会立马通知执行。</p><h3 id="问题4-Handler机制Looper死循环为什么不会导致应用卡死？"><a href="#问题4-Handler机制Looper死循环为什么不会导致应用卡死？" class="headerlink" title="问题4:Handler机制Looper死循环为什么不会导致应用卡死？"></a>问题4:Handler机制Looper死循环为什么不会导致应用卡死？</h3><p>Android系统的的所有事件处理都是通过Looper机制实现的，当有事件时会通过nativeWake唤醒正在等待的Looper线程，无事件处理时通过nativePollOnce使Looper线程进入休眠状态，也正是这样的机制保证了CPU资源的合理利用。</p><h3 id="问题5-Android-执行动画或者绘制-View-时，也是-Handler-吗？"><a href="#问题5-Android-执行动画或者绘制-View-时，也是-Handler-吗？" class="headerlink" title="问题5:Android 执行动画或者绘制 View 时，也是 Handler 吗？"></a>问题5:Android 执行动画或者绘制 View 时，也是 Handler 吗？</h3><p>是，具体可参考源码。（源码部分，笔者还不是彻底搞懂，后期搞懂再补充。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Handler机制是Android中相当经典的异步消息机制，本篇将从实用的角度来分析它。&lt;br&gt;
    
    </summary>
    
      <category term="Android基础" scheme="http://yoursite.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Handler机制" scheme="http://yoursite.com/tags/Handler%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android 进程间通信机制</title>
    <link href="http://yoursite.com/2020/07/14/Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/07/14/Android进程间通信机制/</id>
    <published>2020-07-14T06:03:32.000Z</published>
    <updated>2020-07-17T04:15:50.441Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 Android 实现进程间通信的几种方式，进入正题之前，我们首先来了解下多进程的概念，知道多进程是什么，以及为什么要用多进程。<br><a id="more"></a></p><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><p>1、一般情况下，一个应用程序就是一个进程，这个进程名称就是应用程序包名。每个进程都有自己独立的资源和内存空间，别的进程是不能任意访问其他进程的内存和资源。<br>2、单进程的局限：每个进程所能使用的资源是有限，特别是内存，安卓系统对用户进程有严格的内存要求，超过此内存限制时，应用将OOM和崩溃。所以，Android引入了多进程的概念，它允许在同一个应用内，为了分担主进程的压力，将占用内存的某些页面单独开一个进程。<br>3、Android多进程创建很简单，只需要在AndroidManifest.xml的声明四大组件的标签中增加”android:process”属性即可。命名之后，就成了一个单独的进程。”android:process”属性以【:】开头为当前应用的私有进程(:remote)，否则为全局进程（如：com.xxx.xxx）。<br>4、多进程应用运行时application的onCreate()会执行多次，所以使用的时候就要根据进程名判断当前所处的进程来进行对应的初始化操作。<br>5、静态成员和单例失效：每个进程保持各自的静态成员和单例，相互独立。<br>6、Android会为每一个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间。它们要访问对方的数据的时候，都要通过进程间通信的方式来进行。</p><h1 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h1><h2 id="一、Intent-Bundle"><a href="#一、Intent-Bundle" class="headerlink" title="一、Intent/Bundle"></a>一、Intent/Bundle</h2><p>Activity，Service，Receiver 都支持在 Intent 中传递 Bundle 数据，而 Bundle 实现了 Parcelable 接口，可以在不同的进程间进行传输。所以，在一个进程中启动了另一个进程的 Activity，Service 和 Receiver ，可以在 Bundle 中附加要传递的数据通过 Intent 发送出去。</p><blockquote><p><strong>提示</strong><br>Intent 不仅可以在进程间传输 Bundle（Parcelable）类型数据、基本类型数据，对于 Serializable 类型的数据也支持在进程间传递。但是我们一般不用 Serializable 作为进程间数据传递的载体，至于为什么，请参考<a href="https://juejin.im/post/5dadae3be51d4524d0269ba6#heading-3" target="_blank" rel="noopener">这篇文章</a>的序列化部分。文中提到的 Serializable 序列化、反序列化方式是反射，以反序列化为例，源码追溯路径是 readObject-&gt; readObject0 -&gt; readOrdinaryObject -&gt; invokeReadResolve&gt;readResolveMethod.invoke(…)。</p></blockquote><h2 id="二、文件共享"><a href="#二、文件共享" class="headerlink" title="二、文件共享"></a>二、文件共享</h2><p>1、可以在进程中序列化数据对象到文件中，然后在另一个进程中反序列化这个对象。<br>2、SharedPreferences 由于系统对SP的读写有一定的缓存策略，使内存中有一份SP文件，导致系统对它的读写不可靠。当高频读写操作是，SP会有数据丢失的风险，所以IPC不建议采用这种方式。<br>3、SQLite 支持多进程并发访问。请参考<a href="https://database.51cto.com/art/201908/601243.htm" target="_blank" rel="noopener">这篇文章</a>，笔者没有实践过。<br>4、使用 <a href="https://github.com/Tencent/MMKV" target="_blank" rel="noopener">MMKV</a> 库（后续文章再具体介绍）。</p><h2 id="三、Messager"><a href="#三、Messager" class="headerlink" title="三、Messager"></a>三、Messager</h2><p>通过Messenger可以在不同进程之间传递Message对象，Message中可以放入我们需要传递的数据，它的底层实现是AIDL。</p><p>但是Messenger在服务端的Handler是以串行的方式处理来自客户端的Message，所以如果有大量的并发请求，Messenger就效率低下，所以Messenger适用于数据并发量低的进程间通信。</p><p>具体使用请参考<a href="https://developer.android.com/guide/components/bound-services#Messenger" target="_blank" rel="noopener">官方文章&gt;&gt;</a></p><p>下面以一个音频播放器的例子讲解 Messager 的实际使用，关于音乐类软件开发思路笔者<a href="https://lianjiehao.github.io/2016/12/28/%E4%BC%98%E7%A7%80%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/" target="_blank" rel="noopener">这篇文章</a>中有列举参考资料）。</p><p>首先，我们从 MediaBrowserCompat 的 connect 方法说起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void connect() &#123;</span><br><span class="line">        mImpl.connect();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>方法中的 mImpl 是我们在构造 MediaBrowser 对象时创建的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public MediaBrowserCompat(Context context, ComponentName serviceComponent,</span><br><span class="line">        ConnectionCallback callback, Bundle rootHints) &#123;</span><br><span class="line">    // To workaround an issue of &#123;@link #unsubscribe(String, SubscriptionCallback)&#125; on API 24</span><br><span class="line">    // and 25 devices, use the support library version of implementation on those devices.</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= 26) &#123;</span><br><span class="line">        mImpl = new MediaBrowserImplApi26(context, serviceComponent, callback, rootHints);</span><br><span class="line">    &#125; else if (Build.VERSION.SDK_INT &gt;= 23) &#123;</span><br><span class="line">        mImpl = new MediaBrowserImplApi23(context, serviceComponent, callback, rootHints);</span><br><span class="line">    &#125; else if (Build.VERSION.SDK_INT &gt;= 21) &#123;</span><br><span class="line">        mImpl = new MediaBrowserImplApi21(context, serviceComponent, callback, rootHints);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mImpl = new MediaBrowserImplBase(context, serviceComponent, callback, rootHints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上 mImpl 的四种实现中只有 MediaBrowserImplBase 是以 Messenger 方式进行的（其它三个是 AIDL 的方式），下面我只选取 MediaBrowserImplBase 这个实现方式加以说明。</p><p>于是由<code>mImpl.connect()</code>走到了 MediaBrowserImplBase 的 connect 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void connect() &#123;</span><br><span class="line">            ...</span><br><span class="line">            mHandler.post(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    mServiceConnection = new MediaServiceConnection();</span><br><span class="line">                    boolean bound = false;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        bound = mContext.bindService(intent, mServiceConnection,</span><br><span class="line">                                Context.BIND_AUTO_CREATE);</span><br><span class="line">                    &#125; catch (Exception ex) &#123;</span><br><span class="line">                        Log.e(TAG, &quot;Failed binding to service &quot; + mServiceComponent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>只看主要部分，可见 MediaBrowserCompat 的 connect 方法最终做的工作就是调用 bindService 方法绑定了服务，其中 mServiceConnection 是一个<code>MediaServiceConnection</code>对象，他是<code>MediaBrowserImplBase</code>的内部类，下面我们看看<code>MediaServiceConnection</code>这个类做了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private class MediaServiceConnection implements ServiceConnection &#123;</span><br><span class="line">            MediaServiceConnection() &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onServiceConnected(final ComponentName name, final IBinder binder) &#123;</span><br><span class="line">                postOrRun(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        ...</span><br><span class="line"></span><br><span class="line">                        // Save their binder</span><br><span class="line">                        mServiceBinderWrapper = new ServiceBinderWrapper(binder, mRootHints);</span><br><span class="line"></span><br><span class="line">                        // We make a new mServiceCallbacks each time we connect so that we can drop</span><br><span class="line">                        // responses from previous connections.</span><br><span class="line">                        mCallbacksMessenger = new Messenger(mHandler);</span><br><span class="line">                        mHandler.setCallbacksMessenger(mCallbacksMessenger);</span><br><span class="line"></span><br><span class="line">                        mState = CONNECT_STATE_CONNECTING;</span><br><span class="line"></span><br><span class="line">                        // Call connect, which is async. When we get a response from that we will</span><br><span class="line">                        // say that we&apos;re connected.</span><br><span class="line">                        try &#123;</span><br><span class="line">                            if (DEBUG) &#123;</span><br><span class="line">                                Log.d(TAG, &quot;ServiceCallbacks.onConnect...&quot;);</span><br><span class="line">                                dump();</span><br><span class="line">                            &#125;</span><br><span class="line">                            mServiceBinderWrapper.connect(mContext, mCallbacksMessenger);</span><br><span class="line">                        &#125; catch (RemoteException ex) &#123;</span><br><span class="line"></span><br><span class="line">                            ...</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>我们重点关注 onServiceConnected 方法的实现，看代码注释，这里面做了两个重要的事，一个是由服务端返回的 binder(BinderProxy) 构造出 ServiceBinderWrapper 对象，之后在 ServiceBinderWrapper 构造方法内得到了一个 Messenger 对象，这个 messager 用于向服务端发送消息。第二个是调用 ServiceBinderWrapper 的 connect 方法将客户端构造的 Messenger 对象 mCallbacksMessenger 发送到了服务端，这样服务端就可以向这个客户端发送消息了。最终实现了由服务端到客户端，客户端到服务端的双向沟通机制。下面是 ServiceBinderWrapper 的构成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">private static class ServiceBinderWrapper &#123;</span><br><span class="line">       private Messenger mMessenger;</span><br><span class="line">       private Bundle mRootHints;</span><br><span class="line"></span><br><span class="line">       public ServiceBinderWrapper(IBinder target, Bundle rootHints) &#123;</span><br><span class="line">           mMessenger = new Messenger(target);</span><br><span class="line">           mRootHints = rootHints;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       void connect(Context context, Messenger callbacksMessenger)</span><br><span class="line">               throws RemoteException &#123;</span><br><span class="line">           Bundle data = new Bundle();</span><br><span class="line">           data.putString(DATA_PACKAGE_NAME, context.getPackageName());</span><br><span class="line">           data.putBundle(DATA_ROOT_HINTS, mRootHints);</span><br><span class="line">           sendRequest(CLIENT_MSG_CONNECT, data, callbacksMessenger);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       void disconnect(Messenger callbacksMessenger) throws RemoteException &#123;</span><br><span class="line">           sendRequest(CLIENT_MSG_DISCONNECT, null, callbacksMessenger);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       void addSubscription(String parentId, IBinder callbackToken, Bundle options,</span><br><span class="line">               Messenger callbacksMessenger)</span><br><span class="line">               throws RemoteException &#123;</span><br><span class="line">           Bundle data = new Bundle();</span><br><span class="line">           data.putString(DATA_MEDIA_ITEM_ID, parentId);</span><br><span class="line">           BundleCompat.putBinder(data, DATA_CALLBACK_TOKEN, callbackToken);</span><br><span class="line">           data.putBundle(DATA_OPTIONS, options);</span><br><span class="line">           sendRequest(CLIENT_MSG_ADD_SUBSCRIPTION, data, callbacksMessenger);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       void removeSubscription(String parentId, IBinder callbackToken,</span><br><span class="line">               Messenger callbacksMessenger)</span><br><span class="line">               throws RemoteException &#123;</span><br><span class="line">           Bundle data = new Bundle();</span><br><span class="line">           data.putString(DATA_MEDIA_ITEM_ID, parentId);</span><br><span class="line">           BundleCompat.putBinder(data, DATA_CALLBACK_TOKEN, callbackToken);</span><br><span class="line">           sendRequest(CLIENT_MSG_REMOVE_SUBSCRIPTION, data, callbacksMessenger);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       void getMediaItem(String mediaId, ResultReceiver receiver, Messenger callbacksMessenger)</span><br><span class="line">               throws RemoteException &#123;</span><br><span class="line">           Bundle data = new Bundle();</span><br><span class="line">           data.putString(DATA_MEDIA_ITEM_ID, mediaId);</span><br><span class="line">           data.putParcelable(DATA_RESULT_RECEIVER, receiver);</span><br><span class="line">           sendRequest(CLIENT_MSG_GET_MEDIA_ITEM, data, callbacksMessenger);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       void registerCallbackMessenger(Messenger callbackMessenger) throws RemoteException &#123;</span><br><span class="line">           Bundle data = new Bundle();</span><br><span class="line">           data.putBundle(DATA_ROOT_HINTS, mRootHints);</span><br><span class="line">           sendRequest(CLIENT_MSG_REGISTER_CALLBACK_MESSENGER, data, callbackMessenger);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       void unregisterCallbackMessenger(Messenger callbackMessenger) throws RemoteException &#123;</span><br><span class="line">           sendRequest(CLIENT_MSG_UNREGISTER_CALLBACK_MESSENGER, null, callbackMessenger);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       void search(String query, Bundle extras, ResultReceiver receiver,</span><br><span class="line">               Messenger callbacksMessenger) throws RemoteException &#123;</span><br><span class="line">           Bundle data = new Bundle();</span><br><span class="line">           data.putString(DATA_SEARCH_QUERY, query);</span><br><span class="line">           data.putBundle(DATA_SEARCH_EXTRAS, extras);</span><br><span class="line">           data.putParcelable(DATA_RESULT_RECEIVER, receiver);</span><br><span class="line">           sendRequest(CLIENT_MSG_SEARCH, data, callbacksMessenger);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       void sendCustomAction(String action, Bundle extras, ResultReceiver receiver,</span><br><span class="line">               Messenger callbacksMessenger) throws RemoteException &#123;</span><br><span class="line">           Bundle data = new Bundle();</span><br><span class="line">           data.putString(DATA_CUSTOM_ACTION, action);</span><br><span class="line">           data.putBundle(DATA_CUSTOM_ACTION_EXTRAS, extras);</span><br><span class="line">           data.putParcelable(DATA_RESULT_RECEIVER, receiver);</span><br><span class="line">           sendRequest(CLIENT_MSG_SEND_CUSTOM_ACTION, data, callbacksMessenger);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       private void sendRequest(int what, Bundle data, Messenger cbMessenger)</span><br><span class="line">               throws RemoteException &#123;</span><br><span class="line">           Message msg = Message.obtain();</span><br><span class="line">           msg.what = what;</span><br><span class="line">           msg.arg1 = CLIENT_VERSION_CURRENT;</span><br><span class="line">           msg.setData(data);</span><br><span class="line">           msg.replyTo = cbMessenger;</span><br><span class="line">           mMessenger.send(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>大体流程，首先是在构造函数中根据服务端返回的 binder 创建一个 Messenger 对象，下面的方法都最终调用了 sendRequest 方法，而 sendRequest 方法最后又调用了 Messager 的 send 方法往服务端发送消息，同时也会带上本地的 Messenger 对象 mCallbacksMessenger。</p><p>以上就是客户端的流程，下面进入服务端的流程。</p><p>当客户端调用 bindService 方法后，对于服务端来说最终会调用到它的 onCreate 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= 26) &#123;</span><br><span class="line">        mImpl = new MediaBrowserServiceImplApi26();</span><br><span class="line">    &#125; else if (Build.VERSION.SDK_INT &gt;= 23) &#123;</span><br><span class="line">        mImpl = new MediaBrowserServiceImplApi23();</span><br><span class="line">    &#125; else if (Build.VERSION.SDK_INT &gt;= 21) &#123;</span><br><span class="line">        mImpl = new MediaBrowserServiceImplApi21();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mImpl = new MediaBrowserServiceImplBase();</span><br><span class="line">    &#125;</span><br><span class="line">    mImpl.onCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只关注最后一种情况，即调用 MediaBrowserServiceImplBase 的 onCreate 方法（其它 3 个是 AIDL 方式 ）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MediaBrowserServiceImplBase implements MediaBrowserServiceImpl &#123;</span><br><span class="line">      private Messenger mMessenger;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onCreate() &#123;</span><br><span class="line">          mMessenger = new Messenger(mHandler);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public IBinder onBind(Intent intent) &#123;</span><br><span class="line">          if (SERVICE_INTERFACE.equals(intent.getAction())) &#123;</span><br><span class="line">              return mMessenger.getBinder();</span><br><span class="line">          &#125;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>MediaBrowserServiceImplBase 中，首先在 onCreate 中创建了类型为 Messenger 的 mMessenger 对象，之后在 onBind 方法中通过 mMessenger.getBinder() 返回 IBinder 供客户端使用，客户端拿到这个 IBinder 实例之后就可以往服务器发送消息了，之后的流程就是之前提到的客户端逻辑了。<br>通过解读源码，大家可以发现 Compat 包中对于不同 API 等级，使用的进程间通信方式是不一样的，以上只是一个很小的切入点，其它的方面还需自行阅读源码。总之一个原则就是，不管是 Messenger 还是 AIDL ，要实现进程间的双向沟通，就必须都拿到对方的 IBinder 代理对象。</p><h2 id="四、AIDL"><a href="#四、AIDL" class="headerlink" title="四、AIDL"></a>四、AIDL</h2><p>AIDL 可以解决并发和跨进程调用方法的问题，本质是利用了 Binder 传输机制，其实 Messenger 本质上也是 Binder ，只不过Messager不适合处理大量并发的消息处理，也不支持跨进程调用方法。</p><p>通过编写aidl文件来设计想要暴露的接口，编译后会自动生成对应的java文件，服务器将接口的具体实现写在Stub中，用 IBinder 对象传递给客户端，客户端 bindService 的时候，用 asInterface 的形式将 iBinder 还原成接口，再调用其中的方法。</p><p><a href="https://www.jianshu.com/p/29999c1a93cd" target="_blank" rel="noopener">参考链接&gt;&gt;</a></p><p>注意，AIDL 不支持单独的基本类型变量以及 String，CharSequence 类型变量的传递。他们必须作为 Parcelable 子类的一个属性存在。Serializable 不支持 AIDL 传递。</p><p>除了使用 AIDL 工具实现以上的机制，我们还可以通过手写 AIDL 生成的各个类，实现进程间通信的需求。<a href="https://www.jianshu.com/p/37368fab05bf" target="_blank" rel="noopener">参考链接&gt;&gt;</a></p><h2 id="五、ContentProvider"><a href="#五、ContentProvider" class="headerlink" title="五、ContentProvider"></a>五、ContentProvider</h2><p>系统四大组件之一，底层也是Binder实现，主要用来为其他APP提供数据，可以说天生就是为进程通信而生的。<a href="https://juejin.im/post/5af812966fb9a07ac85a8188" target="_blank" rel="noopener">使用教程&gt;&gt;</a></p><h2 id="六、Socket"><a href="#六、Socket" class="headerlink" title="六、Socket"></a>六、Socket</h2><p>Socket 是连接应用层与传输层之间的接口，常用的 Socket 类型有两种：流式 Socket（SOCK_STREAM）和数据报式 Socket（SOCK_DGRAM）。流式是一种面向连接的 Socket，针对于面向连接的 TCP 服务应用；数据报式 Socket 是一种无连接的 Socket ，对应于无连接的 UDP 服务应用。一般我们使用流式的 Socket。关于 Socket 的介绍将在后续的篇幅中讲解。</p><p><strong>以上内容参照了下面两篇文章的部分内容模块：</strong><br>1、<a href="https://xiaozhuanlan.com/topic/3896402175" target="_blank" rel="noopener">安卓进程间通信及 App 保活</a>的“多进程”和“进程间通信IPC方式”两大模块。<br>2、<a href="https://juejin.im/post/5dadae3be51d4524d0269ba6#heading-3" target="_blank" rel="noopener">使用AIDL来进行进程间通信</a>的“Android进程间通信的方式”和“进程间通信的准备”两大部分。</p><h1 id="疑惑解答"><a href="#疑惑解答" class="headerlink" title="疑惑解答"></a>疑惑解答</h1><h2 id="Android-为什么要选择-Binder-机制来实现进程间通信"><a href="#Android-为什么要选择-Binder-机制来实现进程间通信" class="headerlink" title="Android 为什么要选择 Binder 机制来实现进程间通信"></a>Android 为什么要选择 Binder 机制来实现进程间通信</h2><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">Binder</th><th style="text-align:left">共享内存</th><th style="text-align:left">Socket</th></tr></thead><tbody><tr><td style="text-align:left">性能</td><td style="text-align:left">数据拷贝一次</td><td style="text-align:left">无需拷贝</td><td style="text-align:left">数据拷贝两次</td></tr><tr><td style="text-align:left">稳定</td><td style="text-align:left">C/S架构，清晰明朗，稳定性好。</td><td style="text-align:left">需要自行处理同步等问题。</td><td style="text-align:left">C/S架构，传输效率低，开销大。</td></tr><tr><td style="text-align:left">安全性</td><td style="text-align:left">内核添加身份标识，可靠。</td><td style="text-align:left">依赖上层协议。访问接入点开放，不安全。</td><td style="text-align:left">依赖上层协议。访问接入点开放，不安全。</td></tr></tbody></table><p>Binder “数据拷贝一次”是什么意思？其实这里就涉及到 mmap（memory mapping）的使用了。</p><p>虚拟内存被用户系统分为两部分：用户空间和内核空间，用户空间是用户代码运行的地方，内核空间是内核代码运行的地方，内核空间由所有进程共享。为了安全，用户空间和内核空间是隔离的，即使用户空间的程序发生崩溃，内核也不会受到影响。每个用户空间（进程）之前也是互相隔离的，为了让进程之间可以互相通信，我们可以借助共享内核来实现数据传输。</p><img src="/2020/07/14/Android进程间通信机制/binder.jpg" title="Binder通信"><p>当数据从用户内存中拷贝到内核空间时，会在内核区域开辟一块虚拟内存，即 Binder 缓冲区，之后利用 mmap 技术将这块虚拟内存与接收方的虚拟内存映射到同一块物理内存上，这样就省去了从内核空间到用户空间的拷贝操作，从而实现了 binder 的一次拷贝技术（从用户空间到内核空间）。同时，binder 缓冲区的空间是有限的，所以需要及时释放内存，为后续拷贝操作做准备。</p><p>mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。下面我们利用 mmap 来实现文件写入功能。NDK使用知识请参考笔者写的两篇文章：<a href="http://localhost:4000/2016/08/06/七夕前，我认识了NDK/" target="_blank" rel="noopener">文章一</a>，<a href="http://localhost:4000/2016/08/14/NDK开发全攻略/" target="_blank" rel="noopener">文章二</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">JNIEXPORT void JNICALL</span><br><span class="line">Java_com_cxp_ndkapplication_HelloLibrary_write(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line">    std::string file = &quot;/storage/emulated/0/a.txt&quot;;</span><br><span class="line"></span><br><span class="line">//打开文件 new File(&quot;&quot;)</span><br><span class="line">    int m_fd = open(file.c_str(), O_RDWR | O_CREAT, S_IRWXU);</span><br><span class="line"></span><br><span class="line">//获取一页内存大小</span><br><span class="line">//Linux采用了分页来管理内存，即内存的管理中，内存是以页为单位，一般的32位系统一页为 4096 个字节。</span><br><span class="line">    int32_t m_size = getpagesize();</span><br><span class="line"></span><br><span class="line">//将文件设置为 m_size 这么大。</span><br><span class="line">    ftruncate(m_fd, m_size);</span><br><span class="line"></span><br><span class="line">//m_size：映射区的长度。需要是整数页个字节 byte[]。</span><br><span class="line">    int8_t *m_ptr = static_cast&lt;int8_t *&gt;(mmap(0, m_size, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd,0));</span><br><span class="line"></span><br><span class="line">    std::string data(&quot;12345&quot;);</span><br><span class="line"></span><br><span class="line">//将 data 的 data.size() 个数据 拷贝到 m_ptr。</span><br><span class="line">    memcpy(m_ptr, data.data(), data.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/07/14/Android进程间通信机制/mmap.jpg" title="mmap操作文件"><p>由上图可知，利用 mmap 操作文件是没有内核来参与的，发生零次数据拷贝。</p><p>而对于普通IO操作，则需要内核的参与，总共发生了两次数据拷贝。</p><img src="/2020/07/14/Android进程间通信机制/io.jpg" title="普通IO操作"><p><strong>这个时候就有疑惑了</strong>，前面讲到 binder 机制的实现利用到了 mmap 技术，可是却也经过了内核的拷贝操作啊。其实产生这个疑惑的原因是将 mmap 将内核挂钩了，这样想是不对的。我们可以把 binder 中提到的物理地址想象成文件地址，这样我们在内核区域将一段虚拟内存通过 mmap 映射到物理地址，再将用户空间的一段虚拟内存同样通过 mmap 映射到同一块物理地址后，再对内核区域虚拟空间的操作就等同于对用户空间的操作。</p><p>具体关于mmap的介绍请参考<a href="https://blog.csdn.net/u013525455/article/details/52582839" target="_blank" rel="noopener">这篇文章</a>范例模块之前的内容，当然我还有一些地方不明白的，比如“匿名内存映射”，等到具体使用时再来复盘，这里只需知道什么是 mmap，以及它的基本用法。</p><h2 id="Intent-传递的数据大小限制"><a href="#Intent-传递的数据大小限制" class="headerlink" title="Intent 传递的数据大小限制"></a>Intent 传递的数据大小限制</h2><p>我们深入到源码中，在 system/libhwbinder/ProcessState.cpp 这个类下有这么一行定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define DEFAULT_BINDER_VM_SIZE ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)</span><br></pre></td></tr></table></figure></p><p>可以看到进程为 Binder 分配的内存空间大小是1M-8k，而我们知道 Intent 是通过 binder 传递数据的，所以它的最大传输数据大小也不能超过 1M-8k（实际可传的数据大小会略小于这个数，因为 Intent 传输数据时会携带其它数据）。另外，Binder 是可以异步传输的，异步传输数据最大是（1M-8K）/2，除以 2 更多的是想对异步传输做一个限制，不希望异步传输消耗掉所有的 buffer。</p><p><strong>Binder Buffer 为什么会是(1M - 8K)，而不是整数值 1M ？</strong>这里看起来很奇怪，8K空间到底时用来做什么的？从GIT提交的记录可以看到下面的commits。</p><blockquote><p>Modify the binder to request 1M - 2 pages instead of 1M. The backing store in the kernel requires a guard page, so 1M allocations fragment memory very badly. Subtracting a couple of pages so that they fit in a power of two allows the kernel to make more efficient use of its virtual address space.</p></blockquote><p>这段解释还没有充分理解，其大致的意思是：kernel的“backing store”需要一个保护页，这使得1M用来分配碎片内存时变得很差，所以这里减去两页来提高效率，因为减去 1 页就变成了奇数。至于保护页如何影响内存分配，暂时不太清楚了。</p><p>对于Intent为什么不能传输大数据，可以再看下<a href="https://juejin.im/entry/5cc0f4d46fb9a0322d048b77" target="_blank" rel="noopener">这篇文章</a>。但该文章并未解释 Intent 为什么不能传1M-8k的数据，还有是内核空间是共用的，即所有进程共用 1 个内核空间，所以文中的 B 内核空间表述有误，应该改为共享内核空间。至于为什么不能传 1M-8k 的数据，笔者认为除了 Intent 除了会带有附加数据外，传递的时不只是有这个任务在使用这个 1M-8k 的 buffer（即虚拟内存），其它的任务也可能正在使用这个空间，所以实际传输能使用的空间大小会远小于这个 1M-8k ，笔者在模拟上测得大约是 505 k。</p><p>当使用 AIDL 同步方式传输数据时，可以测得最大传输值大小接近 1M-8K ，采用 AIDL 异步方式传输数据时，可以测得最大传输值大小接近（1M-8k）/2 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍 Android 实现进程间通信的几种方式，进入正题之前，我们首先来了解下多进程的概念，知道多进程是什么，以及为什么要用多进程。&lt;br&gt;
    
    </summary>
    
      <category term="Android基础" scheme="http://yoursite.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Binder机制" scheme="http://yoursite.com/tags/Binder%E6%9C%BA%E5%88%B6/"/>
    
      <category term="进程间通信" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Android 音视频开发实战</title>
    <link href="http://yoursite.com/2020/06/26/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3OpenGLES/"/>
    <id>http://yoursite.com/2020/06/26/初步了解OpenGLES/</id>
    <published>2020-06-26T13:34:57.000Z</published>
    <updated>2020-07-04T02:52:39.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>声明</strong><br>这是一篇 Android 音视频开发系列文章，它将以代码实战为主，并且会把参考文章罗列出来。对于参考文章中未提及的知识、有误的知识点以及未解决的BUG，都会在<code>注意事项</code>模块补充。建议读者在查看代码时配合着参考资料学习，这样效果会更佳。欢迎<a href="https://github.com/lianjiehao/AudioAndVideoPractice/issues" target="_blank" rel="noopener">提问题或建议</a>，大家共同进步～</p></blockquote><a id="more"></a><h4 id="代码实现及介绍"><a href="#代码实现及介绍" class="headerlink" title="代码实现及介绍"></a>代码实现及介绍</h4><ul><li><a href="https://github.com/lianjiehao/AudioAndVideoPractice/tree/master/chapter1-1" target="_blank" rel="noopener">chapter1-1</a>：OpenGL ES 基础环境搭建以及矩形绘制。</li><li><a href="https://github.com/lianjiehao/AudioAndVideoPractice/tree/master/chapter1-2" target="_blank" rel="noopener">chapter1-2</a>：对<code>chapter1-1</code>的封装，同时增加了OpenGL ES 日志输出功能。</li><li><a href="https://github.com/lianjiehao/AudioAndVideoPractice/tree/master/chapter2-1" target="_blank" rel="noopener">chapter2-1</a>：OpenGL ES 实现对图片的渲染。</li><li><a href="https://github.com/lianjiehao/AudioAndVideoPractice/tree/master/chapter2-2" target="_blank" rel="noopener">chapter2-2</a>：解决<code>chapter2-1</code>中图片显示变形的问题。</li><li><a href="https://github.com/lianjiehao/AudioAndVideoPractice/tree/master/chapter3" target="_blank" rel="noopener">chapter3</a>：OpenGL ES 实现对 gif 的渲染。</li><li><a href="https://github.com/lianjiehao/AudioAndVideoPractice/tree/master/chapter4-1" target="_blank" rel="noopener">chapter4-1</a>：音视频硬解码实现。</li><li><a href="https://github.com/lianjiehao/AudioAndVideoPractice/tree/master/chapter4-2" target="_blank" rel="noopener">chapter4-2</a>：OpenGL ES 结合硬解码播放视频。</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="chapter4-代码"><a href="#chapter4-代码" class="headerlink" title="chapter4 代码"></a>chapter4 代码</h5><ul><li>注意：音频采样率不要从<code>MediaFormat</code>中动态获取，而是应该固定为44100，一些资源通过动态获取的值有误。</li><li>BUG：某些视频播放过程中会异常终止。</li><li>BUG：音频播放结束后视频依然会播几帧。</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://juejin.im/post/5dae6469e51d45249850cf6f" target="_blank" rel="noopener">使用 OpenGL 渲染视频画面篇</a></li><li><a href="https://code.tutsplus.com/zh-hans/tutorials/how-to-use-android-media-effects-with-opengl-es--cms-23650" target="_blank" rel="noopener">如何使用OpenGL ES的Android Media Effects框架</a></li><li><a href="https://developer.android.com/guide/topics/graphics/opengl?hl=zh-cn" target="_blank" rel="noopener">Android 官方指南之 OpenGL ES</a></li><li>书籍：《OpenGL ES应用开发实践指南  Android卷》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;&lt;br&gt;这是一篇 Android 音视频开发系列文章，它将以代码实战为主，并且会把参考文章罗列出来。对于参考文章中未提及的知识、有误的知识点以及未解决的BUG，都会在&lt;code&gt;注意事项&lt;/code&gt;模块补充。建议读者在查看代码时配合着参考资料学习，这样效果会更佳。欢迎&lt;a href=&quot;https://github.com/lianjiehao/AudioAndVideoPractice/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;提问题或建议&lt;/a&gt;，大家共同进步～&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="音视频开发" scheme="http://yoursite.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="OpenGL ES" scheme="http://yoursite.com/tags/OpenGL-ES/"/>
    
      <category term="硬解码" scheme="http://yoursite.com/tags/%E7%A1%AC%E8%A7%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 设计模式总结</title>
    <link href="http://yoursite.com/2020/03/08/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E4%B9%8B23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/08/JAVA设计模式总结之23种设计模式/</id>
    <published>2020-03-08T06:58:23.000Z</published>
    <updated>2020-06-18T04:13:49.213Z</updated>
    
    <content type="html"><![CDATA[<p>笔者一直想对设计模式做一个全面的学习，这次疫情期间在家的时间多了，所以决定基于网络上的优秀文章把这一块知识好好学习整理一下，原文链接会在具体引用处标注。<br><a id="more"></a></p><h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><p><a href="http://www.uml.org.cn/oobject/201211231.asp" target="_blank" rel="noopener">原文链接&gt;&gt;</a></p><h1 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h1><p><a href="https://www.cnblogs.com/pony1223/p/7594803.html" target="_blank" rel="noopener">原文链接&gt;&gt;</a></p><p>对于上面参考文章中所提的”高内聚，低耦合”原则，到底什么是内聚，什么是耦合呢？<br>1、耦合<br>耦合主要描述模块之间的关系。耦合模块之间存在依赖, 导致改动可能会互相影响, <strong>关系越紧密, 耦合越强, 模块独立性越差。</strong><br>比如模块A直接操作了模块B中数据, 则视为强耦合, 若A只是通过数据与模块B交互, 则视为弱耦合。独立的模块便于扩展, 维护, 写单元测试, 如果模块之间重重依赖, 会极大降低开发效率。</p><img src="/2020/03/08/JAVA设计模式总结之23种设计模式/1.gif" title="耦合"><p>2、内聚<br>内聚主要描述模块内部。模块内部的元素, <strong>关联性越强, 则内聚越高, 模块单一性更强。</strong><br>一个模块应当尽可能独立完成某个功能, 如果有各种场景需要被引入到当前模块, 代码质量将变得非常脆弱, 这种情况建议拆分为多个模块.低内聚的模块代码, 不管是维护, 扩展还是重构都相当麻烦, 难以下手。</p><img src="/2020/03/08/JAVA设计模式总结之23种设计模式/2.gif" title="内聚"><blockquote><p><strong>注意：</strong><br>模块的粒度可大可小, 可以是函数, 类, 功能块等等。</p></blockquote><h1 id="设计模式详解"><a href="#设计模式详解" class="headerlink" title="设计模式详解"></a>设计模式详解</h1><p>此模块前两个部分来源于<a href="https://www.cnblogs.com/pony1223/p/7608955.html" target="_blank" rel="noopener">此文章</a>，第三部分<code>关键点</code>总结也大多来源于此链接。需要注意的是，链接中其余内容不用管。</p><h3 id="一、什么是设计模式"><a href="#一、什么是设计模式" class="headerlink" title="一、什么是设计模式"></a>一、什么是设计模式</h3><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现实中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。简单说：<br><strong>模式：在某些场景下，针对某类问题的某种通用的解决方案。</strong><br>场景：项目所在的环境<br>问题：约束条件，项目目标等<br>解决方案：通用、可复用的设计，解决约束达到目标。</p><h3 id="二、设计模式的三个分类"><a href="#二、设计模式的三个分类" class="headerlink" title="二、设计模式的三个分类"></a>二、设计模式的三个分类</h3><p><strong>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。</strong><br><strong>结构型模式：把类或对象结合在一起形成一个更大的结构。</strong><br><strong>行为型模式：类和对象如何交互，及划分责任和算法。</strong><br><strong>如下图所示：</strong></p><img src="/2020/03/08/JAVA设计模式总结之23种设计模式/3.png"><h3 id="三、23种设计模式"><a href="#三、23种设计模式" class="headerlink" title="三、23种设计模式"></a>三、23种设计模式</h3><p><del>对于下面外链文章所涉及到的 UML 时序图，笔者不是很理解它们的细节表达，不过也不影响对知识概念的理解吧，以后彻底理解了时序图的使用再来复盘。同时，下面的链接文章中有些细节性的小纠正会在其文章的评论区有体现，某些评论对了理解还是有其它辅助作用的。</del></p><h4 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h4><p><strong>关键点：某个类只能有一个实例，提供一个全局的访问点。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html" target="_blank" rel="noopener">单例模式详解&gt;&gt;</a><br>上面链接中讲到”双重检查加锁”为什么需要 volatile 关键字时没有讲清楚，它并没有提到 volatile 的”有序性”这一特性，实际上这才是”双重检查加锁”场景为什么需要 volatile 的本质。建议参考笔者之前写过的<a href="https://lianjiehao.github.io/2017/02/21/Java并发编程之Volatile和Automic/" target="_blank" rel="noopener">这篇文章</a>来全面了解 volatile 的作用。</p><h4 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2.简单工厂模式"></a>2.简单工厂模式</h4><p><strong>关键点：一个工厂类根据传入的量决定创建出哪一参种产品类的实例。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/03/22/2412308.html" target="_blank" rel="noopener">简单工厂模式详解&gt;&gt;</a></p><h4 id="3-工厂方法模式"><a href="#3-工厂方法模式" class="headerlink" title="3.工厂方法模式"></a>3.工厂方法模式</h4><p><strong>关键点：定义一个创建对象的接口，让子类决定实例化那个类。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/03/25/2416227.html" target="_blank" rel="noopener">工厂方法模式详解&gt;&gt;</a></p><h4 id="4-抽象工厂模式"><a href="#4-抽象工厂模式" class="headerlink" title="4.抽象工厂模式"></a>4.抽象工厂模式</h4><p><strong>关键点：创建相关对象或者依赖对象的家族，而无需明确指定具体类。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html" target="_blank" rel="noopener">抽象工厂模式详解&gt;&gt;&gt;</a></p><h4 id="5-建造者模式"><a href="#5-建造者模式" class="headerlink" title="5.建造者模式"></a>5.建造者模式</h4><p><strong>关键点：封装一个复杂对象的构建过程，并可以按步骤构造。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/07/2433939.html" target="_blank" rel="noopener">建造者模式详解&gt;&gt;&gt;</a><br>以上链接在”电子杂志系统”例子的红色字体部分讲到：虽然在这个例子里面各个产品类均有一个共同的接口，但这仅仅是本例子特有的，并不代表建造模式的特点…<br>我对这一句话的理解是：对于拥有完全不同接口的产品类的创建过程（这也是大多数场景），一种方案是，分别创建产品（Product）、导演者（Director）、抽象建造者（Builder）、具体建造者（WelcomeBuilder和GoodbyeBuilder），也就是用链文中第一个例子分别创建出各个产品。<strong>另一种方案是，复杂对象的构建可以使用链文中最后一种方法，笔者更倾向于此方案，因为能简化流程。</strong><br>总结一下就是，对于链文中第二个例子的多个产品应用共同接口的情况仅仅是个例，作者只是想把这种特殊情况单独拎出来吧，我们还是要把关注点放在大多数场景的解决方案上来，即第一种方案和第三种方案。</p><h4 id="6-原型模式"><a href="#6-原型模式" class="headerlink" title="6.原型模式"></a>6.原型模式</h4><p><strong>关键点：通过复制现有的实例来创建新的实例。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html" target="_blank" rel="noopener">原型模式详解&gt;&gt;&gt;</a></p><h4 id="7-适配器模式"><a href="#7-适配器模式" class="headerlink" title="7.适配器模式"></a>7.适配器模式</h4><p><strong>关键点：把一个类的接口变换成客户端所期待的另一种接口。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html" target="_blank" rel="noopener">适配器模式详解&gt;&gt;&gt;</a></p><h4 id="8-组合（合成）模式"><a href="#8-组合（合成）模式" class="headerlink" title="8.组合（合成）模式"></a>8.组合（合成）模式</h4><p><strong>关键点：将对象组合成树形结构以表示“部分-整体”的层次结构。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/17/2453861.html" target="_blank" rel="noopener">合成模式详解&gt;&gt;&gt;</a></p><h4 id="9-装饰模式"><a href="#9-装饰模式" class="headerlink" title="9.装饰模式"></a>9.装饰模式</h4><p><strong>关键点：动态的给对象添加新的功能，是继承关系的一个替代方案。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html" target="_blank" rel="noopener">装饰模式详解&gt;&gt;&gt;</a></p><h4 id="10-代理模式"><a href="#10-代理模式" class="headerlink" title="10.代理模式"></a>10.代理模式</h4><p><strong>关键点：为其他对象提供一个代理以便控制这个对象的访问。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/23/2466712.html" target="_blank" rel="noopener">代理模式详解&gt;&gt;&gt;</a></p><h4 id="11-亨元模式"><a href="#11-亨元模式" class="headerlink" title="11.亨元模式"></a>11.亨元模式</h4><p><strong>关键点：通过共享技术来有效的支持大量细粒度的对象。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html" target="_blank" rel="noopener">亨元模式&gt;&gt;&gt;</a></p><h4 id="12-外观（门面）模式"><a href="#12-外观（门面）模式" class="headerlink" title="12.外观（门面）模式"></a>12.外观（门面）模式</h4><p><strong>关键点：门面模式提供一个高层次的接口，使得子系统更易于使用。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/02/2478101.html" target="_blank" rel="noopener">门面模式详解&gt;&gt;&gt;</a></p><h4 id="13-桥接（桥梁）模式"><a href="#13-桥接（桥梁）模式" class="headerlink" title="13.桥接（桥梁）模式"></a>13.桥接（桥梁）模式</h4><p><strong>关键点：将抽象部分和它的实现部分分离，使它们都可以独立的变化。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/07/2480938.html" target="_blank" rel="noopener">桥梁模式详解&gt;&gt;&gt;</a><br>～关于<code>JDBC驱动器</code>的例子没看懂。以后在来复盘。～</p><h4 id="14-模板（模板方法）模式"><a href="#14-模板（模板方法）模式" class="headerlink" title="14.模板（模板方法）模式"></a>14.模板（模板方法）模式</h4><p><strong>关键点：定义一个算法结构，而将一些步骤延迟到子类实现。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html" target="_blank" rel="noopener">模板方法模式详解&gt;&gt;&gt;</a></p><h4 id="15-解释器模式"><a href="#15-解释器模式" class="headerlink" title="15.解释器模式"></a>15.解释器模式</h4><p><strong>关键点：给定一个语言，定义它的文法的一种表示，并定义一个解释器。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/06/19/2552617.html" target="_blank" rel="noopener">解释器模式详解&gt;&gt;&gt;</a></p><h4 id="16-策略模式"><a href="#16-策略模式" class="headerlink" title="16.策略模式"></a>16.策略模式</h4><p><strong>关键点：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html" target="_blank" rel="noopener">策略模式详解&gt;&gt;&gt;</a></p><h4 id="17-状态模式"><a href="#17-状态模式" class="headerlink" title="17.状态模式"></a>17.状态模式</h4><p><strong>关键点：允许一个对象在其对象内部状态改变时改变它的行为。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/06/08/2538146.html" target="_blank" rel="noopener">状态模式详解&gt;&gt;&gt;</a></p><h4 id="18-观察者模式"><a href="#18-观察者模式" class="headerlink" title="18.观察者模式"></a>18.观察者模式</h4><p><strong>关键点：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html" target="_blank" rel="noopener">观察者模式详解&gt;&gt;&gt;</a></p><h4 id="19-命令模式"><a href="#19-命令模式" class="headerlink" title="19.命令模式"></a>19.命令模式</h4><p><strong>关键点：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/06/01/2526972.html" target="_blank" rel="noopener">命令模式详解&gt;&gt;&gt;</a></p><h4 id="20-备忘录模式"><a href="#20-备忘录模式" class="headerlink" title="20.备忘录模式"></a>20.备忘录模式</h4><p><strong>关键点：在不破坏封装的前提下，保持对象的内部状态。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/06/06/2534942.html" target="_blank" rel="noopener">备忘录模式详解&gt;&gt;&gt;</a></p><h4 id="21-迭代器（迭代子）模式"><a href="#21-迭代器（迭代子）模式" class="headerlink" title="21.迭代器（迭代子）模式"></a>21.迭代器（迭代子）模式</h4><p><strong>关键点：顺序地访问一个聚集中的元素而不必暴露聚集的内部表象。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/22/2511506.html" target="_blank" rel="noopener">迭代子模式详解&gt;&gt;&gt;</a></p><h4 id="22-访问者模式"><a href="#22-访问者模式" class="headerlink" title="22.访问者模式"></a>22.访问者模式</h4><p><strong>关键点：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。</strong><br><a href="https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">访问者模式详解&gt;&gt;&gt;</a></p><h4 id="23-责任链模式"><a href="#23-责任链模式" class="headerlink" title="23.责任链模式"></a>23.责任链模式</h4><p><strong>关键点：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</strong><br><a href="https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="noopener">责任链模式详解&gt;&gt;&gt;</a></p><h4 id="24-中介者（调停者）模式"><a href="#24-中介者（调停者）模式" class="headerlink" title="24.中介者（调停者）模式"></a>24.中介者（调停者）模式</h4><p><strong>关键点：用一个中介对象来封装一系列的对象交互。</strong><br><a href="https://www.cnblogs.com/java-my-life/archive/2012/06/20/2554024.html" target="_blank" rel="noopener">调停者模式详解&gt;&gt;&gt;</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者一直想对设计模式做一个全面的学习，这次疫情期间在家的时间多了，所以决定基于网络上的优秀文章把这一块知识好好学习整理一下，原文链接会在具体引用处标注。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《深入浅出 Android 源代码》读后感</title>
    <link href="http://yoursite.com/2020/02/18/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/02/18/Activity启动流程/</id>
    <published>2020-02-18T04:22:59.000Z</published>
    <updated>2020-07-19T23:38:57.678Z</updated>
    
    <content type="html"><![CDATA[<p>本篇记录了笔者在阅读《深入浅出 Android 源代码》这本书时认为比较重要的知识点，源码基于 Android 6.0 。<br><a id="more"></a></p><h1 id="Activity-的启动过程"><a href="#Activity-的启动过程" class="headerlink" title="Activity 的启动过程"></a>Activity 的启动过程</h1><p>正如书中所说，从点击桌面图标开始分析 Activity 的启动过程，才能全面的掌握这一块的知识点。手机的桌面其实就是一个 Activity ，名称叫 Launcher。当点击 Launcher 中图标后，进入了 Launcher 类的 startActivitySafely 方法，最终该方法调用了 Instrumentation 的 execStartActivitysAsUser 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/app/Instrumentation.java</span><br><span class="line"></span><br><span class="line">public void execStartActivitiesAsUser(Context who, IBinder contextThread,</span><br><span class="line">        IBinder token, Activity target, Intent[] intents, Bundle options,</span><br><span class="line">        int userId) &#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    if (mActivityMonitors != null) &#123;</span><br><span class="line">        synchronized (mSync) &#123;</span><br><span class="line">            final int N = mActivityMonitors.size();</span><br><span class="line">            for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                final ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                if (am.match(who, null, intents[0])) &#123;</span><br><span class="line">                    am.mHits++;</span><br><span class="line">                    if (am.isBlocking()) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        String[] resolvedTypes = new String[intents.length];</span><br><span class="line">        for (int i=0; i&lt;intents.length; i++) &#123;</span><br><span class="line">            intents[i].migrateExtraStreamToClipData();</span><br><span class="line">            intents[i].prepareToLeaveProcess();</span><br><span class="line">            resolvedTypes[i] = intents[i].resolveTypeIfNeeded(who.getContentResolver());</span><br><span class="line">        &#125;</span><br><span class="line">        int result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivities(whoThread, who.getBasePackageName(), intents, resolvedTypes,</span><br><span class="line">                    token, options, userId);</span><br><span class="line">        checkStartActivityResult(result, intents[0]);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ActivityManagerNative.getDefault()</code>返回 AMS 的代理对象 ActivityManagerProxy，通过 Binder 驱动最终进入到了 AMS 的 startActivity 方法。</p><p>经过一系列的往下调用，流程来到了 ActivityStack 类的 resumeTopActivityInnerLocked 方法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   private boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) &#123;</span><br><span class="line"></span><br><span class="line">///省略一波代码</span><br><span class="line"></span><br><span class="line">       if (mResumedActivity != null) &#123;</span><br><span class="line">           if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                   &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);</span><br><span class="line">           pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);</span><br><span class="line">       &#125;</span><br><span class="line">       if (pausing) &#123;</span><br><span class="line">           if (DEBUG_SWITCH || DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                   &quot;resumeTopActivityLocked: Skip resume: need to start pausing&quot;);</span><br><span class="line">           // At this point we want to put the upcoming activity&apos;s process</span><br><span class="line">           // at the top of the LRU list, since we know we will be needing it</span><br><span class="line">           // very soon and it would be a waste to let it get killed if it</span><br><span class="line">           // happens to be sitting towards the end.</span><br><span class="line">           if (next.app != null &amp;&amp; next.app.thread != null) &#123;</span><br><span class="line">               mService.updateLruProcessLocked(next.app, true, null);</span><br><span class="line">           &#125;</span><br><span class="line">           if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">///省略一波代码</span><br><span class="line"></span><br><span class="line">mStackSupervisor.startSpecificActivityLocked(next, true, true);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>此时，mResumedActivity 就是 Launcher ， mResumedActivity 不为 null，于是调用 startPausingLocked 方法，之后通过应用进程的 ApplicationThread 将流程回到应用进程，最后来到了 ActivityThread 的 handlePauseActivity 类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">private void handlePauseActivity(IBinder token, boolean finished,</span><br><span class="line">        boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r);</span><br><span class="line">        if (userLeaving) &#123;</span><br><span class="line">            performUserLeavingActivity(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">        performPauseActivity(token, finished, r.isPreHoneycomb());</span><br><span class="line"></span><br><span class="line">        // Make sure any pending writes are now committed.</span><br><span class="line">        if (r.isPreHoneycomb()) &#123;</span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Tell the activity manager we have paused.</span><br><span class="line">        if (!dontReport) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mSomeActivitiesChanged = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过调用 performPauseActivity 后，程序真正进入了 Launcher 的 onPause 方法。</p><p>之后 <code>ActivityManagerNative.getDefault().activityPaused(token)</code> 再次将流程转到了 AMS ，通过一些系列调用，到了 ActivityStack 的 completePauseLocked 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/app/ActivityStack.java</span><br><span class="line"></span><br><span class="line">private void completePauseLocked(boolean resumeNext) &#123;</span><br><span class="line">    ActivityRecord prev = mPausingActivity;</span><br><span class="line">    if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Complete pause: &quot; + prev);</span><br><span class="line"></span><br><span class="line">    if (prev != null) &#123;</span><br><span class="line">        prev.state = ActivityState.PAUSED;</span><br><span class="line">        if (prev.finishing) &#123;</span><br><span class="line">            if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Executing finish of activity: &quot; + prev);</span><br><span class="line">            prev = finishCurrentActivityLocked(prev, FINISH_AFTER_VISIBLE, false);</span><br><span class="line">        &#125; else if (prev.app != null) &#123;</span><br><span class="line">            if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Enqueueing pending stop: &quot; + prev);</span><br><span class="line">            if (mStackSupervisor.mWaitingVisibleActivities.remove(prev)) &#123;</span><br><span class="line">                if (DEBUG_SWITCH || DEBUG_PAUSE) Slog.v(TAG_PAUSE,</span><br><span class="line">                        &quot;Complete pause, no longer waiting: &quot; + prev);</span><br><span class="line">            &#125;</span><br><span class="line">            if (prev.configDestroy) &#123;</span><br><span class="line">                // The previous is being paused because the configuration</span><br><span class="line">                // is changing, which means it is actually stopping...</span><br><span class="line">                // To juggle the fact that we are also starting a new</span><br><span class="line">                // instance right now, we need to first completely stop</span><br><span class="line">                // the current instance before starting the new one.</span><br><span class="line">                if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Destroying after pause: &quot; + prev);</span><br><span class="line">                destroyActivityLocked(prev, true, &quot;pause-config&quot;);</span><br><span class="line">            &#125; else if (!hasVisibleBehindActivity() || mService.isSleepingOrShuttingDown()) &#123;</span><br><span class="line">                // If we were visible then resumeTopActivities will release resources before</span><br><span class="line">                // stopping.</span><br><span class="line">                mStackSupervisor.mStoppingActivities.add(prev);</span><br><span class="line">                if (mStackSupervisor.mStoppingActivities.size() &gt; 3 ||</span><br><span class="line">                        prev.frontOfTask &amp;&amp; mTaskHistory.size() &lt;= 1) &#123;</span><br><span class="line">                    // If we already have a few activities waiting to stop,</span><br><span class="line">                    // then give up on things going idle and start clearing</span><br><span class="line">                    // them out. Or if r is the last of activity of the last task the stack</span><br><span class="line">                    // will be empty and must be cleared immediately.</span><br><span class="line">                    if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;To many pending stops, forcing idle&quot;);</span><br><span class="line">                    mStackSupervisor.scheduleIdleLocked();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mStackSupervisor.checkReadyForSleepLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;App died during pause, not stopping: &quot; + prev);</span><br><span class="line">            prev = null;</span><br><span class="line">        &#125;</span><br><span class="line">        // It is possible the activity was freezing the screen before it was paused.</span><br><span class="line">        // In that case go ahead and remove the freeze this activity has on the screen</span><br><span class="line">        // since it is no longer visible.</span><br><span class="line">        prev.stopFreezingScreenLocked(true /*force*/);</span><br><span class="line">        mPausingActivity = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (resumeNext) &#123;</span><br><span class="line">        final ActivityStack topStack = mStackSupervisor.getFocusedStack();</span><br><span class="line">        if (!mService.isSleepingOrShuttingDown()) &#123;</span><br><span class="line">            mStackSupervisor.resumeTopActivitiesLocked(topStack, prev, null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mStackSupervisor.checkReadyForSleepLocked();</span><br><span class="line">            ActivityRecord top = topStack.topRunningActivityLocked(null);</span><br><span class="line">            if (top == null || (prev != null &amp;&amp; top != prev)) &#123;</span><br><span class="line">                // If there are no more activities available to run,</span><br><span class="line">                // do resume anyway to start something.  Also if the top</span><br><span class="line">                // activity on the stack is not the just paused activity,</span><br><span class="line">                // we need to go ahead and resume it to ensure we complete</span><br><span class="line">                // an in-flight app switch.</span><br><span class="line">                mStackSupervisor.resumeTopActivitiesLocked(topStack, null, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (prev != null) &#123;</span><br><span class="line">        prev.resumeKeyDispatchingLocked();</span><br><span class="line"></span><br><span class="line">        if (prev.app != null &amp;&amp; prev.cpuTimeAtResume &gt; 0</span><br><span class="line">                &amp;&amp; mService.mBatteryStatsService.isOnBattery()) &#123;</span><br><span class="line">            long diff = mService.mProcessCpuTracker.getCpuTimeForPid(prev.app.pid)</span><br><span class="line">                    - prev.cpuTimeAtResume;</span><br><span class="line">            if (diff &gt; 0) &#123;</span><br><span class="line">                BatteryStatsImpl bsi = mService.mBatteryStatsService.getActiveStatistics();</span><br><span class="line">                synchronized (bsi) &#123;</span><br><span class="line">                    BatteryStatsImpl.Uid.Proc ps =</span><br><span class="line">                            bsi.getProcessStatsLocked(prev.info.applicationInfo.uid,</span><br><span class="line">                                    prev.info.packageName);</span><br><span class="line">                    if (ps != null) &#123;</span><br><span class="line">                        ps.addForegroundTimeLocked(diff);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.cpuTimeAtResume = 0; // reset it</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Notfiy when the task stack has changed</span><br><span class="line">    mService.notifyTaskStackChangedLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>mStackSupervisor.scheduleIdleLocked()</code> 最终执行了 Launcher 的 onPause 方法。</p><p><code>mStackSupervisor.resumeTopActivitiesLocked</code> 一路调用，再次来到了 ActivityStack 的 resumeTopActivityInnerLocked 方法，该方法调用了 ActivityStackSupervisor 类的 startSpecificActivityLocked 方法，此时正式开始了新 Activity 的生命周期过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/app/ActivityStackSupervisor.java</span><br><span class="line"></span><br><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">        boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">    // Is this activity&apos;s application already running?</span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">            r.info.applicationInfo.uid, true);</span><br><span class="line"></span><br><span class="line">    r.task.stack.setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">    if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0</span><br><span class="line">                    || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">                // Don&apos;t add this if it is a platform component that is marked</span><br><span class="line">                // to run in multiple processes, because this is actually</span><br><span class="line">                // part of the framework so doesn&apos;t make sense to track as a</span><br><span class="line">                // separate apk in the process.</span><br><span class="line">                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class="line">                        mService.mProcessStats);</span><br><span class="line">            &#125;</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If a dead object exception was thrown -- fall through to</span><br><span class="line">        // restart the application.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">            &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果 app 不为 null ,就代表将要启动的 Activity 的进程已经启动(在已启动 APP 中启动Activity 就会走 app 不为 null 的逻辑)，显然这里 app 为 null，于是调用了 AMS 的 startProcessLocked 方法启动新的应用进程。startProcessLocked 通过 Socekt 通知 Zygote 进程创建新的进程，之后进入了 ActivityThread 的 main 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">    // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">    // disable it here, but selectively enable it later (via</span><br><span class="line">    // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">    CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    // Set the reporter for event logging in libcore</span><br><span class="line">    EventLogger.setReporter(new EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">    AndroidKeyStoreProvider.install();</span><br><span class="line"></span><br><span class="line">    // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    thread.attach(false);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler == null) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (false) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(new</span><br><span class="line">                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // End of event ActivityThreadMain.</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>main 方法作为新 app 的入口，主要做了三件事。一是创建了应用程序进程的主线程消息队列和消息循环，让这个线程一直 loop。而是创建一个 ActivityThread 对象。三是 ActivityThread 的 attach() 方法，下面就来看看这个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        final IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">        try &#123;</span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            // Ignore</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mAppThread 是当前进程的一个 Binder 对象，之后会传递给 AMS ，AMS之后就是通过该对象与 ActivityThread 通信的。</p><p><code>mgr.attachApplication</code> 会经过 Binder 驱动最终调用到 AMS 的 attachApplication 方法。</p><p>AMS 的 attachApplication 方法会调用到 AMS 的 attachApplicationLocked 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">        int pid) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // See if the top visible activity is waiting to run in this process...</span><br><span class="line">    if (normalMode) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                didSomething = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">            badApp = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (!didSomething) &#123;</span><br><span class="line">        //调用处理内存管理。不是很理解里面的机制，暂时不分析。</span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mStackSupervisor.attachApplicationLocked(app)</code> 最终会通过 Binder 驱动执行到 ActivityThread 的 scheduleLaunchActivity 方法，最终调用了 handleLaunchActivity 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    </span><br><span class="line">    ...        </span><br><span class="line"></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    if (a != null) &#123;</span><br><span class="line">        r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">        Bundle oldState = r.state;</span><br><span class="line">        handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>performLaunchActivity</code> 调用后会进入 Activity 的 onCreate 方法。</p><p><code>handleResumeActivity</code> 调用后会进入 Activity 的 onStart 和 onResume 方法。</p><p>首先来看下 performLaunchActivity 方法的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    // System.out.println(&quot;##### [&quot; + System.currentTimeMillis() + &quot;] ActivityThread.performLaunchActivity(&quot; + r + &quot;)&quot;);</span><br><span class="line"></span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    if (r.packageInfo == null) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    if (component == null) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.activityInfo.targetActivity != null) &#123;</span><br><span class="line">        component = new ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Activity activity = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        if (r.state != null) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);</span><br><span class="line">        if (localLOGV) Slog.v(</span><br><span class="line">                TAG, r + &quot;: app=&quot; + app</span><br><span class="line">                + &quot;, appName=&quot; + app.getPackageName()</span><br><span class="line">                + &quot;, pkg=&quot; + r.packageInfo.getPackageName()</span><br><span class="line">                + &quot;, comp=&quot; + r.intent.getComponent().toShortString()</span><br><span class="line">                + &quot;, dir=&quot; + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = new Configuration(mCompatConfiguration);</span><br><span class="line">            if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;</span><br><span class="line">                    + r.activityInfo.name + &quot; with config &quot; + config);</span><br><span class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor);</span><br><span class="line"></span><br><span class="line">            if (customIntent != null) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = null;</span><br><span class="line">            activity.mStartedActivity = false;</span><br><span class="line">            int theme = r.activityInfo.getThemeResource();</span><br><span class="line">            if (theme != 0) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = false;</span><br><span class="line">            if (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!activity.mCalled) &#123;</span><br><span class="line">                throw new SuperNotCalledException(</span><br><span class="line">                    &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                    &quot; did not call through to super.onCreate()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">            r.stopped = true;</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.performStart();</span><br><span class="line">                r.stopped = false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    if (r.state != null || r.persistentState != null) &#123;</span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                                r.persistentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (r.state != null) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.mCalled = false;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                            r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!activity.mCalled) &#123;</span><br><span class="line">                    throw new SuperNotCalledException(</span><br><span class="line">                        &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                        &quot; did not call through to super.onPostCreate()&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r.paused = true;</span><br><span class="line"></span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to start activity &quot; + component</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法首先通过反射创建 Activity 对象，之后通过 activity 的 attach 方法做了很多 View 相关的初始化工作，之后调用 <code>mInstrumentation.callActivityOnPostCreate(activity, r.state);</code> 就会进入 Activity 的 onCreate 方法。</p><p>接下来看下 handleResumeActivity 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">        boolean clearHide, boolean isForward, boolean reallyResume) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ActivityClientRecord r = performResumeActivity(token, clearHide);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用 performResumeActivity 后进入 Activity 的 onStart 和 onResume 方法，这里就不再分析了，这个过程和进入 onCreate 方法类似。</p><p>调用 <code>Looper.myQueue().addIdleHandler(new Idler())</code> 语句后，进入 AMS activityIdle 方法，之后再次回到应用进程中执行了上个 Activity 的 onStop 方法。</p><p>至此，Activity 的启动过程就分析完毕。</p><p>最后，推荐阅读以下<a href="https://blog.csdn.net/jiejingguo/article/details/101012122" target="_blank" rel="noopener">这篇文章</a>了解一下 ActivityRecord、ActivityClientRecord、Activity 三者之前的关系。</p><h1 id="ANR-机制"><a href="#ANR-机制" class="headerlink" title="ANR 机制"></a>ANR 机制</h1><h3 id="ANR-产生的原因"><a href="#ANR-产生的原因" class="headerlink" title="ANR 产生的原因"></a>ANR 产生的原因</h3><p>只有当应用程序的UI线程响应超时才会引起ANR，超时产生原因一般有两种。</p><ol><li>当前的事件没有机会得到处理，例如UI线程正在响应另一个事件，当前事件由于某种原因被阻塞了。</li><li>当前的事件正在处理，但是由于耗时太长没能及时完成。</li></ol><p>根据ANR产生的原因不同，超时事件也不尽相同，从本质上将，产生ANR的原因有三种，大致可以对应到android中四大组件中的三个（Activity/View，BroadcastReceiver和Service）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KeyDispatchTimeout</span><br></pre></td></tr></table></figure><p>最常见的一种类型，原因就是View的点击事件或者触摸事件在特定的时间（5s）内无法得到响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BroadcastTimeout</span><br></pre></td></tr></table></figure><p>原因是BroadcastReceiver的onReceive()函数运行在主线程中，在特定的时间（10s）内无法完成处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceTimeout</span><br></pre></td></tr></table></figure><p>比较少出现的一种类型，原因是Service的各个生命周期函数在特定时间（20s）内无法完成处理。</p><p>该模块更多知识请看 <a href="https://juejin.im/entry/597026806fb9a06bcb7fc660" target="_blank" rel="noopener">这篇文章</a>。</p><h3 id="以-Service-的启动为例，分析-ANR-产生的过程"><a href="#以-Service-的启动为例，分析-ANR-产生的过程" class="headerlink" title="以 Service 的启动为例，分析 ANR 产生的过程"></a>以 Service 的启动为例，分析 ANR 产生的过程</h3><p>当我们调用 startService 方法后，最终会来到 ActiveServices 的 realStartServiceLocked 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> frameworks/base/core/java/android/server/am/ActiveServices.java</span><br><span class="line"></span><br><span class="line"> private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">            ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);</span><br><span class="line">        //该方法就是 ANR 记录器，到底特定时间就会触发 ANR 操作。</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                    app.repProcState);</span><br><span class="line">     //通过 Binder 驱动调用到 AMS 的 scheduleCreateService 方法。</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>bumpServiceExecutingLocked 最终会调用 scheduleServiceTimeoutLocked 方法，我来看下 scheduleServiceTimeoutLocked 的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void scheduleServiceTimeoutLocked(ProcessRecord proc) &#123;</span><br><span class="line">    if (proc.executingServices.size() == 0 || proc.thread == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    long now = SystemClock.uptimeMillis();</span><br><span class="line">    Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">            ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">    msg.obj = proc;</span><br><span class="line">    mAm.mHandler.sendMessageAtTime(msg,</span><br><span class="line">            proc.execServicesFg ? (now+SERVICE_TIMEOUT) : (now+ SERVICE_BACKGROUND_TIMEOUT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会在超时时间到达后发送 ActivityManagerService.SERVICE_TIMEOUT_MSG 消息，AMS 受该消息后进入 MainHandler 的 SERVICE_TIMEOUT_MSG case。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">case SERVICE_TIMEOUT_MSG: &#123;</span><br><span class="line">    if (mDidDexOpt) &#123;</span><br><span class="line">        mDidDexOpt = false;</span><br><span class="line">        Message nmsg = mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);</span><br><span class="line">        nmsg.obj = msg.obj;</span><br><span class="line">        mHandler.sendMessageDelayed(nmsg, ActiveServices.SERVICE_TIMEOUT);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mServices.serviceTimeout((ProcessRecord)msg.obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mServices.serviceTimeout 最终会通过 AMS 的 appNotResponding 方法发送 SHOW_NOT_RESPONDING_MSG 消息到 UiHandler 中弹出 ANR 弹窗。</p><p>由以上分析我们可以知道，要想避免 ANR 弹窗的出现，就必须抢在超时时间到达之前结束 mAm.mHandler.sendMessageAtTime 的发送，如何结束呢？</p><p>让我们回到 realStartServiceLocked 方法，执行 app.thread.scheduleCreateService 语句最终会将我们带到应用进程 ActivityThread 类的 handleCreateService 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void handleCreateService(CreateServiceData data) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    Service service = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate service &quot; + data.info.name</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        service.onCreate();</span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        try &#123;</span><br><span class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            // nothing to do.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to create service &quot; + data.info.name</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码首先通过反射创建了 Service 对象，之后 service.onCreate 方法调用，最后 ActivityManagerNative.getDefault().serviceDoneExecuting 语句会通过 Binder 驱动调用 AMS 的 serviceDoneExecuting 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void serviceDoneExecuting(IBinder token, int type, int startId, int res) &#123;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        if (!(token instanceof ServiceRecord)) &#123;</span><br><span class="line">            Slog.e(TAG, &quot;serviceDoneExecuting: Invalid service token=&quot; + token);</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid service token&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mServices.serviceDoneExecutingLocked 最终会调用到 ActiveServices 的 serviceDoneExecutingLocked 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying,</span><br><span class="line">        boolean finishing) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (r.executeNesting &lt;= 0) &#123;</span><br><span class="line">        if (r.app != null) &#123;</span><br><span class="line">            if (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                    &quot;Nesting at 0 of &quot; + r.shortName);</span><br><span class="line">            r.app.execServicesFg = false;</span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line">            if (r.app.executingServices.size() == 0) &#123;</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mAm.mHandler.removeMessages 语句移除了 ActivityManagerService.SERVICE_TIMEOUT_MSG 消息，之后 ANR 就不会被触发了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇记录了笔者在阅读《深入浅出 Android 源代码》这本书时认为比较重要的知识点，源码基于 Android 6.0 。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WebView使用教程</title>
    <link href="http://yoursite.com/2020/01/05/WebView%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/01/05/WebView使用教程/</id>
    <published>2020-01-05T13:03:15.000Z</published>
    <updated>2020-02-26T13:55:57.636Z</updated>
    
    <content type="html"><![CDATA[<p>如果你想在将web页面作为APP的一部分，那么我们可以使用WebView。WebView在Android中继承了view类，作为承载网页的控件。但是我们应该知道它并没有继承web浏览器的所有特性，它所实现的也只是展示网页，以及一些基本的交互和监听功能。<a id="more"></a><br>WebView经常被使用的场景是，当你的APP需要向用户展示一个随时可更新的内容，比如用户条款、使用向导。那么这样的话，我们可以在一个Activity中包含一个WebView控件用来展示服务器维护的内容，这些内容可以在服务器随时更改。<br>WeblView另一个使用场景是，当我们需要在一个页面中请求所有用户的数据，一般的做法是写一个layout，然后利用网络请求所有所需数据，最后将这些数据填充到layout中。但最简洁的方式是，我们其实可以直接加载一个网页，这个网页包含了需要的数据。<br>这个教程将帮助你学会使用WebView，以及关于它高级一点的用法，比如页面跳转、js交互等。</p><h1 id="添加WebView到你的应用"><a href="#添加WebView到你的应用" class="headerlink" title="添加WebView到你的应用"></a>添加WebView到你的应用</h1><p>添加WebView到你的应用最简单的方式是在Layout中添加&lt; WebView &gt;标签，例如下面的例子表示一个全屏的WebView。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;WebView  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:id=&quot;@+id/webview&quot;</span><br><span class="line">android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><p>加载网页，调用loadUrl()方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.loadUrl(&quot;http://www.example.com&quot;);</span><br></pre></td></tr></table></figure></p><p>请求服务器网页时，别忘了要加网络请求权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest ... &gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure></p><p>以上就是最简单的加载网页方式。</p><h1 id="在WebView中使用JavaScript"><a href="#在WebView中使用JavaScript" class="headerlink" title="在WebView中使用JavaScript"></a>在WebView中使用JavaScript</h1><p>如果你在APP展示的网页中包含JS，那么请确保WebView支持JS的加载。在此之后，你还可以新建接口让WebView与Android代码交互。</p><h2 id="授权使用JavaScript"><a href="#授权使用JavaScript" class="headerlink" title="授权使用JavaScript"></a>授权使用JavaScript</h2><p>WebView默认不支持JS的加载，开启它需要调用WebSetting的setJavaScriptEnable()方法。WebSetting可以通过WebView的getSettings()方法获得。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">WebSettings webSettings = myWebView.getSettings();</span><br><span class="line">webSettings.setJavaScriptEnabled(true);</span><br></pre></td></tr></table></figure></p><p>WebSetting提供了许多使用性的功能，比如你想让你幸幸苦苦开发的web page只能在自己的android应用中展示，那么可以在客户端通过setUserAgentString()设置用户代理之后，在服务端遍历userAgentString字段是否是自己的客户端所设定的。</p><h2 id="在Android代码中绑定JavaScript代码"><a href="#在Android代码中绑定JavaScript代码" class="headerlink" title="在Android代码中绑定JavaScript代码"></a>在Android代码中绑定JavaScript代码</h2><p>通过接口的方式，你可以使你的Android代码和JavaScript代码进行交互。例如，你的JavaScript代码可以调用Android代码弹出一个提示框，而不是使用JavaScript的Alert（）方法。<br>让JavaScript和Android代码产生联系的关键是addJavaScriptInterface()方法，此方法包含两个参数，第一个是一个类对象，供JavaScript调用。第二个是接口名称，它用在JavaScript中作为调用Android方法的别名。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class WebAppInterface &#123;</span><br><span class="line">Context mContext;</span><br><span class="line"></span><br><span class="line">/** Instantiate the interface and set the context */</span><br><span class="line">WebAppInterface(Context c) &#123;</span><br><span class="line">mContext = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Show a toast from the web page */</span><br><span class="line">@JavascriptInterface</span><br><span class="line">public void showToast(String toast) &#123;</span><br><span class="line">Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>特别提醒：</strong>如果你的Android目标SDK版本在17或以上，你必须在那些将要在JavaScript中调用的方法体前使用@JavascriptInterface标识。否则，这些方法将不会被调用。</p></blockquote><p>在这个实例中，WebAppInterface允许JavaScript运行showToast方法弹出一个Toast。<br>你可以运行这段代码通过WebView的addJavaScriptInterface()方法，并指定接口的名称为“Android”，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView webView = (WebView) findViewById(R.id.webview);</span><br><span class="line">webView.addJavascriptInterface(new WebAppInterface(this), &quot;Android&quot;);</span><br></pre></td></tr></table></figure></p><p>这段代码为运行在WebView中的JavaScript创建了一个接口“Android”，那么现在你的JavaScript已经有能力访问WebAppInterface中的showToast方法了。下面的HTML和JS代码将调用showToast方法弹出Toast提示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;Say hello&quot; onClick=&quot;showAndroidToast(&apos;Hello Android!&apos;)&quot; /&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function showAndroidToast(toast) &#123;</span><br><span class="line">Android.showToast(toast);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>如你所看到的，在JS中使用“Android”这个接口时，并不需要初始化它，在此之前，WebView已经为你准备好了一些，你只需要通过它调用逻辑即可。</p><blockquote><p><strong>注意：</strong><br>1.WebAppInterface的实例将运行在另一个线程，并不在原来新建它的线程。<br>2.由于通过JS可以调用本地的Android代码，那么我们对于这点要非常的谨慎。对于不受信任的web链接，不应该使用addJavascriptInterface()，除非这个链接是自己本人写的或者其它应该充分信任它的理由。同时，对于不信任的网站，我们在处理它的跳转时应该非常小心，不应该在我们的WebView中直接接受链接的跳转。（默认情况，WebView网页中的链接会跳转到手机的Web浏览器，这是保证安全的前提下一种很好的处理方法。但是，在接下来会提到的serWebViewClient()方法中，你可以自定义链接的行为，这就需要小心了。）</p></blockquote><h1 id="页面导航"><a href="#页面导航" class="headerlink" title="页面导航"></a>页面导航</h1><p>当用户在WebView点击一个链接后，默认的行为是在web浏览器中打开该链接所指向的网页。正如上面所提及的一样，你是可以通过WebView的serWebViewClient方法自定义这个行为的。例如在自己的WebView中展示跳转的内容，而不是跳转到web浏览器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.setWebClient(new WebClient());</span><br></pre></td></tr></table></figure></p><p>当然你还可以做更多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private class MyWebViewClient extends WebViewClient &#123;</span><br><span class="line">@Override</span><br><span class="line">public boolean shouldOverrideUrlLoading(WebView view,String url)&#123;</span><br><span class="line">if (Uri.parse(url).getHost().equals(&quot;www.example.com&quot;)) &#123;</span><br><span class="line">// This is my web site, so do not override; let my WebView load the page</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">// Otherwise, the link is not for a page on my site, so launch another Activity that handles URLs</span><br><span class="line">Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));</span><br><span class="line">startActivity(intent);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后创建MyWebViewClient的实例作为setWebClient()的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.setWebClient(new MyWebViewClient());</span><br></pre></td></tr></table></figure></p><h2 id="导航web的浏览记录"><a href="#导航web的浏览记录" class="headerlink" title="导航web的浏览记录"></a>导航web的浏览记录</h2><p>在WebView中浏览网页时，我们可能会通过web中包含的外链跳转到其它的网页（在同一Webview页面中），那么这些跳转记录是可以来回切换的，这里主要涉及到goBack()和goForward()方法的使用。<br>例如下面的例子，我们通过设备的返回按钮让WebView回退到上一个页面，或者退出当前Activity。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onKeyDown(int keyCode, KeyEvent event) &#123;</span><br><span class="line">    // Check if the key event was the Back button and if there&apos;s history</span><br><span class="line">    if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; myWebView.canGoBack()) &#123;</span><br><span class="line">        myWebView.goBack());</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // If it wasn&apos;t the Back key or there&apos;s no web page history, bubble up to the default</span><br><span class="line">    // system behavior (probably exit the activity)</span><br><span class="line">    return super.onKeyDown(keyCode, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考资料</strong><br><a href="https://developer.android.com/guide/webapps/webview.html#HandlingNavigation" target="_blank" rel="noopener">Building Web Apps in WebView</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你想在将web页面作为APP的一部分，那么我们可以使用WebView。WebView在Android中继承了view类，作为承载网页的控件。但是我们应该知道它并没有继承web浏览器的所有特性，它所实现的也只是展示网页，以及一些基本的交互和监听功能。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="WebView" scheme="http://yoursite.com/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>MD5加密算法</title>
    <link href="http://yoursite.com/2019/12/20/MD5%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/12/20/MD5加密算法/</id>
    <published>2019-12-20T09:19:02.000Z</published>
    <updated>2020-02-26T13:55:57.637Z</updated>
    
    <content type="html"><![CDATA[<p>MD5(Message-Digest Algorithm 5,信息-摘要算法5)用于确保信息传输完整一致，是计算机广泛使用的杂凑算法之一（又译摘要算法，哈希算法）。MD5算法将数据（如汉字）运算成另一固定长度值，MD5的前生有MD2，MD3和MD4。<a id="more"></a><br>MD5算法具有如下特征：<br>1、压缩性：任意长度的数据算出的MD5值是固定的，即128 位固定长度的散列值。<br>2、容易计算：从原数据很容易算出MD5值。<br>3、抗修改性：对原数据任何一个细微的改动，所得到的MD5值都会有很大的不同。<br>4、强抗碰撞：MD5 使用的是散列函数（也称哈希函数），一定概率上也存在哈希冲突（也称哈希碰撞），即多个不同的原数据对应一个相同的 MD5 值。不过，经过 MD4、MD3 等几代算法的优化，MD5 已经充分利用散列的分散性高度避免碰撞的发生。</p><p>可以看出，MD5 是一种不可逆的算法，也就说，你无法通过得到的 MD5 值逆向算出原数据内容。正是凭借这些特点，MD5 被广泛使用。</p><h1 id="MD5的使用场景"><a href="#MD5的使用场景" class="headerlink" title="MD5的使用场景"></a>MD5的使用场景</h1><h4 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h4><p>客户端与服务器的 HTTP 通信，通信双方可以将报文内容做一个 MD5 计算，并将计算所得 MD5 值一并传递给彼此，这样，接收方可以通过对报文内容再次做 MD5 计算得到一个 MD5 值，与传递报文中的 MD5 值做比较，验证数据是否完整，或者是否中途被拦截篡改过。</p><h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4><p>网络云盘中的文件秒传功能也运用到 MD5 算法。服务器存储文件的时候，同时记录每一个文件的 MD5 值，不同文件对应着不同的 MD5 值。这样，遇到用户上传文件时，将上传文件的 MD5 值与服务器上所有存储的 MD5 值做比较，如果相同，则说明用户上传的文件已经在服务器存有。这样，只需要在数据库表中添加一个记录，映射到对应的文件，而不用重复上传，实现所谓秒传的功能。</p><blockquote><p>注意：严格意义上来讲，MD5  并不属于加密算法，也不属于签名算法，而是一种摘要算法，用于数据完整性校验等。</p></blockquote><h1 id="Java-语言中计算-MD5-值的实现方式"><a href="#Java-语言中计算-MD5-值的实现方式" class="headerlink" title="Java 语言中计算 MD5 值的实现方式"></a>Java 语言中计算 MD5 值的实现方式</h1><p><strong>第一步</strong>，获取 MessageDigest 对象，参数为 MD5 字符串，表示这是一个 MD5 算法（其他还有 SHA1 算法等）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</span><br></pre></td></tr></table></figure></p><p><strong>第二步</strong>，输入原数据，参数类型为 byte[] ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5.update(buffer);</span><br></pre></td></tr></table></figure></p><p>注意：update() 方法有点类似 StringBuilder 对象的 append() 方法，采用的是追加模式，属于一个累计更改的过程，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">md5.update(new byte[]&#123;&apos;a&apos;, &apos;b&apos;&#125;);</span><br><span class="line">md5.update(new byte[]&#123;&apos;c&apos;, &apos;d&apos;&#125;);</span><br></pre></td></tr></table></figure></p><p>与<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5.update(new byte[]&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;, &apos;d&apos;&#125;);</span><br></pre></td></tr></table></figure></p><p>是等效的。<br><strong>第三步</strong>，计算 MD5 值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String resultArray = md5.digest();</span><br></pre></td></tr></table></figure></p><p>注意：digest() 方法被调用后，MessageDigest 对象就被重置，也就是说你不能紧接着再次调用该方法计算原数据的 MD5 值。当然，你可以手动调用 reset() 方法重置输入源。<br>digest() 方法返回值是一个字节数组类型的 16 位长度的哈希值，通常，我们会转化为十六进制的 32 位长度的字符串来使用，可以利用 <a href="https://www.jianshu.com/p/8b89ab19db84" target="_blank" rel="noopener">BigInteger</a> 类来做这个转化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bigInt = new BigInteger(1, resultArray);</span><br><span class="line">String resultStr = bigInt.toString(16);</span><br></pre></td></tr></table></figure></p><p>通过这层转换，得到的 MD5 值便是一个长度为 32 位的十六进制字符串，方便使用，类似这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15aa7ec97a6288e46ae865a7211eb4eb</span><br></pre></td></tr></table></figure></p><p>有了上面的基础我们再来看如何将一个文件通过MD5加密转化成32位的十六进制字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static String fileToMD5(String filePath) &#123;</span><br><span class="line">String md5 = null;</span><br><span class="line">MessageDigest digest = null;</span><br><span class="line">try &#123;</span><br><span class="line">digest = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">FileInputStream inputStream = new FileInputStream(filePath);</span><br><span class="line">byte[] b = new byte[1024];</span><br><span class="line">int len = -1;</span><br><span class="line">while ((len = inputStream.read(b)) != -1) &#123;</span><br><span class="line">digest.update(b, 0, len);</span><br><span class="line">&#125;</span><br><span class="line">byte[] bytes = digest.digest();</span><br><span class="line">BigInteger bigInteger = new BigInteger(1, bytes);</span><br><span class="line">md5 = bigInteger.toString(16);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return md5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：文件的大小直接影响字节流的读取速度，间接影响这里 MD5 的计算时长。Java 语言提供有多种方式读取文件，除了上面用到的 FileInputStream 这种顺序读取的 API 类，还有采用随机读取方式的 RandomAccessFile 类等。对于文件读取的效率问题，研究之后再作介绍。</p><hr><p><strong>参考资料</strong><br><a href="http://yifeng.studio/2017/06/13/md5-profile-and-implementation-in-java/" target="_blank" rel="noopener">MD5 简介，及其在 Java 中的实现方式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MD5(Message-Digest Algorithm 5,信息-摘要算法5)用于确保信息传输完整一致，是计算机广泛使用的杂凑算法之一（又译摘要算法，哈希算法）。MD5算法将数据（如汉字）运算成另一固定长度值，MD5的前生有MD2，MD3和MD4。
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="MD5" scheme="http://yoursite.com/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>ConstraintLayout 布局使用指南</title>
    <link href="http://yoursite.com/2019/10/18/ConstraintLayout%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2019/10/18/ConstraintLayout布局使用指南/</id>
    <published>2019-10-17T22:18:40.000Z</published>
    <updated>2020-07-17T04:16:04.328Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是参看了掘金网的<a href="https://juejin.im/entry/5a0f93b4f265da432717ce87" target="_blank" rel="noopener">这篇文章</a>后，对 ConstraintLayout 布局的一个补充说明。<a id="more"></a></p><h2 id="Visibility-behavior"><a href="#Visibility-behavior" class="headerlink" title="Visibility behavior"></a>Visibility behavior</h2><p>ConstraintLayout 对可见行被标记为 GONE 的 View 有特殊的处理方式。下面来谈谈 android:layout_margin 和 app:layout_goneMargin 的区别：<br>1、android:layout_margin 一直有作用，即使目标 View 已经隐藏。<br><img src="/2019/10/18/ConstraintLayout布局使用指南/1.png"><br>2、app:layout_goneMargin 只是在目标 View 隐藏时起作用。<br>同时声明时，后者的优先级大于前者。一般情况下会同时使用这两种属性以达到目标 View 不同显示状态下当前 View 的不同 Margin 效果。</p><h2 id="Virtual-Helpers-objects"><a href="#Virtual-Helpers-objects" class="headerlink" title="Virtual Helpers objects"></a>Virtual Helpers objects</h2><h4 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h4><p>Barrier，直译为障碍、屏障。在约束布局中，可以使用属性 constraint_referenced_ids 来引用多个带约束的组件，从而将它们看作一个整体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">android:id=&quot;@+id/button1&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;100dp&quot;</span><br><span class="line">android:text=&quot;Button1&quot;</span><br><span class="line">app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:id=&quot;@+id/button2&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;200dp&quot;</span><br><span class="line">android:text=&quot;Button2&quot;</span><br><span class="line">app:layout_constraintLeft_toRightOf=&quot;@id/button1&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.constraint.Barrier</span><br><span class="line">android:id=&quot;@+id/barrier1&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">app:barrierDirection=&quot;bottom&quot;</span><br><span class="line">app:constraint_referenced_ids=&quot;button1,button2&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;TextView</span><br><span class="line">android:id=&quot;@+id/bottom_textview&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:text=&quot;stone&quot;</span><br><span class="line">app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toBottomOf=&quot;@id/barrier1&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>上面的 TextView 会在 button1 和 button2 这个整体的下面。如果将 app:constraint_referenced_ids=”button1, button2” 中的 button2 去掉，会发现，TextView 会仅在 button1 的下面。</p><h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><p>组的目的在于（且只能）同时控制多个控件的 Visibility 属性。<strong>但是有以下需要注意的地方。</strong><br>1、单独设置组内控件的 Visibility 无效。<br>2、当有多个组引用了同一个 View ，该 View 的 Visible 属性由最后定义的组决定。</p><h4 id="Layer-Added-in-2-0"><a href="#Layer-Added-in-2-0" class="headerlink" title="Layer(Added in 2.0)"></a>Layer(Added in 2.0)</h4><p>同时需要对一组 View 做统一操作或者需要在 View 集合后面加个背景都可以。同时，他可以实现 Group 的功能。<a href="https://github.com/feng0403/ConstraintLayoutSamples/blob/master/app/src/main/java/cn/feng/constraintlayoutsample/activity/LayerActivity.kt" target="_blank" rel="noopener">实例代码参考&gt;&gt;</a></p><h4 id="Flow-Added-in-2-0"><a href="#Flow-Added-in-2-0" class="headerlink" title="Flow(Added in 2.0)"></a>Flow(Added in 2.0)</h4><p>用引用的方式来避免布局嵌套，代替 LinearLayout 的功能。<a href="https://juejin.im/post/5d0c46246fb9a07ec9561573" target="_blank" rel="noopener">参考链接&gt;&gt;</a></p><h4 id="Placeholder"><a href="#Placeholder" class="headerlink" title="Placeholder"></a>Placeholder</h4><p><a href="https://www.jianshu.com/p/4b23e789befb" target="_blank" rel="noopener">参考地址</a><br>Placeholder （占位符）用于和一个视图关联起来，通过 setContentId() 方法将占位符转换为指定的视图，即视图将在占位符所在位置上显示。当原视图已在 Placeholder 中显示时，原视图将从原有位置消失。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">android:id=&quot;@+id/btn_setContentId&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:onClick=&quot;setContentId&quot;</span><br><span class="line">android:text=&quot;setContentId&quot;</span><br><span class="line">android:textAllCaps=&quot;false&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;ImageView</span><br><span class="line">android:id=&quot;@+id/iv_target&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:src=&quot;@drawable/ic_launcher_background&quot;</span><br><span class="line">app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toBottomOf=&quot;@id/btn_setContentId&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.constraint.Placeholder</span><br><span class="line">android:id=&quot;@+id/placeholder&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Placeholder placeholder = findViewById(R.id.placeholder);</span><br><span class="line">placeholder.setContentId(R.id.iv_target);</span><br></pre></td></tr></table></figure><img src="/2019/10/18/ConstraintLayout布局使用指南/4.webp"><p>此外也可以直接在布局文件中将占位符和视图 ID 绑定在一起<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.constraint.Placeholder</span><br><span class="line">android:id=&quot;@+id/placeholder&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">app:content=&quot;@id/iv_target&quot;</span><br><span class="line">app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br></pre></td></tr></table></figure></p><h2 id="ConstrainSet"><a href="#ConstrainSet" class="headerlink" title="ConstrainSet"></a>ConstrainSet</h2><p>动态修改布局，<a href="https://juejin.im/post/5b503fb2e51d45191d79ee30" target="_blank" rel="noopener">参考链接&gt;&gt;</a></p><blockquote><p>防止布局中有无 id 控件，可以设置 isForceId = false 。</p></blockquote><h2 id="循环定位"><a href="#循环定位" class="headerlink" title="循环定位"></a>循环定位</h2><p>一个小部件的中心可以以一定角度和距离限制相对于另一个小部件的中心。这允许你将一个小部件放在一个圆上。可以使用以下属性：<br>1、layout_constraintCircle ：引用另一个小部件ID<br>2、layout_constraintCircleRadius ：到其他小部件中心的距离<br>3、layout_constraintCircleAngle ：小部件应处于的角度（度数，从0到360）</p><img src="/2019/10/18/ConstraintLayout布局使用指南/2.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">android:id=&quot;@+id/bt_1&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:id=&quot;@+id/bt_2&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">app:layout_constraintCircle=&quot;@+id/bt_1&quot;</span><br><span class="line">app:layout_constraintCircleAngle=&quot;45&quot;</span><br><span class="line">app:layout_constraintCircleRadius=&quot;100dp&quot; /&gt;</span><br></pre></td></tr></table></figure><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p><a href="https://developer.android.google.cn/reference/android/support/constraint/Group" target="_blank" rel="noopener">参考官方文档&gt;&gt;</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是参看了掘金网的&lt;a href=&quot;https://juejin.im/entry/5a0f93b4f265da432717ce87&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;后，对 ConstraintLayout 布局的一个补充说明。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="ConstraintLayout" scheme="http://yoursite.com/tags/ConstraintLayout/"/>
    
  </entry>
  
  <entry>
    <title>Android 问题汇总（进行中...）</title>
    <link href="http://yoursite.com/2019/09/18/Android%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/09/18/Android问题汇总和解决方案/</id>
    <published>2019-09-18T11:29:11.000Z</published>
    <updated>2020-02-10T07:51:08.311Z</updated>
    
    <content type="html"><![CDATA[<p>本文将长期记录并解答笔者在 Android 开发过程中所遇到的问题，这些问题一般是几句话就能概括并且不需要单独成文讲解的。<a id="more"></a></p><h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><p><strong>1、Host 这个 Header的作用是？</strong><br>答：仅用于找到目标主机后确认子主机的域名和端口。<br>解释：Host表示服务器主机地址，这个地址是子主机的地址，或者说是子主机的域名（也可以是IP地址）。<br><a href="https://blog.csdn.net/netdxy/article/details/51195560" target="_blank" rel="noopener">参考地址&gt;&gt;</a><br><strong>2、Host 为什么不放在请求行和 Path 一起拼凑使用，而是单独作为 Header ？</strong><br>答：请求行中的 Path 是给子主机确定访问路径用的，而 Host 是给主主机确认访问的子主机用的。两个的用途不一样，前者给子主机用，后者给主主机用。<br><strong>3、Http 协议中主主机的 IP 地址是何时确定的？</strong><br>答：是在 Http 请求发送之前通过DNS域名解析后确定的。<br><strong>4、当一个 Java 集合（如：HashMap）的 key 是类类型时， 为什么重写了类的 equals() 方法，还要重写 hashCode() 方法？</strong><br>答：因为如果只重写了 equals 方法，两个对象 equals 返回了true，但是如果没有重写 hashCode 方法，集合还是会插入元素。这样集合中就出现了重复元素了。<br><a href="https://zhuanlan.zhihu.com/p/30321358" target="_blank" rel="noopener">参考地址&gt;&gt;</a><br><strong>5、什么是编码？</strong><br>答：把数据从一种格式转换成另一种格式（可能是同一种格式），它是可逆的，它的逆向过程叫做解码。<br><strong>6、什么是对象序列化？</strong><br>答：把数据对象（一般是内存种的，例如JVM中的对象）转换成字节序列的过程。对象在程序内存里的存放形式是散乱的（存放在不同的内存区域、并且由引用进行连接），通过序列化可以把内存中的对象转换成一个字节序列，从而可使用byte[]等形式进行本地存储或网络传输，在需要的时候重新组装（反序列化）来使用。<br><strong>7、序列化和编码的区别</strong><br>答：编码是把数据由一种数据格式转换成另一种数据格式；而序列化是把数据由内存中的对象（而不是某种具体的格式）转换成字节序列。<br><strong>8、非对称加密和数字签名在加密通信中如何配合使用？</strong><br>答：使用非对称加密通信，可以在不可信网络上将双方的公钥传给对方，然后在发消息前分别对消息使用对方的公钥来加密和使用自己的私钥来签名，做到不可信网络上的可靠密钥传播及加密通信。<br>知识拓展：签名是对原数据的 hash 值进行签名，而不是直接对原数据进行签名。这样做是为了减小数据的传输体积。<br><strong>9、TCP/IP协议族、HTTP协议、TCP协议、UDP协议、IP协议、Socket之间的关系？</strong><br><a href="https://www.jianshu.com/p/a5410f895d6b" target="_blank" rel="noopener">参考文章</a><br>Ⅰ、TCP/IP协议族是一个网络通信模型，为互联网的基础通信架构，它并不只是包含TCP协议和IP协议，只是因为这两个协议很重要，所以才用它们来命名。通常TCP/IP协议族被分为四层：应用层（HTTP协议）、传输层（TCP协议 | UDP协议）、网络层（IP协议）、数据链路层（以太网协议等）。<br>Ⅱ、HTTP连接是基于TCP协议的可靠传输协议，同时也是请求响应模式且无状态的协议。（Http 1.1 之后可以通过设置 Keep-Alive请求头将 Http 转变成长连接模式，所以此时的 Http 是有状态的。）<br>Ⅲ、Socket连接既可以基于TCP协议，也可以基于UDP协议。前者每次建立连接都要执行TCP的三次握手过程，每次断开连接都要执行四次挥手过程。后者没有三次握手和四次挥手的过程。<br>Ⅳ、TCP协议（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来，同时，结束对话也需要四次挥手过程。<br>V、UDP协议（User Data Protocol，用户数据报协议）在传输数据时不建立连接，因此也就不需要维护连接状态。UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。<br>Ⅵ、总结一下就是，TCP/IP协议族是一个总称，它包含了HTTP协议、TCP协议、UDP协议、IP协议。TCP协议、UDP协议是两种不同的传输层协议。Socket是一个为了便于使用  TCP/UDP 而提供的API接口规范，而Http是一个应用层协议，Http的下一层基于TCP协议，它和Socket没有联系。在 Http 连接中，只有客户端发起请求后服务端才会响应，服务端是无法主动向客户端发消息的，而Socket连接中，通信双方发送消息并没有先后的限制，通信双方中的任何一方可以随时向另一方发送消息。最后，笔者也认为既然 Socket 是一个对传输层协议的接口封装，而传输层的上个步骤是来自于应用层的（这里就是Http协议了），所以可以说 Sockect 的实现是依赖于上层http协议的。（应用层协议还有一个WebSocke协议支持双向主动发送消息给对方，它和 Http协议 的区别可以参考<a href="https://github.com/onlyliuxin/coding2017/issues/497" target="_blank" rel="noopener">这个链接</a>）<br><strong>10、HMAC 是什么 以及 Https 建立连接过程中产生的 mac secrete 有什么用？</strong><br>关于 HMAC 的定义可以看<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1183198304823296" target="_blank" rel="noopener">这篇文章</a>，所以我得到结论是 HMAC 不仅可以验证数据的完整性，同时还能保证数据来自于可信的对象（加大破解难度）。而 mac  secrete 实际上充当了 HMAC 计算过程中的 key 。</p><h1 id="自定义-View-相关"><a href="#自定义-View-相关" class="headerlink" title="自定义 View 相关"></a>自定义 View 相关</h1><p><strong>1、canvas 中 save（）和 saveLayer（）区别</strong><br><a href="https://blog.csdn.net/lijiuche/article/details/53467844" target="_blank" rel="noopener">参考链接&gt;&gt;</a><br><strong>2、自定义 View 时拿到 View 属性值的两种方式</strong><br>方式一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TypedArray typedArray =context.obtainStyledAttributes(attrs,控件在 R.styleable.styleable 文件中的命名【随意】);</span><br><span class="line">typedArray.getXXX(R.styleable.styleable文件中的控件名称_控件属性名, defaultValue);</span><br></pre></td></tr></table></figure></p><p>方式二<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TypedArray typedArray =context.obtainStyledAttributes(attrs,由控件属性组成的数组【如&#123;android.R.attr.layout_width,R.attr.***&#125;】);</span><br><span class="line">typedArray.getXXX(属性在数组中的引索, defaultValue);</span><br></pre></td></tr></table></figure></p><p>注意，对于方式二，obtainStyledAttributes 的第二个参数必须是由组成该控件的属性生成的数组，可以是系统自带的，如：android.R.attr.layout_width，也可以是在 styleable 文件自定义的属性，如：R.attr.<strong>*。</strong>3、Android 动画选择问题**<br>优先考虑使用属性动画、View 动画、或者他们的衍生版本动画。如果实现起来复杂，才考虑使用<a href="https://kimball325.github.io/2019/07/29/%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/" target="_blank" rel="noopener">过渡动画</a>或 <a href="https://juejin.im/post/5d595328f265da03c34bfa59" target="_blank" rel="noopener">MotionLayout 动画</a>。</p><blockquote><p>注意：过渡动画使用<code>TransitionManager#go()</code>方式时，需要重新绑定数据（因为 View 会被重新添加），<code>TransitionManager#beginDelayedTransition()</code>方式和 MotionLayout 动画不需要重新绑定数据。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将长期记录并解答笔者在 Android 开发过程中所遇到的问题，这些问题一般是几句话就能概括并且不需要单独成文讲解的。
    
    </summary>
    
      <category term="Android 其它" scheme="http://yoursite.com/categories/Android-%E5%85%B6%E5%AE%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Kotlin 使用笔记（进行中...）</title>
    <link href="http://yoursite.com/2019/08/28/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/08/28/Kotlin学习笔记/</id>
    <published>2019-08-28T04:08:10.000Z</published>
    <updated>2020-03-06T05:37:54.329Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章将长期记录并解答笔者在学习使用 Kotlin 过程中所遇到的问题点，参考资料会以 <code>扔物线</code> 老师的 <a href="https://kaixue.io" target="_blank" rel="noopener">码上开学系列教程</a> 和 <a href="https://www.kotlincn.net/docs/reference/whatsnew13.html" target="_blank" rel="noopener">Kotlin 官方教程</a> 为主，同时也会配合参考其他优秀文章。<a id="more"></a></p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>Java 的单例模式通常实现起来稍显繁琐，包含大量的模板代码，具体使用可参考<a href="https://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">这篇文章</a>。<br>而 Kotlin 实现单例模式是非常便捷的，只需使用 <code>object</code> 关键字即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 👇 class 替换成了 object</span><br><span class="line">object A &#123;</span><br><span class="line">    val number: Int = 1</span><br><span class="line">    fun method() &#123;</span><br><span class="line">        println(&quot;A.method()&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 Android studio 转换工具将上面代码转成 Java 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final class A &#123;</span><br><span class="line">   private static final int number = 1;</span><br><span class="line">   public static final A INSTANCE;</span><br><span class="line"></span><br><span class="line">   public final int getNumber() &#123;</span><br><span class="line">      return number;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final void method() &#123;</span><br><span class="line">      String var1 = &quot;A.method()&quot;;</span><br><span class="line">      boolean var2 = false;</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      A var0 = new A();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">      number = 1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，实际上这种通过 <code>object</code> 实现的单例是一个饿汉式的单例，并且实现了线程安全。</p><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>Java 一共有四大代码块，可参考<a href="https://juejin.im/entry/5876f05a2f301e005772fb07" target="_blank" rel="noopener">这篇文章</a>，需要注意的是，文章中最后提到的同步代码块中对静态代码块的解释有误，如果要了解 java 中的同步代码块知识，可以移步到笔者之前写的<a href="https://kimball325.github.io/2016/12/18/Java并发编程-Synchronized/" target="_blank" rel="noopener">这篇文章</a>。<br>Kotlin 中的构造代码块和静态代码块有了一些变化，先来看构造代码块。<br>Java 是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        // 初始化代码块，先于下面的构造器执行</span><br><span class="line">    &#125;</span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而 Kotlin 是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        // 初始化代码块，先于下面的构造器执行</span><br><span class="line">    &#125;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于静态代码块， Java 是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Sample &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而 Kotlin 是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Sample &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        init &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="访问限制符"><a href="#访问限制符" class="headerlink" title="访问限制符"></a>访问限制符</h4><p>Java 的访问限制符可以参考<a href="https://www.runoob.com/java/java-modifier-types.html#protected-desc" target="_blank" rel="noopener">这篇文章</a>访问控制修饰符部分。其中，如下几个知识点需要注意一下：</p><blockquote><p>1、<strong>子类与基类在同一包中</strong>：被声明为 protected 或 default 的变量、方法和构造器能被同一个包中的任何其他类访问。<br>2、<strong>子类与基类不在同一包中</strong>：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的 protected 方法。同时，在子类中既不能访问其从基类继承而来的 default 方法，也不能访问基类实例的 default 方法。（变量、构造器同理。）<br>3、子类可以对从父类继承的方法加宽访问范围。访问控制符的访问范围有大到小排序是：public &gt; protect &gt;  default &gt; private。</p></blockquote><p>对于Kotlin的访问控制符，直接参考码上开学吧。</p><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>首先我们来看使用内联函数的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline fun log() &#123;</span><br><span class="line">    println(&quot;log1&quot;)</span><br><span class="line">    println(&quot;log2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    log()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反编译成 Java 的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static final void log() &#123;</span><br><span class="line">     String var1 = &quot;log1&quot;;</span><br><span class="line">     System.out.println(var1);</span><br><span class="line">     var1 = &quot;log2&quot;;</span><br><span class="line">     System.out.println(var1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">     Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">     String var1 = &quot;log1&quot;;</span><br><span class="line">     System.out.println(var1);</span><br><span class="line">     var1 = &quot;log2&quot;;</span><br><span class="line">     System.out.println(var1);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>而我们去掉 inline 关键字后，再反编译成 Java 代码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static final void log() &#123;</span><br><span class="line">    String var0 = &quot;log1&quot;;</span><br><span class="line">    System.out.println(var0);</span><br><span class="line">    var0 = &quot;log2&quot;;</span><br><span class="line">    System.out.println(var0);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">    Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">    log();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>如上可以看到，使用内联函数可以减少一层函数的调用栈，但如果有多个地方调用内联函数的话，就会隐式地增加编译后代码的行数。那么如果正确使用内联函数呢，或者说它到底有什么用？有如下几个使用场景：</p><p>1、函数参数包含函数类型的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class View &#123;</span><br><span class="line">    inline fun setOnClickListener(listener: (View) -&gt; Unit) &#123;</span><br><span class="line">        listener(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果不使用内联函数，由于 setOnClickListener 使用的是函数类型的参数，那么在调用时会产生一个额外的对象，具体的过程可以反编译成 Java 文件后看看。</p><p>2、泛型具体化。<br>平时我们使用泛型时，是不能直接对泛型类型进行操作的。比如下面的操作会导致编译不通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; excute() &#123;</span><br><span class="line">    func(T::class.java) //编译器报错：Cannot use &apos;T&apos; as reified type parameter. Use a class instead.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大意是：不能使用泛型 T 作为具体的类型参数。如果依照 Java 的解决方式，可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; excute(class: Class&lt;T&gt;) &#123;</span><br><span class="line">    func(class)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过， Kotlin 中有更加方便的用法，也就是使用 inline 关键字达到让泛型具体化的目标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;reified T&gt; excute() &#123;</span><br><span class="line">    func(T::class.java)</span><br><span class="line">&#125;</span><br><span class="line">//PS：使用时还需在泛型声明前加上 refied 关键字，才能让泛型真正具体化。</span><br></pre></td></tr></table></figure></p><blockquote><p>Retrofit 最新拓展中，内部已经实现了一个内联函数用来代替旧版本创建实例的方式。具体可参考 <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit2/KotlinExtensions.kt" target="_blank" rel="noopener">Retrofit.create()</a> 拓展方法。</p></blockquote><h4 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h4><p><a href="https://www.runoob.com/kotlin/kotlin-delegated.html" target="_blank" rel="noopener">参考地址&gt;&gt;</a><br>上面的文章中，笔者认为只需要理解从开篇到“把属性储存在映射中”部分的内容，剩下的内容读者自行斟酌其重要性吧。</p><h4 id="构造器执行顺序"><a href="#构造器执行顺序" class="headerlink" title="构造器执行顺序"></a>构造器执行顺序</h4><p>Kotlin 的构造器执行顺序和 Java 一致，可参考<a href="https://blog.csdn.net/IBLiplus/article/details/81192986" target="_blank" rel="noopener">这篇文章&gt;&gt;</a></p><h4 id="作用域函数-with"><a href="#作用域函数-with" class="headerlink" title="作用域函数 with"></a>作用域函数 with</h4><p>‘with’最大的作用是可以返回任何对象，这是其它几个作用域函数不能实现的。<a href="https://www.kotlincn.net/docs/reference/scope-functions.html#with" target="_blank" rel="noopener">官方详解&gt;&gt;</a></p><h4 id="lambda表达式、匿名函数以及函数类型三者之间的联系与区别"><a href="#lambda表达式、匿名函数以及函数类型三者之间的联系与区别" class="headerlink" title="lambda表达式、匿名函数以及函数类型三者之间的联系与区别"></a>lambda表达式、匿名函数以及函数类型三者之间的联系与区别</h4><p><a href="https://www.kotlincn.net/docs/reference/lambdas.html#lambda-表达式与匿名函数" target="_blank" rel="noopener">官方文档参考&gt;&gt;</a></p><h4 id="理解「带接收者类型的函数类型-」"><a href="#理解「带接收者类型的函数类型-」" class="headerlink" title="理解「带接收者类型的函数类型 」"></a>理解「带接收者类型的函数类型 」</h4><p>概念：<a href="https://www.kotlincn.net/docs/reference/lambdas.html#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%B8%8E-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">官方文档（只需看相关的）&gt;&gt;</a><br>实践（来自 Android KTX Core）：<a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:core/core-ktx/src/main/java/androidx/core/content/SharedPreferences.kt;l=20?q=SharedPreferences&amp;ss=androidx" target="_blank" rel="noopener">SharedPreferences 源码&gt;&gt;</a></p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>其实闭包并不是 Kotlin 中的新概念，在 Java 8 中就已经支持。我们以 Thread 为例，来看看什么是闭包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 Thread 的完整写法</span><br><span class="line">Thread(object : Runnable &#123;</span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">​</span><br><span class="line">// Runnable 是函数式接口，可以使用 lambda 表达式简化为</span><br><span class="line">Thread(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br><span class="line">​</span><br><span class="line">// 使用闭包原则，再简化为</span><br><span class="line">Thread &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>形如 Thread {…} 这样的结构中 {} 就是一个<strong>闭包</strong>。</p><p>在 Kotlin 中有这样一个语法糖：当函数的最后一个参数是 lambda 表达式时（又名：拖尾 lambda 表达式），可以将 lambda 写在括号外。这就是它的<strong>闭包原则</strong>。</p><p>在这里需要一个类型为 Runnable 的参数，而 Runnable 是一个 Java 接口，且只定义了一个函数 run，这种情况可以转换成传递一个 lambda 表达式（第二段），因为是最后一个参数，根据闭包原则我们就可以直接写成 Thread {…}（第三段） 的形式。</p><blockquote><p><strong>注意</strong>:<br>Kotlin 对于“函数式接口可以使用 lambda 表达式”这个用法仅仅是针对接口是 Java 类型的情况，如果接口是 Kotlin 写的，则在 Kotlin 中调用以接口作为参数的方法时必须通过关键字’object’创建匿名类的对象来作为其参数。</p></blockquote><p><a href="https://kaixue.io/kotlin-coroutines-1/" target="_blank" rel="noopener">参考链接&gt;&gt;</a></p><h4 id="平台类型"><a href="#平台类型" class="headerlink" title="平台类型"></a>平台类型</h4><p>在 kotlin 中使用其他平台（如：Java）的类型时，如果该类型未用可空性注解标注，则 Kotlin 会自动将这其解释成平台类型。</p><p>在类型后面加上一个感叹号的类型就是平台类型，平台类型不能手动声明。</p><p>Kotlin 对平台类型的空检测会放宽， 因此它们的安全保证与在 Java 中相同，即要空检查。</p><p><a href="https://www.kotlincn.net/docs/reference/java-interop.html#%E7%A9%BA%E5%AE%89%E5%85%A8%E4%B8%8E%E5%B9%B3%E5%8F%B0%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">官方文档（看到可空性注解）&gt;&gt;</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章将长期记录并解答笔者在学习使用 Kotlin 过程中所遇到的问题点，参考资料会以 &lt;code&gt;扔物线&lt;/code&gt; 老师的 &lt;a href=&quot;https://kaixue.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;码上开学系列教程&lt;/a&gt; 和 &lt;a href=&quot;https://www.kotlincn.net/docs/reference/whatsnew13.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kotlin 官方教程&lt;/a&gt; 为主，同时也会配合参考其他优秀文章。
    
    </summary>
    
      <category term="Android 其它" scheme="http://yoursite.com/categories/Android-%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android动画（七）：过渡动画</title>
    <link href="http://yoursite.com/2019/07/29/%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/07/29/过渡动画/</id>
    <published>2019-07-29T14:11:15.000Z</published>
    <updated>2019-10-14T22:12:45.084Z</updated>
    
    <content type="html"><![CDATA[<p>笔者已将本节的代码上传至 <a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">Github</a>，大家可以结合着学习。<a id="more"></a><br>Android 4.4.2 (API level 19) 引入了 Transition 框架，支持场景过渡效果，到了A ndroid 5.0（API level 21） 开始支持 Activity 过渡动画。相对于视图动画或属性动画，Transition 动画更具特殊性，Transition 可以看作对属性动画的高度封装。为了对 Transition 有一个大体的了解，我们从 Scene Transition(场景过渡动画)、Activity 过渡动画之 Content Transition、Activity 过渡动画之 Shared Element Transition 这三个方面来做概述。</p><h3 id="场景过渡动画：Scene-Transition"><a href="#场景过渡动画：Scene-Transition" class="headerlink" title="场景过渡动画：Scene Transition"></a>场景过渡动画：Scene Transition</h3><p>场景过渡动画是指以动画的形式实现View两个场景的切换(从一个场景切换到另一个场景)。而且在切换过程中通过 Transition 来设置不同的过渡动画效果。<br>场景过渡动画中有三个特别关键概念：Scene（场景），Transition（过渡动画），TransitionManager（管理）。</p><p>1、Scene：Scene 代表一个场景。Scene 保存了一个视图层级结构，包括它所有的 views 以及 views 的状态，通常由 getSceneForLayout (ViewGroup sceneRoot,int layoutId,Context context)获取 Scene 实例。Transition 框架可以实现在 starting scene 和 ending scene 之间执行动画。而且大多数情况下，我们不需要创建 starting scene，因为 starting scene 通常由当前UI状态决定，我们只需要创建 ending scene。</p><p>2、Transition：Transiton 则是用来设置过渡动画效果用的。而且系统给提供了一些非常有用的 Transtion 动画效果，如下表所示:</p><table><thead><tr><th>系统Transition</th><th>解释</th></tr></thead><tbody><tr><td>ChangeBounds</td><td>检测 View 的位置边界创建移动和大小变化动画(关注布局边界的变化，不关注 scale 引起的布局边界变化)</td></tr><tr><td>ChangeTransform</td><td>检测 View 的 scale 和 rotation 创建缩放和旋转动画(关注 scale 和 ratation 的变化)</td></tr><tr><td>ChangeClipBounds</td><td>检测 View 的剪切区域的位置边界，和 ChangeBounds 类似。不过 ChangeBounds 针对的是 view 而 ChangeClipBounds 针对的是 view 的剪切区域 rect 的变化，（关注 setClipBounds(Rect rect) 中 rect 的变化）</td></tr><tr><td>ChangeImageTransform</td><td>检测 ImageView 的 ScaleType，并创建相应动画(关注的是 ImageView 的 scaleType)</td></tr><tr><td>Fade</td><td>根据 View 的 visibility状态的的不同创建淡入淡动画,调整的是透明度(关注的是 View 的 visibility 的状态)</td></tr><tr><td>Slide</td><td>根据 View 的 visibility 状态的的不同创建滑动动画(关注的是 View 的 visibility 的状态)</td></tr><tr><td>Explode</td><td>根据 View 的 visibility 状态的的不同创建分解动画(关注的是 View 的 visibility 的状态)</td></tr><tr><td>AutoTransition</td><td>默认动画，ChangeBounds、Fade 动画的集合</td></tr></tbody></table><blockquote><p><strong>PathMotion</strong><br>Transition 的辅助工具，以 path 的方式指定过渡效果，两个具体实现类 ArcMotion 和 PatternPathMotion，效果类似于之前讲过的路径动画。<a href="http://rkhcy.github.io/2017/09/21/TransitionNote/" target="_blank" rel="noopener">参考链接&gt;&gt;</a></p></blockquote><p>3、TransitionManager<br>TransitionManager 用于将 Scene 和 Transition 联系起来，它提供了一系列的方法，如：go(Scene scene, Transition transition)，到指定的场景所使用的过渡动画是什么，beginDelayedTransition(ViewGroup sceneRoot, Transition transition)，在当前场景到下一帧的过渡效果是什么。</p><p>我们在使用场景过渡动画时，有两种实现方式。<br>1、TransitionManager.go方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">//定义开始场景、结束场景。</span><br><span class="line">mSceneStart = Scene.getSceneForLayout(sceneRootView, R.layout.scene_start, context);</span><br><span class="line">mSceneEnd = Scene.getSceneForLayout(sceneRootView, R.layout.scene_end, context);</span><br><span class="line">//开始场景过渡动画。其中&quot;transition&quot;参数可以通过代码生成，如：new AutoTransition()。也可以是引用xml文件，如：TransitionInflater.from(this).inflateTransition(R.transition.xxx)。</span><br><span class="line">TransitionManager.go(mSceneEnd,transition);</span><br></pre></td></tr></table></figure></p><p>2、beginDelayedTransition方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TransitionManager.beginDelayedTransition(sceneRootView,transition);</span><br><span class="line">//下面改变 sceneRootView 中子 View 的属性，如：位置，缩放比例等。</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>beginDelayedTransition 的方式是不是会让你联想到之前讲过的 LayoutTransition 动画呢？它们之间的区别可以这么理解：LayoutTransition针对的是各个控件在限定场景到达时的动画表现。而beginDelayedTransition针对的是不同的场景之间的切换动画。前者关注的是控件（微观），后者关注的是场景（宏观）。<br>除了使用系统自带的 Transtion 使用动画以外，我们还可以自定义 Transition 动画，具体可参考<a href="https://developer.android.com/training/transitions/custom-transitions" target="_blank" rel="noopener">官方的这篇文章</a>。或者直接看官方给的<a href="https://github.com/googlesamples/android-CustomTransition" target="_blank" rel="noopener">DEMO</a>。</p><h5 id="使用场景过渡动画需要注意的点："><a href="#使用场景过渡动画需要注意的点：" class="headerlink" title="使用场景过渡动画需要注意的点："></a>使用场景过渡动画需要注意的点：</h5><p>1、Android 版本在 4.0(API Level 14) 到 4.4.2(API Level 19) 使用 Android Support Library，但是Activity过渡动画和共享元素过渡动画至少要Android 5.0版本才支持。<br>2、对于 SurfaceView 可能不起效果，因为 SurfaceView 的实例是在非 UI 线程更新的，因此会造成和其他视图动画不同步。<br>3、某些特定的转换类型在应用到 TextureView 时可能不会产生所需的动画效果。<br>4、继承自 AdapterView 的视图如：ListView，与该框架不兼容。RecycleView 兼容该框架，不过由于 RecycleView 复用机制的存在，这里就会存在两个动画：一个进入、一个退出，所以如果不满足需求，还是老实用 ItemAnimator 吧。（PS：后面再写篇文章详细介绍 RecycleView。）<br>5、不要对包含文本的视图的大小进行动画。(这里所指的大小改变主要包括直接改变视图的宽高或者通过 setTextSize 改变视图的大小，不包括 scale 引起的视图大小变化。)<br>6、默认情况下，sceneRoot 下所有的 View 都会执行 Transition 动画，我们可以通过 Transition.addTarget 和 removeTarget 方法选择性添加或移除执行动画的 View 。需要注意的是，Transition 的 removeTarget 方法必须在已经使用了 addTarget的前提下才有效果。在未使用 addTarget 的情况下，如果要排除某个 View 执行动画效果，可以使用 Transition 的 excludeTarget 替代 removeTarget 方法。<br><strong>本节参考资料:</strong><br><a href="https://developer.android.com/training/transitions" target="_blank" rel="noopener">1、Animate layout changes using a transition</a><br><a href="http://rkhcy.github.io/2017/09/21/TransitionNote/" target="_blank" rel="noopener">2、Android Transition（一）</a><br><a href="https://blog.csdn.net/wuyuxing24/article/details/78857912" target="_blank" rel="noopener">3、Android Transition（Android过渡动画）</a></p><h3 id="Activity过渡动画：Content-Transition、Shared-Element-Transition"><a href="#Activity过渡动画：Content-Transition、Shared-Element-Transition" class="headerlink" title="Activity过渡动画：Content Transition、Shared Element Transition"></a>Activity过渡动画：Content Transition、Shared Element Transition</h3><p>官方参考文档：<a href="https://developer.android.com/training/transitions/start-activity" target="_blank" rel="noopener">Start an activity using an animation</a><br>中文参考文档：<a href="https://juejin.im/post/59cc54825188257a73280214" target="_blank" rel="noopener">Activity 过渡动画</a></p><h5 id="对于共享元素的延迟加载"><a href="#对于共享元素的延迟加载" class="headerlink" title="对于共享元素的延迟加载"></a>对于共享元素的延迟加载</h5><p>如果共享元素在被调用的 Activity 需要通过 AsyncTask, Loader, 或其它类似的数据加载方式决定它们最终的表现，数据被分发返回到主线程之前框架是可以开始过渡的。<br>为了解决这个问题，Activity Transitions API 提供了一个方法暂时推迟过渡直到我们确切地知道共享元素已经被适当的渲染和放置。<br>为了从开始时暂时阻止共享元素过渡，调用 postponeEnterTransition()（API &gt;= 21）或 supportPostponeEnterTransition()（API &lt; 21）在你被调用的 Activity 中的 onCreate() 方法中。然后，当你知道所有共享元素已经被适当的摆放和大小时，调用 startPostponedEnterTransition()（API &gt;= 21）或supportStartPostponedEnterTransition()（API &lt; 21） 恢复过渡。<br>你会找到一个常见的处理模式是在 OnPreDrawListener 中开启延迟过渡，它将会在共享元素被渲染和放置后调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ... load remote image with Glide/Picasso here</span><br><span class="line">supportPostponeEnterTransition();</span><br><span class="line">ivBackdrop.getViewTreeObserver().addOnPreDrawListener(</span><br><span class="line">    new ViewTreeObserver.OnPreDrawListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean onPreDraw() &#123;</span><br><span class="line">            ivBackdrop.getViewTreeObserver().removeOnPreDrawListener(this);</span><br><span class="line">            supportStartPostponedEnterTransition();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>需要记住的是，一定要在共享元素被渲染和放置后调用<code>startPostponedEnterTransition</code>方法，否者被调用的 Activity 会一直被堵塞。<br><a href="https://yuweiguocn.github.io/shared-element-activity-transition/" target="_blank" rel="noopener">参考文章&gt;&gt;</a></p><h5 id="ViewOverlay-补充"><a href="#ViewOverlay-补充" class="headerlink" title="ViewOverlay 补充"></a>ViewOverlay 补充</h5><p><code>ViewOverlay</code>可以实现跨ViewGroup的动画，参考Demo中的<a href="https://github.com/tangxianming/AnimationPracticeApplication/blob/master/app/src/main/java/com/txm/topcodes/animationpracticeapplication/activity/OverlayActivity.java" target="_blank" rel="noopener">OverlayActivity类</a>，有如下要的：<br>1、动画完成后一定要记得在目标 ViewGroup Overlay 移除当前的View。<br>2、被添加到目标 ViewGroup Overlay 中的 View，无法响应点击事件。</p><h5 id="Activity-过渡动画需要注意的点："><a href="#Activity-过渡动画需要注意的点：" class="headerlink" title="Activity 过渡动画需要注意的点："></a>Activity 过渡动画需要注意的点：</h5><p>1、对于非共享元素过渡动画，一些国内机型在开启 windowAllowEnterTransitionOverlap 后，如果 ExitTransition 设置的转场时间过长，则会出现返回页面时无法恢复原来状态的问题。<br>使用经验：如果需要启动页也有动画效果的话，不能将动画时长设置过长，同时要结合多个机型测试一下。另外，不设置 ExitTransition 动画效果不会有问题。<br>2、一些国内机型跳转目标页时，即使使用了 excludeTarget(android.R.id.statusBarBackground, true) 方法排除状态栏参与动画，状态栏背景仍会出现颜色切换现象（颜色为目标页面背景色）。<a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">解决方案请参考Demo&gt;&gt;</a><br>3、使用 Fragment 的 Transition 实现界面过渡可完美避免出现上述问题。 <a href="https://github.com/lgvalle/Material-Animations" target="_blank" rel="noopener">参考项目&gt;&gt;</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者已将本节的代码上传至 &lt;a href=&quot;https://github.com/tangxianming/AnimationPracticeApplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，大家可以结合着学习。
    
    </summary>
    
      <category term="Android动画基础" scheme="http://yoursite.com/categories/Android%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Scene Transition" scheme="http://yoursite.com/tags/Scene-Transition/"/>
    
      <category term="Content Transition" scheme="http://yoursite.com/tags/Content-Transition/"/>
    
      <category term="Shared Element Transition" scheme="http://yoursite.com/tags/Shared-Element-Transition/"/>
    
  </entry>
  
  <entry>
    <title>Android动画（六）：布局动画</title>
    <link href="http://yoursite.com/2019/07/21/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8006%EF%BC%9A%E5%B8%83%E5%B1%80%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/07/21/动画基础06：布局动画/</id>
    <published>2019-07-21T04:00:05.000Z</published>
    <updated>2019-10-17T22:36:51.387Z</updated>
    
    <content type="html"><![CDATA[<p>笔者已将本节的代码上传至 <a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">Github</a>，大家可以结合着学习。<br>在 Android 的动画体系中，有补间动画，帧动画和属性动画，但是这些动画都是针对单个对象的，如果想对 ViewGroup 作动画，就要用到布局动画了。布局动画一共有两种：LayoutAnimation 和 LayoutTransition，本文将逐一介绍他们的用法和区别。<a id="more"></a></p><h3 id="LayoutAnimation"><a href="#LayoutAnimation" class="headerlink" title="LayoutAnimation"></a>LayoutAnimation</h3><p>LayoutAnimation 布局动画属于补间动画的一种，利用它可以快速实现对 ViewGroup 中子 view 的动画。不过，它的缺陷是只能够在 ViewGroup 初始化时对其子 view 产生动画效果，之后再增加子 view 时没有效果。<br>LayoutAnimation 动画可以直接在 xml 中定义：<br>1、首先定义单个 View 的补间动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;500&quot;&gt;</span><br><span class="line">  &lt;translate</span><br><span class="line">      android:fromXDelta=&quot;-50%p&quot;</span><br><span class="line">      android:toXDelta=&quot;0&quot;/&gt;</span><br><span class="line">  &lt;alpha</span><br><span class="line">      android:fromAlpha=&quot;0.0&quot;</span><br><span class="line">      android:toAlpha=&quot;1.0&quot;/&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p><p>2、定义 layoutAnimation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layoutAnimation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:animation=&quot;@anim/slide_in_from_left&quot;</span><br><span class="line">    android:animationOrder=&quot;random&quot;</span><br><span class="line">    android:delay=&quot;1&quot;/&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">1、delay : ViewGroup 中单个Item动画的开始延时，取值是android:animation 所指定动画时长的倍数，可以是float，也可以是百分数，默认0.5</span><br><span class="line">比如slide_in_from_left中定义的动画时长是500ms，这里delay=1，那么在上一个动画执行之后延时500ms执行下一个item的动画</span><br><span class="line">2、animationOrder : 动画开始顺序，normal(正序)、reverse(倒序)、random(随机)</span><br><span class="line">3、animation : 指定动画资源animation，注意不能使用animator</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></p><p>可以通过下面两种方式加载<br>1、直接在 ViewGroup 的 layout xml 文件中设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:layoutAnimation=&quot;@anim/list_item_slide_layout_animation&quot;</span><br></pre></td></tr></table></figure></p><p>2、使用代码设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Animation animation = AnimationUtils.loadAnimation(mActivity，R.anim.slide_in_from_left);</span><br><span class="line">LayoutAnimationController animationController = new LayoutAnimationController(animation，</span><br><span class="line">         1f);</span><br><span class="line">animationController.setOrder(LayoutAnimationController.ORDER_NORMAL);</span><br><span class="line">mList.setLayoutAnimation(animationController);</span><br><span class="line">mList.startLayoutAnimation();</span><br></pre></td></tr></table></figure></p><blockquote><p>同时，系统也提供了 <a href="https://wiki.jikexueyuan.com/project/android-animation/11.html" target="_blank" rel="noopener">gridLayoutAnimation</a> 用于给 Gridview 设置布局动画。<br>需要注意的是布局动画，在创建ViewGroup的时候生效，后续添加的子View是没有动画效果的。</p></blockquote><h3 id="LayoutTransition"><a href="#LayoutTransition" class="headerlink" title="LayoutTransition"></a>LayoutTransition</h3><p>LayoutTransition 是API Level 11 才出现的。LayoutTransition 的动画效果，只有当 ViewGroup 中有 View 添加、删除、隐藏、显示的时候才会体现出来，初始化时没有效果。<br>LayoutTransition 类中主要有五种容器转换动画类型，具体如下：</p><blockquote><p>LayoutTransition.APPEARING：子 View 添加到容器中时的过渡动画效果。<br>LayoutTransition.CHANGE_APPEARING：子 View 添加到容器中时，其他子 View 位置改变的过渡动画。<br>LayoutTransition.DISAPPEARING：子 View 从容器中移除时的过渡动画效果。<br>LayoutTransition.CHANGE_DISAPPEARING：子 View 从容器中移除时，其它子 View 位置改变的过渡动画。<br>LayoutTransition.CHANGING：子 View 在容器中位置改变时的过渡动画，不涉及删除或者添加操作。(没有试出效果，哪位大神知道用法的话，欢迎到<a href="https://github.com/tangxianming/AnimationPracticeApplication/issues" target="_blank" rel="noopener">github</a>留个言，谢谢。)</p></blockquote><p>LayoutTransition 也有两种方式添加。<br>1、在xml中直接添加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 只能使用系统默认的 LayoutTransition 动画</span><br><span class="line">android:animateLayoutChanges=&quot;true&quot;</span><br></pre></td></tr></table></figure></p><p>2、在代码中使用。<br>使用系统默认的 LayoutTransition 动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LayoutTransition mTransitioner = new LayoutTransition();</span><br><span class="line">mViewGroup.setLayoutTransition(mTransitioner);</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：使用系统动画时，会出现动画未达到预期的现象。此时应该从这些方面考虑：<br>a. 直接子 View 是一个容器，且容器中的子 View 是否过多？<br>b. 直接子 View 之间的依赖关系是否能达到动画预期？<br>c. 运用在 SurfaceView 上的动画效果会异常。</p></blockquote><p>使用自定义的 LayoutTransition 动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LayoutTransition layoutTransition = new LayoutTransition();</span><br><span class="line">viewGroup.setLayoutTransition(layoutTransition);</span><br><span class="line">...</span><br><span class="line">layoutTransition.setAnimator(transitionType， AnimatorInflater.loadAnimator(this， R.animator.xxx));</span><br><span class="line">&lt;!--transitionType代表五种容器转换动画类型； R.animator.xxx代表属性动画资源。--&gt;</span><br></pre></td></tr></table></figure></p><p>同时，可以给 LayoutTransition 设置监听器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mTransitioner.addTransitionListener(new LayoutTransition.TransitionListener()&#123;//...&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>布局动画类</th><th>类型</th><th>优缺点</th><th>发布版本</th></tr></thead><tbody><tr><td>LayoutAnimation</td><td>补间动画</td><td>优点：快速实现对 ViewGroup 中子 View 的动画。对于 RecyclerView 这些 list 类型的 ViewGroup 同样适用。<br>缺点：只能够在 ViewGroup 初始化时对其子 View 产生动画效果。</td><td>API Level 1</td></tr><tr><td>LayoutTransition</td><td>属性动画</td><td>优点：ViewGroup 中只要有子 View 添加、删除、隐藏、显示，都能对子 View 的产生动画。。<br>缺点：1、对于 RecyclerView 不适用，我在实验滑动的时候是直接报错了，所以我建议如果是 RecyclerView 的话，还是用它自带的 ItemAnimator。2、对于 ListView 适用，参考这个<a href="https://pupli.net/2017/03/24/android-animating-listview-with-layouttransition/" target="_blank" rel="noopener">链接</a>，不过效果有点乱，同时还使得问题复杂化了，我在<a href="https://stackoverflow.com/questions/17239151/using-changing-layouttransition-type-in-a-listview-has-no-effect" target="_blank" rel="noopener">stackoverflow</a>上看到了这个问题的回答。3、初始化 ViewGroup 时没有效果。</td><td>API Level 11</td></tr></tbody></table><hr><p><strong>参考资料</strong><br>1.<a href="http://www.voidcn.com/article/p-bytxriow-xp.html" target="_blank" rel="noopener">Android 动画(一) LayoutAnimation 与 LayoutTransition</a><br>2.<a href="https://medium.com/@evanchen76/android-animation-30天上手-day13-layouttransition-a4c6d2a1cd90" target="_blank" rel="noopener">Android animation 30天上手 — Day13 LayoutTransition</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者已将本节的代码上传至 &lt;a href=&quot;https://github.com/tangxianming/AnimationPracticeApplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，大家可以结合着学习。&lt;br&gt;在 Android 的动画体系中，有补间动画，帧动画和属性动画，但是这些动画都是针对单个对象的，如果想对 ViewGroup 作动画，就要用到布局动画了。布局动画一共有两种：LayoutAnimation 和 LayoutTransition，本文将逐一介绍他们的用法和区别。
    
    </summary>
    
      <category term="Android动画基础" scheme="http://yoursite.com/categories/Android%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="LayoutAnimation" scheme="http://yoursite.com/tags/LayoutAnimation/"/>
    
      <category term="LayoutTransition" scheme="http://yoursite.com/tags/LayoutTransition/"/>
    
  </entry>
  
  <entry>
    <title>Android动画（五）：插值器和估值器补充、Fling动画、物理动画</title>
    <link href="http://yoursite.com/2019/03/03/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8005%EF%BC%9APath%E7%B1%BB%E5%9E%8B%E6%8F%92%E5%80%BC%E5%99%A8%E3%80%81%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB%E3%80%81Fling%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/03/03/动画基础05：Path类型插值器、路径动画、Fling动画/</id>
    <published>2019-03-03T13:08:19.000Z</published>
    <updated>2019-10-14T22:12:45.082Z</updated>
    
    <content type="html"><![CDATA[<p>笔者已将本节的代码上传至 <a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">Github</a>，大家可以结合着学习。<a id="more"></a><br>本篇讲的是 Android 视图位置变化相关的知识，其中，第一部分是对之前文章<a href="https://kimball325.github.io/2019/01/25/动画基础02：视图动画、属性动画/" target="_blank" rel="noopener">视图动画、属性动画</a>中插值器、估值器的补充。本章的内容主要参考了官方的下面三篇文章：<br><a href="https://developer.android.com/training/animation/reposition-view" target="_blank" rel="noopener">1、Move a View with Animation</a><br><a href="https://developer.android.com/guide/topics/graphics/fling-animation" target="_blank" rel="noopener">2、Move views using a fling animation</a><br><a href="https://developer.android.com/guide/topics/graphics/spring-animation#add-support-library" target="_blank" rel="noopener">3、Animate movement using spring physics</a><br>参考的中文文章在文末有给出。</p><h4 id="Path类型的插值器"><a href="#Path类型的插值器" class="headerlink" title="Path类型的插值器"></a>Path类型的插值器</h4><p>Path 类型的插值器是一种新的插值器，Android 从5.0开始支持。可以用代码、XML 两种方式实现，这里我们只讨论代码实现的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">Path path = new Path();</span><br><span class="line">path.lineTo(1f, 1f);</span><br><span class="line">PathInterpolator pathInterpolator = new PathInterpolator(path);</span><br><span class="line">…………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从以上代码可以看出，Path 被限制在一个1*1的正方形中，x、y坐标的取值范围都为[0,1]，并且 Path 必须从(0,0)坐标开始，(1,1)坐标结束。x坐标代表时间进度：0-100%，y坐标代表当前时间点对应的动画完成度：0-100%。<br>一旦<code>pathInterpolator</code>创建完成，就可以通过<code>Animator.setInterpolator()</code>方法使用它了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animation = ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 100f);</span><br><span class="line">animation.setInterpolator(pathInterpolator);</span><br><span class="line">animation.start();</span><br></pre></td></tr></table></figure></p><img src="/2019/03/03/动画基础05：Path类型插值器、路径动画、Fling动画/path_interpolator.gif" title="Path类型的插值器"><h4 id="估值器实现路径动画"><a href="#估值器实现路径动画" class="headerlink" title="估值器实现路径动画"></a>估值器实现路径动画</h4><p>ObjectAnimator从 Android 5.0 开始提供了一类新的构造方法用于实现沿自定义路径移动的动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">Path path = new Path();</span><br><span class="line">path.moveTo(view.getX(), view.getY());</span><br><span class="line">path.cubicTo(view.getX(), view.getY(),</span><br><span class="line">view.getX() + 300, view.getY() + 200,</span><br><span class="line">view.getX() - 400, view.getY() + 500);</span><br><span class="line">//下面两种方法不允许</span><br><span class="line">//path.addCircle(view.getX(), view.getY(),100,Path.Direction.CCW);</span><br><span class="line">//path.arcTo(view.getX()+100, view.getY()+100, view.getX() + 500, view.getY() + 500, 270f, -180f, true);</span><br><span class="line">ObjectAnimator objectAnimator =</span><br><span class="line">ObjectAnimator.ofFloat(ivBalPathAnimator, View.X, View.Y, path);</span><br><span class="line">objectAnimator.setDuration(1200);</span><br><span class="line">objectAnimator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">objectAnimator.setRepeatMode(ValueAnimator.REVERSE);</span><br><span class="line">objectAnimator.setInterpolator(new LinearInterpolator());</span><br><span class="line">objectAnimator.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/03/03/动画基础05：Path类型插值器、路径动画、Fling动画/path_animator.gif" title="路径动画"><h4 id="Fling动画"><a href="#Fling动画" class="headerlink" title="Fling动画"></a>Fling动画</h4><p>Fling 动画使用物理学中摩擦力的概念，使得 view 的速度逐渐被降低，从而实现了现实中的阻力运动。Android 4.4版本开始支持该动画。<br><img src="/2019/03/03/动画基础05：Path类型插值器、路径动画、Fling动画/fling-animation.gif" title="Fling Animation"><br><strong> 1、添加支持库 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">implementation &apos;com.android.support:support-dynamic-animation:28.0.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 2、创建fling动画 </strong><br>FlingAnimation 类可以帮助你创建fling动画，只要在创建 FlingAnimation 实例时传入操作的 View 对象以及操作对象的属性即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlingAnimation fling = new FlingAnimation(view, DynamicAnimation.SCROLL_X);</span><br></pre></td></tr></table></figure></p><p><strong> 3、设置初始速度 </strong><br>为了让物体移动（并非只有移动），我们必须给物体一个初速度。默认的初速度是0，所以我们必须定义一个大于0的初速度以保证物体能够移动。<br>设置初速度的方法是<code>setStartVelocity()</code>。您可以使用固定值作为起始速度，也可以将其基于触摸手势的速度通过<a href="http://www.gcssloop.com/customview/gestruedector" target="_blank" rel="noopener">GestureDetetor.OnGestureListener </a>获取。如果您选择提供固定值，您应该以每秒dp的值定义值，然后将其转换为每秒像素数。以每秒dp定义值的方式允许速度独立于设备的密度和形状因子。有关将起始速度转换为每秒像素数的更多信息，将在下一篇文章 《Spring Animation》中的“ 每秒转换为每秒像素数”部分讲解 。</p><p><strong> 4、设置动画的取值范围 </strong><br>你可以通过<code>setMinValue()</code>和<code>setMaxValue()</code>设置属性值的变化范围，这个对于有明确变化范围的属性显得十分重要，例如透明度（0-1）。注意，当fling时的属性值到达设定的最大值或者最小值时，动画会立刻结束。</p><p><strong> 5、设置阻力因子 </strong><br>你可以通过<code>setFriction()</code>改变动画的阻力因子，他定义了速度下降的速度。阻力因子的默认值是1。<br>下面的例子定义了一个横向滑动的fling动画，滑动边界被设置为0和maxScroll，摩擦力设置为1.1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FlingAnimation fling = new FlingAnimation(view, DynamicAnimation.SCROLL_X);</span><br><span class="line">fling.setStartVelocity(-velocityX)</span><br><span class="line">.setMinValue(0)</span><br><span class="line">.setMaxValue(maxScroll)</span><br><span class="line">.setFriction(1.1f)</span><br><span class="line">.start();</span><br></pre></td></tr></table></figure></p><p>注意，上面的方法仅仅适用于单个属性的 fling 变化。如果有多个属性同时需要fling变化呢？有的文章倒是建议用<code>FloatPropertyCompat</code>实现。可是<code>FloatPropertyCompat</code>有它的局限性，正如<a href="https://code.tutsplus.com/zh-hans/tutorials/adding-physics-based-animations-to-android-apps--cms-29053" target="_blank" rel="noopener">这篇文章</a>的第五部分所说：要在确保所有属性的值不是完全相互独立的情况下，该方法才适用。否则，我们只能针对每个属性都建立一个 FlingAnimation。</p><p><strong> 6、设置最小可见变化 </strong><br>当您在为不以像素为单位定义的自定义属性设置动画时，应设置用户可见的动画值的最小更改，它作为定义动画结束的最小值。<br>当操作 DynamicAnimation.ViewProperty 动画时不需要调用此方法，因为此时的最小可见变化可以自动获取。例如：<br>1、默认最小可见的变化值是1个像素，如：TRANSLATION_X，TRANSLATION_Y， TRANSLATION_Z，SCROLL_X，和 SCROLL_Y。<br>2、对于使用旋转动画，如ROTATION， ROTATION_X，和ROTATION_Y，最小可见变化是 MIN_VISIBLE_CHANGE_ROTATION_DEGREES，或1/10像素。<br>3、对于使用不透明度的动画，最小可见变化为 MIN_VISIBLE_CHANGE_ALPHA 或者1/256。<br>要设置动画的最小可见变化，请调用<code>setMinimumVisibleChange()</code>方法，并传递最小可见常量或您需要为自定义属性计算的值。有关计算此值的更多信息，请参阅本部分末的“计算最小可见变化值”部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anim.setMinimumVisibleChange(DynamicAnimation.MIN_VISIBLE_CHANGE_SCALE);</span><br></pre></td></tr></table></figure></p><p>注意：只有在为不以像素定义的自定义属性制作动画时，才需要设置最小可见变化值。</p><blockquote><p><strong>计算最小可见变化值 ：</strong><br>最小可见变化值=自定义属性值的范围/以像素为单位的动画执行范围。<br>例如，要进行动画制作的自定义非像素为单位的属性变化范围是从0到100，同时如果此过程对应于200像素的动画更改。根据公式，最小可见变化值是100/200等于0.5像素。</p></blockquote><h4 id="Spring动画"><a href="#Spring动画" class="headerlink" title="Spring动画"></a>Spring动画</h4><p>这一部分的内容在官网讲得也是很明白了。需要注意的是，官网结尾最后的“Cancel animation”部分提到的‘cancel()’和‘skipToEnd()’使用注意事项：</p><blockquote><p>cancel()：立即停止动画<br>skipToEnd()：恢复到最终位置并停止动画。需要注意的是，在无阻尼的情况下，不能调用该方法（即：DampingRatio==0时）。为了安全，可以先调用 canSkipToEnd() 进行判断，有阻尼的情况下返回 true，否则返回 false。一般来说，skipToEnd() 会有跳跃的效果。</p></blockquote><p>以下是Demo中实现的效果：<br><img src="/2019/03/03/动画基础05：Path类型插值器、路径动画、Fling动画/spring_animation.gif" title="物理动画"></p><hr><p><strong>参考资料</strong><br><a href="https://cloud.tencent.com/info/eb3faa589479ceb0a501d4cbf3a25541.html" target="_blank" rel="noopener">1、中文翻译：使用 fling 动画移动视图</a><br><a href="https://juejin.im/entry/58ddd02644d904006d034b33" target="_blank" rel="noopener">2、SpringAnimation 详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者已将本节的代码上传至 &lt;a href=&quot;https://github.com/tangxianming/AnimationPracticeApplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，大家可以结合着学习。
    
    </summary>
    
      <category term="Android动画基础" scheme="http://yoursite.com/categories/Android%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PathInterpolator" scheme="http://yoursite.com/tags/PathInterpolator/"/>
    
      <category term="路径动画" scheme="http://yoursite.com/tags/%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/"/>
    
      <category term="FlingAnimation" scheme="http://yoursite.com/tags/FlingAnimation/"/>
    
      <category term="SpringAnimation" scheme="http://yoursite.com/tags/SpringAnimation/"/>
    
  </entry>
  
  <entry>
    <title>Android动画（四）：淡入淡出、翻牌、揭露动画</title>
    <link href="http://yoursite.com/2019/02/22/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8004%EF%BC%9A%E6%B7%A1%E5%85%A5%E3%80%81%E7%BF%BB%E7%89%8C%E3%80%81%E6%8F%AD%E9%9C%B2%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/02/22/动画基础04：淡入、翻牌、揭露动画/</id>
    <published>2019-02-22T07:20:25.000Z</published>
    <updated>2019-10-14T22:12:45.081Z</updated>
    
    <content type="html"><![CDATA[<p>笔者已将本节的代码上传至 <a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">Github</a>，大家可以结合着学习。以下内容是对<a href="https://developer.android.com/training/animation/reveal-or-hide-view#java" target="_blank" rel="noopener">官方文档</a>的翻译。<a id="more"></a><br>当你在使用APP时，如果立即从旧的内容切换到新内容，则很容易让用户感到不适，所以我们需要转场动画来平滑地过渡这种新旧内容的切换过程。<br>有三种常用的动画适合该场景，他们分别是淡入淡出动画、翻牌动画、揭露动画。</p><h2 id="淡入淡出动画"><a href="#淡入淡出动画" class="headerlink" title="淡入淡出动画"></a>淡入淡出动画</h2><p>淡入淡出动画顾名思义是在一个 View 或者 ViewGroup 消失时，另外一个View同步显示的动画。本节采用<code>ViewPropertyAnimator</code>实现淡入淡出动画，从Android 3.1 （API level 12）开始支持 ViewPropertyAnimator。<br>这是一个使用淡入淡出动画的例子。<br><img src="/2019/02/22/动画基础04：淡入、翻牌、揭露动画/anim_crossfade.gif" title="Crossfade animation"></p><h4 id="创建views"><a href="#创建views" class="headerlink" title="创建views"></a>创建views</h4><p>首先，你需要创建两个你需要使用淡入淡出动画的 View。下面创建了一个进度指示 View 和一个可滑动的文本 View：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        android:id=&quot;@+id/content&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            style=&quot;?android:textAppearanceMedium&quot;</span><br><span class="line">            android:lineSpacingMultiplier=&quot;1.2&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@string/lorem_ipsum&quot;</span><br><span class="line">            android:padding=&quot;16dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/ScrollView&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ProgressBar</span><br><span class="line">        android:id=&quot;@+id/loading_spinner&quot;</span><br><span class="line">        style=&quot;?android:progressBarStyleLarge&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_gravity=&quot;center&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure></p><h4 id="创建淡入淡出动画"><a href="#创建淡入淡出动画" class="headerlink" title="创建淡入淡出动画"></a>创建淡入淡出动画</h4><p>分为3个步骤：<br>1、创建成员变量以便接下来对其添加动画。<br>2、对于将要淡入的 View，提前将 visibility 属性设置为<code>GONE</code>。这不仅能够避免该 View 在动画开始之前占用 layout 空间，同时也避免了不必要的 layout 计算。<br>3、预先保存<code>config_shortAnimTime</code>属性值。这个属性值表示标准的短暂动画时长，这个时长是很理想的数值对于频繁使用的动画来说。除此之外，还有<code>config_longAnimTime</code>和<code>config_mediumAnimTime</code>可供选择。</p><p>下面的代码使用了之前创建的 layout 作为活动的 content view：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CrossfadeActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private View contentView;</span><br><span class="line">    private View loadingView;</span><br><span class="line">    private int shortAnimationDuration;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_crossfade);</span><br><span class="line"></span><br><span class="line">        contentView = findViewById(R.id.content);</span><br><span class="line">        loadingView = findViewById(R.id.loading_spinner);</span><br><span class="line"></span><br><span class="line">        // Initially hide the content view.</span><br><span class="line">        contentView.setVisibility(View.GONE);</span><br><span class="line"></span><br><span class="line">        // Retrieve and cache the system&apos;s default &quot;short&quot; animation time.</span><br><span class="line">        shortAnimationDuration = getResources().getInteger(</span><br><span class="line">                android.R.integer.config_shortAnimTime);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="添加淡入淡出动画"><a href="#添加淡入淡出动画" class="headerlink" title="添加淡入淡出动画"></a>添加淡入淡出动画</h4><p>最后，我们要实现淡入淡出动画还需要如下3个步骤：<br>1、对于将要淡入的 View，设置它的 alpha 属性为0并且设置 visiblity 为<code>VISIBLE</code>（该 View 之前的 visibility 为<code>GONE</code>）。这一步让该 View 处于可见但完全透明的状态。<br>2、对将要淡入的view，让它的透明度从0变化到1。对于将要淡出的view，让它的透明度从1到0。<br>3、在<code>Animator.AnimatorListener</code>的<code>onAnimationEnd()</code>方法中设置淡出view 的 visibility 属性为<code>GONE</code>。注意，虽然该 View 已经完全透明，但是设置属性 visibility 为<code>GONE</code>不仅可以阻止该 View 占用 layout 空间，同时还避免了不必要的 layout 计算。<br>下面是这几步的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CrossfadeActivity extends Activity &#123;</span><br><span class="line">    private View contentView;</span><br><span class="line">    private View loadingView;</span><br><span class="line">    private int shortAnimationDuration;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    private void crossfade() &#123;</span><br><span class="line">        contentView.setAlpha(0f);</span><br><span class="line">        contentView.setVisibility(View.VISIBLE);</span><br><span class="line">        contentView.animate()</span><br><span class="line">                .alpha(1f)</span><br><span class="line">                .setDuration(shortAnimationDuration)</span><br><span class="line">                .setListener(null);</span><br><span class="line">        loadingView.animate()</span><br><span class="line">                .alpha(0f)</span><br><span class="line">                .setDuration(shortAnimationDuration)</span><br><span class="line">                .setListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">                        loadingView.setVisibility(View.GONE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="翻牌动画"><a href="#翻牌动画" class="headerlink" title="翻牌动画"></a>翻牌动画</h2><p>该动画适用于在两个 View 之间实现类似翻牌的动效。本节的翻牌动画借助了<code>FragmentTransaction</code>类的<code>setCustomAnimations</code>方法，该类从 Android3.0（API等级11） 开始可以调用。当然，你也可以借助其他的方式实现咯。</p><h4 id="创建Animator-object"><a href="#创建Animator-object" class="headerlink" title="创建Animator object"></a>创建Animator object</h4><p>为了创建翻牌动画，你一共需要四个 animators。两个分别控制前面的内容（卡片正面）从左边翻出和从左边翻入。同时需要两个 animators 分别控制后面的内容（卡片反面）从右边翻入和右边翻出。<br>card_flip_left_in.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- Before rotating, immediately set the alpha to 0. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;1.0&quot;</span><br><span class="line">        android:valueTo=&quot;0.0&quot;</span><br><span class="line">        android:propertyName=&quot;alpha&quot;</span><br><span class="line">        android:duration=&quot;0&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Rotate. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;-180&quot;</span><br><span class="line">        android:valueTo=&quot;0&quot;</span><br><span class="line">        android:propertyName=&quot;rotationY&quot;</span><br><span class="line">        android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot;</span><br><span class="line">        android:duration=&quot;@integer/card_flip_time_full&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 1. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;0.0&quot;</span><br><span class="line">        android:valueTo=&quot;1.0&quot;</span><br><span class="line">        android:propertyName=&quot;alpha&quot;</span><br><span class="line">        android:startOffset=&quot;@integer/card_flip_time_half&quot;</span><br><span class="line">        android:duration=&quot;1&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p><p>card_flip_left_out.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- Rotate. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;0&quot;</span><br><span class="line">        android:valueTo=&quot;180&quot;</span><br><span class="line">        android:propertyName=&quot;rotationY&quot;</span><br><span class="line">        android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot;</span><br><span class="line">        android:duration=&quot;@integer/card_flip_time_full&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 0. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;1.0&quot;</span><br><span class="line">        android:valueTo=&quot;0.0&quot;</span><br><span class="line">        android:propertyName=&quot;alpha&quot;</span><br><span class="line">        android:startOffset=&quot;@integer/card_flip_time_half&quot;</span><br><span class="line">        android:duration=&quot;1&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p><p>card_flip_right_in.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- Before rotating, immediately set the alpha to 0. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;1.0&quot;</span><br><span class="line">        android:valueTo=&quot;0.0&quot;</span><br><span class="line">        android:propertyName=&quot;alpha&quot;</span><br><span class="line">        android:duration=&quot;0&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Rotate. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;180&quot;</span><br><span class="line">        android:valueTo=&quot;0&quot;</span><br><span class="line">        android:propertyName=&quot;rotationY&quot;</span><br><span class="line">        android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot;</span><br><span class="line">        android:duration=&quot;@integer/card_flip_time_full&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 1. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;0.0&quot;</span><br><span class="line">        android:valueTo=&quot;1.0&quot;</span><br><span class="line">        android:propertyName=&quot;alpha&quot;</span><br><span class="line">        android:startOffset=&quot;@integer/card_flip_time_half&quot;</span><br><span class="line">        android:duration=&quot;1&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p><p>card_flip_right_out.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- Rotate. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;0&quot;</span><br><span class="line">        android:valueTo=&quot;-180&quot;</span><br><span class="line">        android:propertyName=&quot;rotationY&quot;</span><br><span class="line">        android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot;</span><br><span class="line">        android:duration=&quot;@integer/card_flip_time_full&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 0. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;1.0&quot;</span><br><span class="line">        android:valueTo=&quot;0.0&quot;</span><br><span class="line">        android:propertyName=&quot;alpha&quot;</span><br><span class="line">        android:startOffset=&quot;@integer/card_flip_time_half&quot;</span><br><span class="line">        android:duration=&quot;1&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p><h4 id="创建view"><a href="#创建view" class="headerlink" title="创建view"></a>创建view</h4><p>卡片的正反面是两个独立的 layout，方便之后将这两个独立的 layout 分别绑定到两个 Fragment 上。下面是这两个独立的 layout 之一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:padding=&quot;130dp&quot;&gt;</span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:background=&quot;#a6c&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">            android:text=&quot;FONT&quot;</span><br><span class="line">            android:textColor=&quot;#FFFFFF&quot;</span><br><span class="line">            android:textStyle=&quot;bold&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/RelativeLayout&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>下面是另一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:padding=&quot;130dp&quot;&gt;</span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:background=&quot;@color/colorPrimary&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">            android:text=&quot;BACK&quot;</span><br><span class="line">            android:textColor=&quot;#FFFFFF&quot;</span><br><span class="line">            android:textStyle=&quot;bold&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/RelativeLayout&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><h4 id="创建fragments"><a href="#创建fragments" class="headerlink" title="创建fragments"></a>创建fragments</h4><p>创建两个 Fragment 作为卡片的正反面，将之前的两个 layout 分别绑定到这两个 Fragment 上。然后将这两个 Fragment 作为 FragmentActivity 的展示内容，该 Activity 就是你要展示翻牌动画的页面。下面是两个 Fragment 的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CardFlipActivity extends FragmentActivity &#123;</span><br><span class="line">    ...</span><br><span class="line">    /**</span><br><span class="line">     * A fragment representing the front of the card.</span><br><span class="line">     */</span><br><span class="line">    public class CardFrontFragment extends Fragment &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public View onCreateView(LayoutInflater inflater, ViewGroup container,</span><br><span class="line">                Bundle savedInstanceState) &#123;</span><br><span class="line">            return inflater.inflate(R.layout.fragment_card_front, container, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * A fragment representing the back of the card.</span><br><span class="line">     */</span><br><span class="line">    public class CardBackFragment extends Fragment &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public View onCreateView(LayoutInflater inflater, ViewGroup container,</span><br><span class="line">                Bundle savedInstanceState) &#123;</span><br><span class="line">            return inflater.inflate(R.layout.fragment_card_back, container, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实现动画"><a href="#实现动画" class="headerlink" title="实现动画"></a>实现动画</h4><p>现在，你需要在 Activity 中展示这两个 Fragment 的内容。为了实现此需求，你应该为你的 Activity 创建一个 layout。下面的例子在此 layout 中创建了一个<code>FrameLayout</code>作为 Fragment 的容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:id=&quot;@+id/container&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>在 Activity 中，将以上的 layout 设置为 content view。然后在 Activity 的<code>oncreate</code>阶段显示卡片的正面内容。下面的例子展示了这一过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CardFlipActivity extends FragmentActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_activity_card_flip);</span><br><span class="line"></span><br><span class="line">        if (savedInstanceState == null) &#123;</span><br><span class="line">            getSupportFragmentManager()</span><br><span class="line">                    .beginTransaction()</span><br><span class="line">                    .add(R.id.container, new CardFrontFragment())</span><br><span class="line">                    .commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在你已经展示了卡片的正面，接下来要做的就是如何使用翻牌动画翻开卡片的背面，当卡片翻转到背面后，再次将其翻转到正面。下面的代码实现这一功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CardFlipActivity extends FragmentActivity &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    private void flipCard() &#123;</span><br><span class="line">        if (showingBack) &#123;</span><br><span class="line">            //Flip to the font.</span><br><span class="line">            showingBack = false;</span><br><span class="line">            getSupportFragmentManager()</span><br><span class="line">                    .beginTransaction()</span><br><span class="line">                    //注意setCustomAnimations()方法必须在add、remove、replace调用之前被设置，否则不起作用。</span><br><span class="line">                    .setCustomAnimations(</span><br><span class="line">                            R.animator.card_flip_left_in,</span><br><span class="line">                            R.animator.card_flip_left_out,</span><br><span class="line">                            0,</span><br><span class="line">                            0)</span><br><span class="line">                    .replace(R.id.flContainer, new CardFrontFragment())</span><br><span class="line">                    .commit();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // Flip to the back.</span><br><span class="line">        showingBack = true;</span><br><span class="line">        getSupportFragmentManager()</span><br><span class="line">                .beginTransaction()</span><br><span class="line">                .setCustomAnimations(</span><br><span class="line">                        R.animator.card_flip_right_in,</span><br><span class="line">                        R.animator.card_flip_right_out,</span><br><span class="line">                        0,</span><br><span class="line">                        0)</span><br><span class="line">                .replace(R.id.flContainer, new CardBackFragment())</span><br><span class="line">                .commit();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最终实现的效果：<br><img src="/2019/02/22/动画基础04：淡入、翻牌、揭露动画/anim_card_flip.gif" title="Card flip animation"></p><h2 id="揭露动画"><a href="#揭露动画" class="headerlink" title="揭露动画"></a>揭露动画</h2><p>当需要显示或者隐藏view时，揭露动画给用户提供了一种视觉上的延续。<code>ViewAnimationUtils.createCircularReveal()</code>方法可以帮助你实现此动画，此方式在 Android 5.0（API level 21） 以上提供。<br>下面的代码展示了如何使用揭露动画展示初始状态为 invisible 的 View：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// previously invisible view</span><br><span class="line">View myView = findViewById(R.id.my_view);</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    int cx = myView.getWidth() / 2;</span><br><span class="line">    int cy = myView.getHeight() / 2;</span><br><span class="line">    float finalRadius = (float) Math.hypot(cx, cy);</span><br><span class="line">    Animator anim = ViewAnimationUtils.createCircularReveal(myView, cx, cy, 0f, finalRadius);</span><br><span class="line">    myView.setVisibility(View.VISIBLE);</span><br><span class="line">    anim.start();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // set the view to visible without a circular reveal animation below Lollipop</span><br><span class="line">    myView.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ViewAnimationUtils.createCircularReveal()</code>动画一共有5个参数。第一个参数表示目标 View。接下来的两个参数代表了揭露动画开始的圆心坐标。一般地，这通常是目标 View的中心点坐标，但是你也可以将它定义为你的手指触摸点的坐标，从而使得揭露动画从你的手指触摸点开始揭露。第四个参数表示动画开始的圆形区域半径。<br>在上面的例子中，初始的圆形半径为0，从而目标 View 初始状态是隐藏的。最后一个参数代表揭露区域（圆形区域）的最大半径。值得注意的是，最后一个参数必须保证能够完全覆盖你的目标 View。<br>下面是使用揭露动画隐藏视图的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// previously visible view</span><br><span class="line">final View myView = findViewById(R.id.my_view);</span><br><span class="line">if (Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    int cx = myView.getWidth() / 2;</span><br><span class="line">    int cy = myView.getHeight() / 2;</span><br><span class="line">    float initialRadius = (float) Math.hypot(cx, cy);</span><br><span class="line">    Animator anim = ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, 0f);</span><br><span class="line">    anim.addListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">            super.onAnimationEnd(animation);</span><br><span class="line">            myView.setVisibility(View.INVISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    anim.start();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // set the view to invisible without a circular reveal animation below Lollipop</span><br><span class="line">    myView.setVisibility(View.INVISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实例中，揭露动画的初始半径足够覆盖整个目标视图，所以初始时的视图是完全可见的。最终的半径设置为0，则表示动画结束后会隐藏目标视图。注意，当动画结束后要将目标视图的 visiblility 属性设置为<code>INVISIBLE</code>以提高性能。<br>最终效果如下：<br><img src="/2019/02/22/动画基础04：淡入、翻牌、揭露动画/circular_reveal.gif" title="揭露动画"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者已将本节的代码上传至 &lt;a href=&quot;https://github.com/tangxianming/AnimationPracticeApplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，大家可以结合着学习。以下内容是对&lt;a href=&quot;https://developer.android.com/training/animation/reveal-or-hide-view#java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;的翻译。
    
    </summary>
    
      <category term="Android动画基础" scheme="http://yoursite.com/categories/Android%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="淡入淡出动画" scheme="http://yoursite.com/tags/%E6%B7%A1%E5%85%A5%E6%B7%A1%E5%87%BA%E5%8A%A8%E7%94%BB/"/>
    
      <category term="翻牌动画" scheme="http://yoursite.com/tags/%E7%BF%BB%E7%89%8C%E5%8A%A8%E7%94%BB/"/>
    
      <category term="揭露动画" scheme="http://yoursite.com/tags/%E6%8F%AD%E9%9C%B2%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Android动画（三）：矢量图动画</title>
    <link href="http://yoursite.com/2019/02/17/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8003%EF%BC%9A%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/02/17/动画基础03：矢量图动画/</id>
    <published>2019-02-17T02:04:42.000Z</published>
    <updated>2019-10-14T22:12:45.081Z</updated>
    
    <content type="html"><![CDATA[<p>笔者已将本节的代码上传至 <a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">Github</a>，大家可以结合着学习。本篇参考了CSDN作者：<code>Mr13_周</code> 的以下三篇文章。<a id="more"></a><br>1、<a href="https://blog.csdn.net/zwlove5280/article/details/73196543" target="_blank" rel="noopener">SVG 的 PathData 在 Android 中的使用</a><br>2、<a href="https://blog.csdn.net/zwlove5280/article/details/73442464" target="_blank" rel="noopener">Android：获取并制作矢量图动画</a><br>3、<a href="https://blog.csdn.net/zwlove5280/article/details/73650801" target="_blank" rel="noopener">Android 矢量图动画（完结篇）</a><br>在通读完这3篇文章后，笔者在代码实操后，补充以下知识点。</p><h4 id="知识一：strokeLineJoin-的-miter-模式-。"><a href="#知识一：strokeLineJoin-的-miter-模式-。" class="headerlink" title="知识一：strokeLineJoin 的 miter 模式 。"></a>知识一：strokeLineJoin 的 miter 模式 。</h4><p><code>strokeLineJoin</code>是 path 标签下的属性，负责线条的拐角形状，包括如下3个属性值：<br>1、miter : 默认值，也就是系统默认使用的。<br>2、round : 圆角式连接。<br>3、bevel：斜角式连接。<br>当线条拐角为 MITER 时，拐角处的外缘需要使用延长线来补偿：<br><img src="/2019/02/17/动画基础03：矢量图动画/1.jpg"><br>而这种补偿方案会有一个问题：如果拐角的角度太小，就有可能由于出现连接点过长的情况。比如这样：<br><img src="/2019/02/17/动画基础03：矢量图动画/2.jpg"><br>所以为了避免意料之外的过长的尖角出现， MITER 型连接点有一个额外的规则：当尖角过长时，自动改用  BEVEL 的方式来渲染连接点。例如上图的这个尖角，在默认情况下是不会出现的，而是会由于延长线过长而被转为 BEVEL 型连接点：<br><img src="/2019/02/17/动画基础03：矢量图动画/3.jpg"><br>至于多尖的角才属于过于尖，尖到需要转为使用 BEVEL 来绘制，则是由 path 标签的属性<code>strokeMiterLimit</code>来设置的。strokeMiterLimit 参数是对于转角长度的限制，具体来讲，是指尖角的外缘端点和内部拐角的距离与线条宽度的比。也就是下面这两个长度的比：<br><img src="/2019/02/17/动画基础03：矢量图动画/4.jpg"><br>这个 strokeMiterLimit 的默认值是 4，对应的是一个大约 29° 的锐角：<br><img src="/2019/02/17/动画基础03：矢量图动画/5.jpg"><br>默认情况下，大于这个角的尖角会被保留，而小于这个夹角的 strokeLineJoin 就会被自动转换为 bevel 模式。<br><a href="https://hencoder.com/ui-1-2/" target="_blank" rel="noopener">参考地址&gt;&gt;</a></p><h4 id="知识二：SVG、VectorDrawable、AnimatedVectorDrawable之间的联系。"><a href="#知识二：SVG、VectorDrawable、AnimatedVectorDrawable之间的联系。" class="headerlink" title="知识二：SVG、VectorDrawable、AnimatedVectorDrawable之间的联系。"></a>知识二：SVG、VectorDrawable、AnimatedVectorDrawable之间的联系。</h4><p>SVG是一种格式，代表矢量图形，类似的有JPG、PNG格式。SVG不能在 Android 中直接使用。<br>VectorDrawable 是 Android 5.0 系统中引入了来支持矢量图(SVG)的，同时还引入了 AnimatedVectorDrawable 来支持矢量图动画。<br>市场上有很多SVG转 VectorDrawable 的工具，笔者推荐<a href="https://inloop.github.io/svg2android/" target="_blank" rel="noopener">这个网站</a>，不过需要科学上网哦。</p><h4 id="知识三：VectorDrawable的各个标签的属性介绍。"><a href="#知识三：VectorDrawable的各个标签的属性介绍。" class="headerlink" title="知识三：VectorDrawable的各个标签的属性介绍。"></a>知识三：VectorDrawable的各个标签的属性介绍。</h4><p>如果你喜欢原滋原味的，请查看<a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable" target="_blank" rel="noopener">官方文档</a>。如果喜欢翻译好了的，请移步<a href="https://juejin.im/entry/5899404a128fe10065689b34" target="_blank" rel="noopener">这篇文章</a>的最后部分。</p><h4 id="知识四：对trimPathStart、trimPathEnd、trimPathOffset属性的理解。"><a href="#知识四：对trimPathStart、trimPathEnd、trimPathOffset属性的理解。" class="headerlink" title="知识四：对trimPathStart、trimPathEnd、trimPathOffset属性的理解。"></a>知识四：对trimPathStart、trimPathEnd、trimPathOffset属性的理解。</h4><p>具体介绍请移步到简书的<a href="https://www.jianshu.com/p/6bb3584dda41" target="_blank" rel="noopener">这篇文章</a>。这里还有一点需要补充，当他们的值n大于1时，实际的值是n-1，比如 trimPathStart 的值是1.1，那么系统会自动按0.1处理。注意，n不能小于0，否者会将当前path全部修剪。其它的情况，可以下载笔者的代码自己操作一下。</p><h4 id="知识五：怎么处理兼容性？"><a href="#知识五：怎么处理兼容性？" class="headerlink" title="知识五：怎么处理兼容性？"></a>知识五：怎么处理兼容性？</h4><p>Android从5.0版本（API 21）才开始支持矢量图，引入了 VectorDrawable（矢量图） 和 AnimatedVectorDrawable（矢量图动画）。对于低版本，官方虽然也给出了<a href="https://www.jianshu.com/p/dd218763282c" target="_blank" rel="noopener">兼容方法</a>，但是依然还有很多坑要踩，比如<a href="https://cloud.tencent.com/developer/article/1160396" target="_blank" rel="noopener">这篇文章</a>所说的。所以笔者建议如果没有强制要求的话，还是把你的app的最低版本支持提高到API 21吧。</p><h4 id="知识六：width、height、viewportWidth、viewportHeight属性说明。"><a href="#知识六：width、height、viewportWidth、viewportHeight属性说明。" class="headerlink" title="知识六：width、height、viewportWidth、viewportHeight属性说明。"></a>知识六：width、height、viewportWidth、viewportHeight属性说明。</h4><p>1、android:width \ android:height：定义矢量图的宽高。<br>2、android:viewportHeight \ android:viewportWidth：定义图像被划分的比例大小。比如width=200dp、viewportWidth=500，即把200dp大小的图像划分成500份，后面Path标签中的坐标，就全部使用的是这里划分后的坐标系统。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者已将本节的代码上传至 &lt;a href=&quot;https://github.com/tangxianming/AnimationPracticeApplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，大家可以结合着学习。本篇参考了CSDN作者：&lt;code&gt;Mr13_周&lt;/code&gt; 的以下三篇文章。
    
    </summary>
    
      <category term="Android动画基础" scheme="http://yoursite.com/categories/Android%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="AnimationDrawable" scheme="http://yoursite.com/tags/AnimationDrawable/"/>
    
      <category term="AnimatedVectorDrawable" scheme="http://yoursite.com/tags/AnimatedVectorDrawable/"/>
    
  </entry>
  
  <entry>
    <title>Android动画（二）：视图动画、属性动画</title>
    <link href="http://yoursite.com/2019/01/25/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8002%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E3%80%81%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/01/25/动画基础02：视图动画、属性动画/</id>
    <published>2019-01-25T08:57:30.000Z</published>
    <updated>2019-10-14T22:12:45.080Z</updated>
    
    <content type="html"><![CDATA[<p>笔者已将本节的代码上传至<a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">Github</a>，大家可以结合着学习。<br>本篇以文章<a href="https://juejin.im/post/5aea7063f265da0b9b072758" target="_blank" rel="noopener">《Android 动画：这是一份详细 &amp; 清晰的动画学习指南》</a>为基础，笔者在通读了这篇文章并进行了必要的代码实操后觉得有三个知识点需要补充，所以本篇将记录下这三个知识点。<a id="more"></a></p><h4 id="知识一：LayoutAnimation的局限性"><a href="#知识一：LayoutAnimation的局限性" class="headerlink" title="知识一：LayoutAnimation的局限性"></a>知识一：LayoutAnimation的局限性</h4><p>LayoutAnimation 只在创建 ViewGroup 的时候生效，后续添加的子 View 是没有动画效果的。这和 LayoutTransition 有很大的区别，在后续介绍<a href="https://kimball325.github.io/2019/01/25/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8002%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E3%80%81%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/" target="_blank" rel="noopener">布局动画</a>时再展开介绍。</p><h4 id="知识二：动画监听方法归类"><a href="#知识二：动画监听方法归类" class="headerlink" title="知识二：动画监听方法归类"></a>知识二：动画监听方法归类</h4><p>1、转场动画相关<br>Animation.setAnimationListener(Animation.AnimationListener listener);<br>2、属性动画相关<br>Animator.addListener(AnimatorListenerAdapter adapter);<br>Animator.addListener(Animator.AnimatorListener listener);<br>Animator.addPauseListener(Animator.AnimatorPauseListener listener);<br>Animator.addUpdateListener(ValueAnimator.AnimatorUpdateListener listener);<br>3、ViewPropertyAnimator动画相关<br>ViewPropertyAnimator.setListener(AnimatorListenerAdapter adapter);<br>ViewPropertyAnimator.setListener(Animator.AnimatorListener listener);<br>ViewPropertyAnimator.setUpdateListener(AnimatorUpdateListener listener);<br>ViewPropertyAnimator.withEndAction(Runnable runnable);<br>ViewPropertyAnimator.withStartAction(Runnable runnable);</p><blockquote><p><strong> 注意 </strong><br>withStartAction() / withEndAction() 是一次性的，在动画执行结束后就自动弃掉了，就算之后再重用  ViewPropertyAnimator 来做别的动画，用它们设置的回调也不会再被调用。而 set/addListener() 所设置的 AnimatorListener 是持续有效的，当动画重复执行时，回调总会被调用。</p></blockquote><p><a href="https://hencoder.com/ui-1-6/" target="_blank" rel="noopener">参考链接&gt;&gt;</a></p><h4 id="知识三：AnimationDrawable的使用时机"><a href="#知识三：AnimationDrawable的使用时机" class="headerlink" title="知识三：AnimationDrawable的使用时机"></a>知识三：AnimationDrawable的使用时机</h4><p>AnimationDrawable 的 start 方法不能在你的 Activity 的<code>onCreate()</code>中使用，否者会没有效果，因为这个时候 AnimationDrawable 还没有绑定到窗口。如果你想在进入页面后立即开始动画，可以在你的 Activity 的<code>onStart()</code>方法中调用。当然，你也可以在交互监听中调用 start 方法，比如在某个 View 的<code>onClick()</code>方法中调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者已将本节的代码上传至&lt;a href=&quot;https://github.com/tangxianming/AnimationPracticeApplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，大家可以结合着学习。&lt;br&gt;本篇以文章&lt;a href=&quot;https://juejin.im/post/5aea7063f265da0b9b072758&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Android 动画：这是一份详细 &amp;amp; 清晰的动画学习指南》&lt;/a&gt;为基础，笔者在通读了这篇文章并进行了必要的代码实操后觉得有三个知识点需要补充，所以本篇将记录下这三个知识点。
    
    </summary>
    
      <category term="Android动画基础" scheme="http://yoursite.com/categories/Android%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Animation" scheme="http://yoursite.com/tags/Animation/"/>
    
      <category term="LayoutAnimation" scheme="http://yoursite.com/tags/LayoutAnimation/"/>
    
      <category term="Animator" scheme="http://yoursite.com/tags/Animator/"/>
    
      <category term="ValueAnimator" scheme="http://yoursite.com/tags/ValueAnimator/"/>
    
      <category term="ObjectAnimator" scheme="http://yoursite.com/tags/ObjectAnimator/"/>
    
      <category term="ViewPropertyAnimator" scheme="http://yoursite.com/tags/ViewPropertyAnimator/"/>
    
  </entry>
  
  <entry>
    <title>Android动画（一）：坐标、区域、视图层级</title>
    <link href="http://yoursite.com/2019/01/15/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8001%EF%BC%9A%E5%9D%90%E6%A0%87%E3%80%81%E5%8C%BA%E5%9F%9F%E3%80%81%E8%A7%86%E5%9B%BE%E5%B1%82%E7%BA%A7/"/>
    <id>http://yoursite.com/2019/01/15/动画基础01：坐标、区域、视图层级/</id>
    <published>2019-01-15T09:01:21.000Z</published>
    <updated>2020-01-07T22:36:25.025Z</updated>
    
    <content type="html"><![CDATA[<p>笔者已将本节的代码上传至 <a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">Github</a>，大家可以结合着学习。<a id="more"></a></p><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>event.getX()：表示的是触摸的点距离自身左边界的距离。<br>event.getY()：表示的是触摸的点距离自身上边界的距离。<br>event.getRawX：表示的是触摸点距离屏幕左边界的距离。<br>event.getRawY：表示的是触摸点距离屏幕上边界的距离，包括状态栏。<br>View.getX：表示View左上角相对于父容器的x坐标。<br>View.getY：表示View左上角相对于父容器的y坐标。<br>View.getTranslationX()：计算的是该View在X轴的偏移量。初始值为0，向左偏移值为负，向右偏移值为正。<br>View.getTranslationY()：计算的是该View在Y轴的偏移量。初始值为0，向上偏移为负，向下偏移为正。<br>View.getLocationInWindow(pos)：计算的是view在其父窗口中的坐标位置。<br>View.getLocationOnScreen(pos)：计算的是view在其整个屏幕上的坐标位置。</p><blockquote><p><strong>知识补充</strong><br>1、Android中每个 View 都有一个自己的坐标系，彼此之间是不影响的。这个坐标系的原点是 View 左上角的那个点；水平方向是 x 轴，右正左负；竖直方向是 y 轴，下正上负。<a href="https://hencoder.com/ui-1-1/" target="_blank" rel="noopener">查看来源</a><br>2、如果重写 Activity 的<code>onTouchEvent(MotionEvent event)</code>方法，这个时候 event.getX() 与 event.getRawX() 获取的值是一样的，event.getY() 与 event.getRawY() 获取的值是一样，但是直接触摸状态栏、底部导航栏时的坐标位置不能获得。<a href="https://blog.csdn.net/xuxingxing002/article/details/50328529" target="_blank" rel="noopener">查看来源</a><br>3、view.translationX 表示 view 在原来基础上移动多少，view.X 表示最终要移动到X轴的哪个位置，view.getX() 的值为 view.getLeft() 与 view.getTranslationX() 之和。<a href="https://www.jianshu.com/p/8dec4dd68fd9" target="_blank" rel="noopener">查看来源</a><br>4、注意 canvas.translate 与 view.translationX 是不同的，前者表示 canvas 在上次基础上移动多少。（适用所有 translate() 类的方法。）<br>5、当view是在dialog 或 popupWindow 上显示时，getLocationInWindow获得的值是相对于 dialog 或者 popuwindow 左上角的坐标。<a href="http://www.itdaan.com/blog/2015/09/11/e032ab54ebed4076e988044fa973b6a7.html" target="_blank" rel="noopener">查看来源1</a>  | <a href="https://blog.csdn.net/ouyang_peng/article/details/46902957" target="_blank" rel="noopener">查看来源2</a></p></blockquote><h2 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h2><p>我为便于表述，统一把<strong>视图大小</strong>、<strong>视图范围</strong>、<strong>Android 5.0主题风格</strong>的知识都划归到这一部分，大家不必纠结，重点关注每个知识点的概念以及区别。<br>View.getWidth()：表示的是当前控件的宽度，即getRight()-getLeft()。<br>View.getHeight()：表示的是当前控件的高度，即getBottom()-getTop()。<br>View.getTop()：子View的顶部到父View顶部的距离。<br>View.getRight()：子View的右边界到父View的左边界的距离。<br>View.getBottom()：子View的底部到父View的顶部的距离。<br>View.getLeft()：子View的左边界到父View的左边界的距离。<br>View.getGlobalVisibleRect(rect)：得到整体相对于屏幕（包括状态栏）的区域范围rect，这个rect表示当前view的范围。<br>View.getLocalVisibleRect(rect)：得到自己显示的区域，这个区域的坐标是相对自身的，仅仅用来表示自身所占的范围。左上角坐标一直为（0，0），右下角通过计算可得。<br>View.getWindowVisibleDisplayFrame(rect)：获取到程序显示的区域，包括标题栏（ActionBar），不包括状态栏、导航栏、键盘区域(如弹起)。</p><blockquote><p><strong>知识补充</strong><br>1、<a href="https://blog.csdn.net/chenbing81/article/details/75902401" target="_blank" rel="noopener">Android手机获取屏幕分辨率高度因虚拟导航栏带来的问题。</a><br>2、<a href="https://blog.csdn.net/u012764110/article/details/49783465" target="_blank" rel="noopener">如何在onCreate方法中获取状态栏，底部导航栏高度？</a><br>（注意：即使状态栏、底部导航栏被隐藏，他们的高度依然可以按链接中的方法得到。）<br>3、<a href="https://www.jianshu.com/p/a179d9419c35" target="_blank" rel="noopener">获取View高度的三种方法。</a></p></blockquote><p>Android 5.0之后的主题风格：<br><img src="/2019/01/15/动画基础01：坐标、区域、视图层级/2.jpg"><br>1、如果 app 的标题栏仍是使用 actionbar，则直接在风格 (styles) 或是主题 (themes) 里进行设定 colorPrimary 参数即可；若是采用 toolbar 的话，则要在界面 (layout) 里面设定 toolbar 控件的 background 属性。<br>2、如果在 style 中设置了 statusBarColor，则会覆盖 colorPrimaryDark 的影响，即：状态栏的颜色将是 statusBarColor。</p><h2 id="视图层级"><a href="#视图层级" class="headerlink" title="视图层级"></a>视图层级</h2><img src="/2019/01/15/动画基础01：坐标、区域、视图层级/1.png"><p>getParent：获取上一级容器。<br>getRootView： 获取顶级视图 ecorView。<br>getWindow().getDecorView()：获取顶级视图 DecorView。<br>findViewById(android.R.id.content)：获取 Xml 根布局的父容器。可想而知，不包括状态栏、标题栏（ActionBar）、导航栏。<br>对于视图层级，如果要深入了解的话，请参考<a href="https://www.jianshu.com/p/8766babc40e0" target="_blank" rel="noopener">这篇文章&gt;&gt;</a>。</p><hr><p><strong>参考资料</strong><br>1.<a href="https://www.jianshu.com/p/df4baad0591e" target="_blank" rel="noopener">Android 屏幕坐标系</a><br>2.<a href="https://www.cnblogs.com/tianzhijiexian/p/4097225.html" target="_blank" rel="noopener">得到view坐标的各种方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者已将本节的代码上传至 &lt;a href=&quot;https://github.com/tangxianming/AnimationPracticeApplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，大家可以结合着学习。
    
    </summary>
    
      <category term="Android动画基础" scheme="http://yoursite.com/categories/Android%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="坐标" scheme="http://yoursite.com/tags/%E5%9D%90%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>DecimalFormat使用详解</title>
    <link href="http://yoursite.com/2018/08/11/DecimalFormat%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/08/11/DecimalFormat使用详解/</id>
    <published>2018-08-11T03:16:06.000Z</published>
    <updated>2019-02-17T02:03:35.645Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>产品狗的需求：</strong><br>要求客户端拿到服务器返回的数据后，以最多保留2位小数的形式展示该数据。例如：2.247==&gt;2.25、2.20==&gt;2.2。</p></blockquote><a id="more"></a><p>拿到这个需求后，当然最先考虑的是使用<code>String.format(&quot;%.2f&quot;, 2.20)</code>,可是结果却是：<br><img src="/2018/08/11/DecimalFormat使用详解/1.jpg"><br>很显然，String.format的形式只能适用于固定的小数保留需求。<br>之后笔者在网上搜索了一圈，发现主要有DecimalFormat、BigDecimal、NumberFormat<a href="https://www.cnblogs.com/chenrenshui/p/6128444.html" target="_blank" rel="noopener">这几种方案</a>。鉴于它们的功能一样，本文就对DecimalFormat做一番研究。</p><h2 id="DecimalFormat-中的-0-和"><a href="#DecimalFormat-中的-0-和" class="headerlink" title="DecimalFormat 中的 0 和 #"></a>DecimalFormat 中的 0 和 #</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line">public class DecimalFormatTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[]args)&#123;</span><br><span class="line">DecimalFormat df1,df2;</span><br><span class="line">System.out.println(&quot;整数部分0/#的区别&quot;);</span><br><span class="line"></span><br><span class="line">df1 = new DecimalFormat(&quot;#.00&quot;);</span><br><span class="line">df2 = new DecimalFormat(&quot;0.00&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(df1.format(0.1)); // .10</span><br><span class="line">System.out.println(df2.format(0.1)); // 0.10  </span><br><span class="line"></span><br><span class="line">System.out.println(&quot;小数部分0/#的区别&quot;);</span><br><span class="line"></span><br><span class="line">df1 = new DecimalFormat(&quot;0.00&quot;);</span><br><span class="line">df2 = new DecimalFormat(&quot;0.##&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(df1.format(0.1)); // 0.10</span><br><span class="line">System.out.println(df2.format(0.1)); // 0.1</span><br><span class="line"></span><br><span class="line">System.out.println(df1.format(0.006)); // 0.01</span><br><span class="line">System.out.println(df2.format(0.006)); // 0.01</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;3、整数部分有多位&quot;);</span><br><span class="line"></span><br><span class="line">df1 = new DecimalFormat(&quot;0.00&quot;);</span><br><span class="line">df2 = new DecimalFormat(&quot;#.00&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(df1.format(2)); // 2.00</span><br><span class="line">System.out.println(df2.format(2)); // 2.00</span><br><span class="line"></span><br><span class="line">System.out.println(df1.format(20)); // 20.00</span><br><span class="line">System.out.println(df2.format(20)); // 20.00</span><br><span class="line"></span><br><span class="line">System.out.println(df1.format(200)); // 200.00</span><br><span class="line">System.out.println(df2.format(200)); // 200.00</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong><br>1、小数部分 #代表最多有几位，0代表必须有且只能有几位。<br>.00 表示最终结果有两位小数,没有则补0，多了就四舍五入第三个小数。<br>.## 表示最终结果最多有两位小数，一位或者没有都可以，多了同样四舍五入第三位。<br>2、整数部分 0 和 #。<br>当整数部分为0时，比如 0.1，# 此时认为整数部分不存在，所以不写 。0 认为没有至少也得一位，写上0。（这跟上面第一部分的表现是一致的：# 有就写，没有就不写；0 必须有，没有就补0。）<br>3、整数部分有多位时： 2；20；200。<br>由上面的结果可以看出 0和#对整数部分多位时的处理是一致的，就是有几位写多少位。（这跟上面两部分的表现是不一致的 在有多位时，0和#都没有匹配位数，而是有多少写多少。）<br>通常，我们使用的处理方式有： 0.00 或者 0.## 。<br><strong>实践：</strong><br>对于问题中的2.247==&gt;2.25、2.20==&gt;2.2，采用DecimalFormat实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new DecimalFormat(&quot;0.##&quot;).format(dd);</span><br></pre></td></tr></table></figure></p><h2 id="问题延伸"><a href="#问题延伸" class="headerlink" title="问题延伸"></a>问题延伸</h2><p><a href="https://blog.csdn.net/alanzyy/article/details/8465098" target="_blank" rel="noopener">1、DecimalFormat对数值格式化的舍入问题——RoundingMode。</a><br><a href="https://www.cnblogs.com/yjmyzz/p/4427669.html" target="_blank" rel="noopener">2、恶心的0.5四舍五入问题。</a><br>对于此条问题，笔者使用的方式是文中所提及的<code>在具体数据后加上0.000001</code>。<br>3、String.format对于浮点型数据的展示问题。<br>注意在精度要求高的情况下，<strong>String.format中使用的浮点数必须是双精度的</strong>，这样才能确保四舍五入的规则正确。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(&quot;%.2f&quot;, 2.245f));</span><br></pre></td></tr></table></figure></p><p>打印的结果是 2.24，错误。如果是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(&quot;%.2f&quot;, 2.245));</span><br></pre></td></tr></table></figure></p><p>打印的结果就是 2.25，正确。<br>为什么会这样呢？这里涉及到精度损耗的问题。在<code>String.format(&quot;%.2f&quot;, 2.245f)</code>中接受的数值应该是double类型的，所以2.245f 实际上是被转换为了double类型。而 java 将2.245f 强制转化为double类型后，得到的实际double类型值为：2.244999885559082。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;产品狗的需求：&lt;/strong&gt;&lt;br&gt;要求客户端拿到服务器返回的数据后，以最多保留2位小数的形式展示该数据。例如：2.247==&amp;gt;2.25、2.20==&amp;gt;2.2。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="DecimalFormat" scheme="http://yoursite.com/tags/DecimalFormat/"/>
    
  </entry>
  
  <entry>
    <title>由View.post()方法引发的想象</title>
    <link href="http://yoursite.com/2018/07/21/%E7%94%B1View-post-%E6%96%B9%E6%B3%95%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%B3%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/07/21/由View-post-方法引发的想象/</id>
    <published>2018-07-21T09:57:19.000Z</published>
    <updated>2020-02-26T13:55:57.639Z</updated>
    
    <content type="html"><![CDATA[<p>如题，笔者在想这个标题的时候思考了很久，不知道应该取一个什么样的标题才能涵盖全本篇要涉及的内容。绞尽脑子，最终确定起这个不痛不痒的标题。原因是，写这篇文章之前的一系列相关疑惑就是从View.post()开始的。<a id="more"></a><br>本篇要探究这么几个问题：<br>1、都知道非静态内部类和匿名类会引发内存泄露，并且我们也知道如何取避免这个问题的发生，但是怎样做得更加完美呢？<br>2、View.Post()中的run方法和Handler.post()方法中的run方法运行线程有什么不同呢？<br>3、View.Post()中的run方法在整个Activity的生命周期的里处在哪个位置呢？<br>好，以上三个问题就是我要总结的重点了。注意，下面对post方法将做的总结，对于postDelay同样适用。</p><h2 id="问题一的情况"><a href="#问题一的情况" class="headerlink" title="问题一的情况"></a>问题一的情况</h2><p>这个问题前面说过我们知道如何去避免它的发生，避免的方法可参考<a href="https://github.com/francistao/LearningNotes/blob/master/Part1/Android/Android内存泄漏总结.md" target="_blank" rel="noopener">这篇文章</a>。但是，对于真正的生产环境，这些还是不够的。所引文章中所提虽然避免了 Activity 泄漏，不过 Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列MessageQueue 中的消息。下面几个方法都可以移除 Message：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void removeCallbacks(Runnable r);</span><br><span class="line"></span><br><span class="line">public final void removeCallbacks(Runnable r, Object token);</span><br><span class="line"></span><br><span class="line">public final void removeCallbacksAndMessages(Object token);</span><br><span class="line"></span><br><span class="line">public final void removeMessages(int what);</span><br><span class="line"></span><br><span class="line">public final void removeMessages(int what, Object object);</span><br></pre></td></tr></table></figure></p><p>以上讨论的内容虽未提及View.post()系列，但是对于View.post()系列同样存在内存泄露的问题，我们可以用同样的方式避免，但是之后我们依然要记住removeCallbacks()噢。</p><h2 id="问题二的情况"><a href="#问题二的情况" class="headerlink" title="问题二的情况"></a>问题二的情况</h2><p>请允许我直接从<a href="https://stackoverflow.com/questions/41728973/what-is-the-difference-between-view-postdelayed-and-handler-postdelayed-on-t" target="_blank" rel="noopener">Stack Overflow</a>粘过来吧(别打我😜)<br>According to the documentation of Handler.postDelayed(Runnable r, long delayMillis):</p><blockquote><p>Causes the Runnable r to be added to the message queue, to be run after the specified amount of time elapses. The runnable will be run on the thread to which this handler is attached.</p></blockquote><p>On the other hand View.postDelayed(Runnable action, long delayMillis):</p><blockquote><p>Causes the Runnable to be added to the message queue, to be run after the specified amount of time elapses. The runnable will be run on the user interface thread.</p></blockquote><h2 id="问题三的情况"><a href="#问题三的情况" class="headerlink" title="问题三的情况"></a>问题三的情况</h2><p>探究这个问题主要是为了以后在post(new Runnable(){……})的run方法中写逻辑时，可以清晰的知道它在Activity的生命周期中所处的位置（这是很必要的，比如AnimationDrawable的start()方法只能在onStart()中或者之后执行才有效）。为了验证，我们直接上代码吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">tvContent=findViewById(R.id.tvContent);</span><br><span class="line">tvContent.post(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">Log.d(TAG, &quot;run&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void onStart() &#123;</span><br><span class="line">super.onStart();</span><br><span class="line">Log.d(TAG, &quot;onStart&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void onStop() &#123;</span><br><span class="line">super.onStop();</span><br><span class="line">Log.d(TAG, &quot;onStop&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void onPause() &#123;</span><br><span class="line">super.onPause();</span><br><span class="line">Log.d(TAG, &quot;onPause&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void onResume() &#123;</span><br><span class="line">super.onResume();</span><br><span class="line">Log.d(TAG, &quot;onResume&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void onAttachedToWindow() &#123;</span><br><span class="line">super.onAttachedToWindow();</span><br><span class="line">Log.d(TAG, &quot;onAttachedToWindow&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">super.onDestroy();</span><br><span class="line">Log.d(TAG, &quot;onDestroy&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码很简单，这里不多解释了，直接看运行结果吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onStart</span><br><span class="line">onResume</span><br><span class="line">onAttachedToWindow</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p><p>结论很明显了，此时的run方法处在onAttachedToWindow方法之后。题外话，对于onAttachedToWindow方法Google的解释是下面这样的：</p><blockquote><p>This is called when the view is attached to a window. At this point it has a Surface and will start drawing. Note that this function is guaranteed to be called before onDraw(android.graphics.Canvas), however it may be called any time before the first onDraw – including before or after onMeasure(int, int).<br>If you override this method you must call through to the superclass implementation.</p></blockquote><p>大概意思是onAttachedToWindow可以保证在首个ondraw方法调用前被调用。因此，我们可以很放心地将一些绘制之前的初始化操作放在onAttachedToWindow里面。</p><h2 id="问题延伸"><a href="#问题延伸" class="headerlink" title="问题延伸"></a>问题延伸</h2><h4 id="Context的应用场景"><a href="#Context的应用场景" class="headerlink" title="Context的应用场景"></a>Context的应用场景</h4><p>对于Application，Service，Activity三者的Context的应用场景是怎样的呢？直接盗用一张图吧：</p><img src="/2018/07/21/由View-post-方法引发的想象/image02.png"><p>大家注意看到有一些 NO 上添加了一些数字，其实这些从能力上来说是 YES ，但是为什么说是 NO 呢？下面逐个解释一下：<br>数字1：启动 Activity 在这些类中是可以的，但是需要<a href="https://www.cnblogs.com/xiaoQLu/archive/2012/07/17/2595294.html" target="_blank" rel="noopener">创建一个新的 task </a>（此类场景测试过程中，笔者发现 SDK 已自动为 Intent 加上了 FLAG_ACTIVITY_NEW_TASK 标签，不需要手动添加）。一般情况不推荐。<br>数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。<br>数字3：在 receiver 为 null 时允许，在 4.2 或以上的版本中，用于获取黏性广播的当前值。（可以无视）<br>注：ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个 context 用于使用。<br><a href="https://www.cnblogs.com/liyiran/p/5283551.html" target="_blank" rel="noopener">参考链接&gt;&gt;</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如题，笔者在想这个标题的时候思考了很久，不知道应该取一个什么样的标题才能涵盖全本篇要涉及的内容。绞尽脑子，最终确定起这个不痛不痒的标题。原因是，写这篇文章之前的一系列相关疑惑就是从View.post()开始的。
    
    </summary>
    
      <category term="Android 其它" scheme="http://yoursite.com/categories/Android-%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="内存泄露" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>Android演化历史</title>
    <link href="http://yoursite.com/2018/06/21/Android%E5%90%84%E7%89%88%E6%9C%AC%E4%BB%A3%E5%8F%B7%E3%80%81%E7%89%88%E6%9C%AC%E5%8F%B7%E3%80%81API%E7%BA%A7%E5%88%AB%E3%80%81%E5%8F%91%E5%B8%83%E6%97%B6%E9%97%B4%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/06/21/Android各版本代号、版本号、API级别、发布时间对照表/</id>
    <published>2018-06-21T15:06:09.000Z</published>
    <updated>2020-02-26T13:55:57.638Z</updated>
    
    <content type="html"><![CDATA[<p>Android开发过程中，经常会遇到类似于这个版本号对应的API级别是多少？这个API级别对应的版本号是多少？这样的问题。本文就以此为出发点，详细的介绍一下Android的版本演化进程。一是为了下次再遇到前面说的问题时能够快速查找本文得到答案，二是让自己对Android发展历程有一个清晰的思路。<a id="more"></a></p><h2 id="对照表"><a href="#对照表" class="headerlink" title="对照表"></a>对照表</h2><table><thead><tr><th>版本号</th><th>API级别</th><th style="text-align:center">代号</th><th style="text-align:right">发布时间</th></tr></thead><tbody><tr><td>Android 9.0</td><td>28</td><td style="text-align:center">P</td><td style="text-align:right">2018-3</td></tr><tr><td>Android 8.1</td><td>27</td><td style="text-align:center">Oreo</td><td style="text-align:right"></td></tr><tr><td>Android 8.0</td><td>26</td><td style="text-align:center">Oreo</td><td style="text-align:right">2017-3</td></tr><tr><td>Android 7.1.1</td><td>25</td><td style="text-align:center">Nougat</td><td style="text-align:right">2016-10</td></tr><tr><td>Android 7.0</td><td>24</td><td style="text-align:center">Nougat</td><td style="text-align:right">2016-08</td></tr><tr><td>Android 6.0</td><td>23</td><td style="text-align:center">Marshmallow</td><td style="text-align:right">2015-10</td></tr><tr><td>Android 5.1</td><td>22</td><td style="text-align:center">Lollipop</td><td style="text-align:right">2015-03</td></tr><tr><td>Android 5.0</td><td>21</td><td style="text-align:center">Lollipop</td><td style="text-align:right">2014-11</td></tr><tr><td>Android 4.4W</td><td>20</td><td style="text-align:center">KitKat</td><td style="text-align:right">2014-06</td></tr><tr><td>Android 4.4</td><td>19</td><td style="text-align:center">KitKat</td><td style="text-align:right">2013-10</td></tr><tr><td>Android 4.3</td><td>18</td><td style="text-align:center">Jelly Bean</td><td style="text-align:right">2013-07</td></tr><tr><td>Android 4.2</td><td>17</td><td style="text-align:center">Jelly Bean</td><td style="text-align:right">2012-11</td></tr><tr><td>Android 4.1</td><td>16</td><td style="text-align:center">Jelly Bean</td><td style="text-align:right">2012-07</td></tr><tr><td>Android 4.0.3</td><td>15</td><td style="text-align:center">Ice Cream Sandwich</td><td style="text-align:right">2011-12</td></tr><tr><td>Android 4.0</td><td>14</td><td style="text-align:center">Ice Cream Sandwich</td><td style="text-align:right">2011-10</td></tr><tr><td>Android 3.2</td><td>13</td><td style="text-align:center">Honeycomb</td><td style="text-align:right">2011-07</td></tr><tr><td>Android 3.1</td><td>12</td><td style="text-align:center">Honeycomb</td><td style="text-align:right">2011-05</td></tr><tr><td>Android 3.0</td><td>11</td><td style="text-align:center">Honeycomb</td><td style="text-align:right">2011-02</td></tr><tr><td>Android 2.3.3</td><td>10</td><td style="text-align:center">Gingerbread</td><td style="text-align:right">2011-02</td></tr><tr><td>Android 2.3</td><td>9</td><td style="text-align:center">Gingerbread</td><td style="text-align:right">2010-12</td></tr><tr><td>Android 2.2</td><td>8</td><td style="text-align:center">Froyo</td><td style="text-align:right">2010-05</td></tr><tr><td>Android 2.1</td><td>7</td><td style="text-align:center">Eclair</td><td style="text-align:right">2010-01</td></tr><tr><td>Android 2.0.1</td><td>6</td><td style="text-align:center">Eclair</td><td style="text-align:right">2009-12</td></tr><tr><td>Android 2.0</td><td>5</td><td style="text-align:center">Eclair</td><td style="text-align:right">2009-10</td></tr><tr><td>Android 1.6</td><td>4</td><td style="text-align:center">Donut</td><td style="text-align:right">2009-09</td></tr><tr><td>Android 1.5</td><td>3</td><td style="text-align:center">Cupcake</td><td style="text-align:right">2009-04</td></tr><tr><td>Android 1.1</td><td>2</td><td style="text-align:center"></td><td style="text-align:right">2009-02</td></tr><tr><td>Android 1.0</td><td>1</td><td style="text-align:center"></td><td style="text-align:right">2008-09</td></tr></tbody></table><h2 id="Android-重要历史版本功能"><a href="#Android-重要历史版本功能" class="headerlink" title="Android 重要历史版本功能"></a>Android 重要历史版本功能</h2><h4 id="Android-7-0"><a href="#Android-7-0" class="headerlink" title="Android 7.0"></a>Android 7.0</h4><ul><li>多语言区域支持，更多语言</li><li>多窗口支持</li><li>新增的表情符号<br><a href="https://developer.android.com/about/versions/nougat/android-7.0" target="_blank" rel="noopener">see more>></a></li></ul><h4 id="Android-6-0"><a href="#Android-6-0" class="headerlink" title="Android 6.0"></a>Android 6.0</h4><ul><li>运行时权限及其管理</li><li>低电耗模式和应用待机模式</li><li>文本选择</li><li>WLAN 和网络连接变更</li><li>指纹身份验证</li><li>主题化 ColorStateList<br><a href="https://developer.android.com/about/versions/marshmallow/" target="_blank" rel="noopener">see more>></a></li></ul><h4 id="Android-5-0"><a href="#Android-5-0" class="headerlink" title="Android 5.0"></a>Android 5.0</h4><ul><li>Material Design</li><li>全新的通知中心设计</li><li>支持64位ART虚拟机<br><a href="https://developer.android.com/about/versions/lollipop" target="_blank" rel="noopener">see more>></a></li></ul><h4 id="Android-4-4"><a href="#Android-4-4" class="headerlink" title="Android 4.4"></a>Android 4.4</h4><ul><li>全屏沉浸模式</li><li>透明系统 UI 样式</li><li>用于动画场景的转场框架</li><li>屏幕录制</li><li>步测器和计步器<br><a href="https://developer.android.com/about/versions/kitkat" target="_blank" rel="noopener">see more>></a></li></ul><h2 id="其它知识"><a href="#其它知识" class="headerlink" title="其它知识"></a>其它知识</h2><h4 id="Android-中如何选择-compileSdkVersion-minSdkVersion-和-targetSdkVersion"><a href="#Android-中如何选择-compileSdkVersion-minSdkVersion-和-targetSdkVersion" class="headerlink" title="Android 中如何选择 compileSdkVersion, minSdkVersion 和 targetSdkVersion"></a>Android 中如何选择 compileSdkVersion, minSdkVersion 和 targetSdkVersion</h4><p><a href="https://www.imooc.com/article/43291?block_id=tuijian_wz" target="_blank" rel="noopener">参考文章一</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0118/3881.html" target="_blank" rel="noopener">参考文章二</a></p><hr><p><strong>参考资料</strong><br><a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element#ApiLevels" target="_blank" rel="noopener">Android平台版本对比</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android开发过程中，经常会遇到类似于这个版本号对应的API级别是多少？这个API级别对应的版本号是多少？这样的问题。本文就以此为出发点，详细的介绍一下Android的版本演化进程。一是为了下次再遇到前面说的问题时能够快速查找本文得到答案，二是让自己对Android发展历程有一个清晰的思路。
    
    </summary>
    
      <category term="Android 其它" scheme="http://yoursite.com/categories/Android-%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="Android 演化历史" scheme="http://yoursite.com/tags/Android-%E6%BC%94%E5%8C%96%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
</feed>
