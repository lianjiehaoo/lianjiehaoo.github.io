<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唐先明de博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-16T14:45:53.363Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>TXM</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin 学习及使用笔记（进行中...）</title>
    <link href="http://yoursite.com/2019/10/28/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/10/28/Kotlin学习笔记/</id>
    <published>2019-10-28T04:08:10.000Z</published>
    <updated>2019-12-16T14:45:53.363Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章将长期记录并解答笔者在学习使用 Kotlin 过程中所遇到的问题点，参考资料会以 <code>扔物线</code> 老师的 <a href="https://kaixue.io" target="_blank" rel="noopener">码上开学系列教程</a> 和 <a href="https://www.kotlincn.net/docs/reference/whatsnew13.html" target="_blank" rel="noopener">Kotlin 官方教程</a> 为主，同时也会配合参考其他优秀文章。<a id="more"></a></p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>Java 的单例模式通常实现起来稍显繁琐，包含大量的模板代码，具体使用可参考<a href="https://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">这篇文章</a>。<br>而 Kotlin 实现单例模式是非常便捷的，只需使用 <code>object</code> 关键字即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 👇 class 替换成了 object</span><br><span class="line">object A &#123;</span><br><span class="line">    val number: Int = 1</span><br><span class="line">    fun method() &#123;</span><br><span class="line">        println(&quot;A.method()&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 Android studio 转换工具将上面代码转成 Java 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final class A &#123;</span><br><span class="line">   private static final int number = 1;</span><br><span class="line">   public static final A INSTANCE;</span><br><span class="line"></span><br><span class="line">   public final int getNumber() &#123;</span><br><span class="line">      return number;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final void method() &#123;</span><br><span class="line">      String var1 = &quot;A.method()&quot;;</span><br><span class="line">      boolean var2 = false;</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      A var0 = new A();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">      number = 1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，实际上这种通过 <code>object</code> 实现的单例是一个饿汉式的单例，并且实现了线程安全。</p><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>Java 一共有四大代码块，可参考<a href="https://juejin.im/entry/5876f05a2f301e005772fb07" target="_blank" rel="noopener">这篇文章</a>，需要注意的是，文章中最后提到的同步代码块中对静态代码块的解释有误，如果要了解 java 中的同步代码块知识，可以移步到笔者之前写的<a href="https://kimball325.github.io/2016/12/18/Java并发编程-Synchronized/" target="_blank" rel="noopener">这篇文章</a>。<br>Kotlin 中的构造代码块和静态代码块有了一些变化，先来看构造代码块。<br>Java 是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        // 初始化代码块，先于下面的构造器执行</span><br><span class="line">    &#125;</span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而 Kotlin 是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        // 初始化代码块，先于下面的构造器执行</span><br><span class="line">    &#125;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于静态代码块， Java 是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Sample &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而 Kotlin 是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Sample &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        init &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="访问限制符"><a href="#访问限制符" class="headerlink" title="访问限制符"></a>访问限制符</h4><p>Java 的访问限制符可以参考<a href="https://www.runoob.com/java/java-modifier-types.html#protected-desc" target="_blank" rel="noopener">这篇文章</a>访问控制修饰符部分。其中，如下几个知识点需要注意一下：</p><blockquote><p>1、<strong>子类与基类在同一包中</strong>：被声明为 protected 或 default 的变量、方法和构造器能被同一个包中的任何其他类访问。<br>2、<strong>子类与基类不在同一包中</strong>：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的 protected 方法。同时，在子类中既不能访问其从基类继承而来的 default 方法，也不能访问基类实例的 default 方法。（变量、构造器同理。）<br>3、子类可以对从父类继承的方法加宽访问范围。访问控制符的访问范围有大到小排序是：public &gt; protect &gt;  default &gt; private。</p></blockquote><p>对于Kotlin的访问控制符，直接参考码上开学吧。</p><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>首先我们来看使用内联函数的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline fun log() &#123;</span><br><span class="line">    println(&quot;log1&quot;)</span><br><span class="line">    println(&quot;log2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    log()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反编译成 Java 的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static final void log() &#123;</span><br><span class="line">     String var1 = &quot;log1&quot;;</span><br><span class="line">     System.out.println(var1);</span><br><span class="line">     var1 = &quot;log2&quot;;</span><br><span class="line">     System.out.println(var1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">     Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">     String var1 = &quot;log1&quot;;</span><br><span class="line">     System.out.println(var1);</span><br><span class="line">     var1 = &quot;log2&quot;;</span><br><span class="line">     System.out.println(var1);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>而我们去掉 inline 关键字后，再反编译成 Java 代码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static final void log() &#123;</span><br><span class="line">    String var0 = &quot;log1&quot;;</span><br><span class="line">    System.out.println(var0);</span><br><span class="line">    var0 = &quot;log2&quot;;</span><br><span class="line">    System.out.println(var0);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">    Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">    log();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>如上可以看到，使用内联函数可以减少一层函数的调用栈，但如果有多个地方调用内联函数的话，就会隐式地增加编译后代码的行数。那么如果正确使用内联函数呢，或者说它到底有什么用？有如下几个使用场景：</p><p>1、函数参数包含函数类型的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class View &#123;</span><br><span class="line">    inline fun setOnClickListener(listener: (View) -&gt; Unit) &#123;</span><br><span class="line">        listener(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果不使用内联函数，由于 setOnClickListener 使用的是函数类型的参数，那么在调用时会产生一个额外的对象，具体的过程可以反编译成 Java 文件后看看。</p><p>2、泛型具体化。<br>平时我们使用泛型时，是不能直接对泛型类型进行操作的。比如下面的操作会导致编译不通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; excute() &#123;</span><br><span class="line">    func(T::class.java) //编译器报错：Cannot use &apos;T&apos; as reified type parameter. Use a class instead.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大意是：不能使用泛型 T 作为具体的类型参数。如果依照 Java 的解决方式，可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; excute(class: Class&lt;T&gt;) &#123;</span><br><span class="line">    func(class)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过， Kotlin 中有更加方便的用法，也就是使用 inline 关键字达到让泛型具体化的目标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;reified T&gt; excute() &#123;</span><br><span class="line">    func(T::class.java)</span><br><span class="line">&#125;</span><br><span class="line">//PS：使用时还需在泛型声明前加上 refied 关键字，才能让泛型真正具体化。</span><br></pre></td></tr></table></figure></p><blockquote><p>Retrofit 最新拓展中，内部已经实现了一个内联函数用来代替旧版本创建实例的方式。具体可参考 <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit2/KotlinExtensions.kt" target="_blank" rel="noopener">Retrofit.create()</a> 拓展方法。</p></blockquote><h4 id="Kotlin-委托"><a href="#Kotlin-委托" class="headerlink" title="Kotlin 委托"></a>Kotlin 委托</h4><p><a href="https://www.runoob.com/kotlin/kotlin-delegated.html" target="_blank" rel="noopener">参考地址&gt;&gt;</a><br>上面的文章中，笔者认为只需要理解从开篇到“把属性储存在映射中”部分的内容，剩下的内容读者自行斟酌其重要性吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章将长期记录并解答笔者在学习使用 Kotlin 过程中所遇到的问题点，参考资料会以 &lt;code&gt;扔物线&lt;/code&gt; 老师的 &lt;a href=&quot;https://kaixue.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;码上开学系列教程&lt;/a&gt; 和 &lt;a href=&quot;https://www.kotlincn.net/docs/reference/whatsnew13.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kotlin 官方教程&lt;/a&gt; 为主，同时也会配合参考其他优秀文章。
    
    </summary>
    
      <category term="Android 其它" scheme="http://yoursite.com/categories/Android-%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Java数据类型解析</title>
    <link href="http://yoursite.com/2019/10/24/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/24/Java基本数据类型解析/</id>
    <published>2019-10-24T02:09:10.000Z</published>
    <updated>2019-12-16T14:45:53.362Z</updated>
    
    <content type="html"><![CDATA[<p>Java 数据类型的问题不是 Java 开发中的难点，而且问题一般都能在编译的时候就显现出来，可是知道它的原理对于写出高质量的代码的很有帮助的。本文将详细介绍 Java 数据类型相关的知识，必须要提的是，本文的大部分知识来源于网上的优秀文章（文末有给链接），笔者只是在理解它们的基础上重新排版并增加了一些补充的内容。<a id="more"></a></p><h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><p>Java 的数据类型有两类：<br>1、值类型（又叫内置数据类型，基本数据类型）<br>2、引用类型（除值类型以外，都是引用类型，包括 String、数组）</p><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>Java 语言提供了 8 种值类型，大致分为 4 类：</p><ul><li>整型：byte 、short 、int 、long</li><li>浮点型：float 、 double</li><li>字符型：char</li><li>布尔型：boolean</li></ul><img src="/2019/10/24/Java基本数据类型解析/1.png"><h4 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h4><p>从概念方面来说</p><ul><li>值类型：变量名指向具体的数值。</li><li>引用类型：变量名指向存数据对象的内存地址。</li></ul><p>从内存方面来说</p><ul><li>值类型：变量在声明之后，Java 就会立刻分配给他内存空间。</li><li>引用类型：它以特殊的方式（类似 C 指针）指向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址。</li></ul><p>从使用方面来说</p><ul><li>基本类型：使用时需要赋具体值,判断时使用 == 号。</li><li>引用类型：使用时可以赋 null，判断时使用 equals 方法。</li></ul><blockquote><p><strong>扩展阅读</strong><br><a href="https://juejin.im/post/59cd71835188255d3448faf6" target="_blank" rel="noopener">Java 基本数据类型和引用类型</a><br>这篇文章对于基本数据类型和引用类型的内存存储讲述比较生动。<br><a href="https://github.com/francistao/LearningNotes/blob/master/Part1/Android/Android内存泄漏总结.md" target="_blank" rel="noopener">Android 内存泄漏总结</a><br>这篇文章对于 Java 的内存存储机制讲得比较透彻。</p></blockquote><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><p>将一种类型的值赋值给另一种类型是很常见的。在 Java 中，boolean 类型与其他 7 种类型的数据都不能进行转换，这一点很明确。但对于其他 7 种数据类型，它们之间都可以进行转换，只是可能会存在精度损失或其他一些变化。Java 中，值类型转换有两种方式：<br>1、自动转换（隐式）：无需任何操作。<br>2、强制转换（显式）：需使用转换操作符（type）。<br>将6种数据类型按下面顺序排列一下：<br>double &gt; float &gt; long &gt; int &gt; short &gt; byte<br>如果从小转换到大，那么可以自动转换，而从大到小，则必须使用强制转换。需要注意的是，对于 char 类型，除 char 转 double、float、long、int 可以自动转换外，对于 char 的剩余情况的转换必须要强制转换。</p><blockquote><p><strong>扩展阅读：</strong><br><a href="https://www.w3cschool.cn/java/java-char-data-type.html" target="_blank" rel="noopener">Java char数据类型</a><br>全面理解 char 基本类型数据的使用方法。<br><a href="https://www.cnblogs.com/zlj843767688/p/9751702.html" target="_blank" rel="noopener">原码反码补码</a><br><a href="https://www.cnblogs.com/bt21cn/p/7527194.html" target="_blank" rel="noopener">byte类型的最小值为什么是-128而非-127</a><br>关于数据类型表示的数据范围问题</p></blockquote><h4 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h4><p>自动转换因为较大的类型（如int）要保存较小的类型（如byte），内存总是足够的，不需要强制转换。如果将字面值保存到byte、short、char、long的时候，也会自动进行类型转换，注意区别，此时从int（没有带 L 的整型字面值为 int）到byte/short/char也是自动完成的，虽然它们都比 int 小，但是有个限制是字面值必须要在目标类型的取值范围内，超过了目标的取值范围，则还是需要强转，例如：byte b=1 是没有问题的，而byte b=200 就必须写成 byte b=(byte)200 了，因为 byte 的取值范围是 [-128,127] 。</p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>如果要把大的转成小的，就必须强制转换。强制转换采用转换操作符（）。严格地说，将byte转为char不属于强制转换，因为从byte到char的过程其实是byte–&gt;int–&gt;char，所以自动转换和强制转换都有。强制转换除了可能的精度损失外，还可能使模发生变化。强制转换格式如下：</p><blockquote><p>(target-type) value;</p></blockquote><p>如果整数的值超出了byte所能表示的范围，结果将对byte类型的范围取余数。例如a=256超出了byte的[-128,127]的范围，所以将257除以byte的范围（256）取余数得到b=1；需要注意的是，当a=200时，此时除了256取余数应该为-56，而不是200。<br>将浮点类型赋给整数类型的时候，会发生截尾。也就是把小数的部分去掉，只留下整数部分。此时如果整数超出目标类型范围，一样将对目标类型的范围取余数。</p><h4 id="赋值及表达式中的类型转换"><a href="#赋值及表达式中的类型转换" class="headerlink" title="赋值及表达式中的类型转换"></a>赋值及表达式中的类型转换</h4><p>1、字面值赋值<br>在使用字面值对整数赋值的过程中，可以将 int 字面值赋值给byte short char int，只要不超出范围。这个过程中的类型转换时自动完成的，但是如果你试图将long 字面值赋给byte，即使没有超出范围，也必须进行强制类型转换。例如 byte b = 10L；是错的，要进行强制转换。<br>2、表达式中的自动类型提升<br>除了赋值以外，表达式计算过程中也可能发生一些类型转换。在表达式中，类型提升规则如下：</p><ul><li>所有byte/short/char都被提升为int。</li><li>如果有一个操作数为long，整个表达式提升为long。float和double情况也一样。</li></ul><h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><h4 id="包装类、装箱、拆箱"><a href="#包装类、装箱、拆箱" class="headerlink" title="包装类、装箱、拆箱"></a>包装类、装箱、拆箱</h4><p>Java 中为每一种基本数据类型提供了相应的包装类，如下：</p><blockquote><p>Byte &lt;-&gt; byte<br>Short &lt;-&gt; short<br>Integer &lt;-&gt; int<br>Long &lt;-&gt; long<br>Float &lt;-&gt; float<br>Double &lt;-&gt; double<br>Character &lt;-&gt; char<br>Boolean &lt;-&gt; boolean</p></blockquote><p>引入包装类的目的就是：提供一种机制，使得值类型可以与引用类型互相转换。<br>基本数据类型与包装类的转换被称为装箱和拆箱。</p><ul><li>装箱是将值类型转换为引用类型，例如：int 转 Integer。装箱过程是通过调用包装类的 valueOf 方法实现的。</li><li>拆箱是将引用类型转换为值类型，例如：Integer 转 int。拆箱过程是通过调用包装类的 xxxValue 方法实现的。（xxx 代表对应的基本数据类型）。</li></ul><h4 id="自动装箱、自动拆箱"><a href="#自动装箱、自动拆箱" class="headerlink" title="自动装箱、自动拆箱"></a>自动装箱、自动拆箱</h4><p>值类型的自动装箱、拆箱自 JDK 5 开始提供的功能。自动装箱与拆箱的机制可以让我们在 Java 的变量赋值或者是方法调用等情况下使用原始类型或者对象类型更加简单直接。<br>因为自动装箱会隐式地创建对象，如果在一个循环体中，会创建无用的中间对象，这样会增加 GC 压力，拉低程序的性能。所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作。<br>JDK 5 之前的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = new Integer(10); // 非自动装箱</span><br></pre></td></tr></table></figure></p><p>JDK 5 之后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i2 = 10; // 自动装箱</span><br></pre></td></tr></table></figure></p><p>Java 对于自动装箱和拆箱的设计，依赖于一种叫做享元模式的设计模式（笔者也没有具体去了解过，有兴趣的朋友可以去研究下）。</p><blockquote><p><strong>扩展阅读：</strong><br><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">深入剖析 Java 中的装箱和拆箱</a><br>结合示例，一步步阐述装箱和拆箱原理。</p></blockquote><h4 id="装箱、拆箱的应用和注意点"><a href="#装箱、拆箱的应用和注意点" class="headerlink" title="装箱、拆箱的应用和注意点"></a>装箱、拆箱的应用和注意点</h4><p>装箱、拆箱应用场景:<br>1、一种最普通的场景是：调用一个含类型为 Object 参数的方法，该 Object 可支持任意类型（因为 Object 是所有类的父类），以便通用。当你需要将一个值类型（如 int）传入时，需要使用 Integer 装箱。<br>2、一个非泛型的容器，同样是为了保证通用，而将元素类型定义为 Object。于是，要将值类型数据加入容器时，需要装箱。<br>3、当 == 运算符的两个操作，一个操作数是包装类，另一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = 10; // 自动装箱</span><br><span class="line">Integer i2 = new Integer(10); // 非自动装箱</span><br><span class="line">Integer i3 = Integer.valueOf(10); // 非自动装箱</span><br><span class="line">int i4 = new Integer(10); // 自动拆箱</span><br><span class="line">int i5 = i2.intValue(); // 非自动拆箱</span><br><span class="line">System.out.println(&quot;i1 = [&quot; + i1 + &quot;]&quot;);</span><br><span class="line">System.out.println(&quot;i2 = [&quot; + i2 + &quot;]&quot;);</span><br><span class="line">System.out.println(&quot;i3 = [&quot; + i3 + &quot;]&quot;);</span><br><span class="line">System.out.println(&quot;i4 = [&quot; + i4 + &quot;]&quot;);</span><br><span class="line">System.out.println(&quot;i5 = [&quot; + i5 + &quot;]&quot;);</span><br><span class="line">System.out.println(&quot;i1 == i2 is [&quot; + (i1 == i2) + &quot;]&quot;);</span><br><span class="line">System.out.println(&quot;i1 == i4 is [&quot; + (i1 == i4) + &quot;]&quot;); // 自动拆箱</span><br><span class="line">// Output:</span><br><span class="line">// i1 = [10]</span><br><span class="line">// i2 = [10]</span><br><span class="line">// i3 = [10]</span><br><span class="line">// i4 = [10]</span><br><span class="line">// i5 = [10]</span><br><span class="line">// i1 == i2 is [false]</span><br><span class="line">// i1 == i4 is [true]</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>示例说明：</strong><br>上面的例子，虽然简单，但却隐藏了自动装箱、拆箱和非自动装箱、拆箱的应用。从例子中可以看到，明明所有变量都初始化为数值 10 了，但为何会出现 i1 == i2 is [false] 而 i1 == i4 is [true] ？<br>原因在于：<br>i1、i2 都是包装类，使用 == 时，Java 将它们当做两个对象，而非两个 int 值来比较，所以两个对象自然是不相等的。正确的比较操作应该使用 equals 方法。<br>i1 是包装类，i4 是基础数据类型，使用 == 时，Java 会将两个 i1 这个包装类对象自动拆箱为一个 int 值，再代入到 == 运算表达式中计算；最终，相当于两个 int 进行比较，由于值相同，所以结果相等。</p></blockquote><p>装箱、拆箱应用注意点:<br>1、装箱操作会创建对象，频繁的装箱操作会造成不必要的内存消耗，影响性能。所以应该尽量避免装箱。<br>2、基础数据类型的比较操作使用 ==，包装类的比较操作使用 equals 方法。</p><hr><p><strong>参考资料</strong><br><a href="https://juejin.im/post/5c851ab2e51d4520d33183c3" target="_blank" rel="noopener">深入理解 Java 基本数据类型</a><br><a href="https://zhuanlan.zhihu.com/p/25439066" target="_blank" rel="noopener">Java 基本数据类型 - 四类八种</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 数据类型的问题不是 Java 开发中的难点，而且问题一般都能在编译的时候就显现出来，可是知道它的原理对于写出高质量的代码的很有帮助的。本文将详细介绍 Java 数据类型相关的知识，必须要提的是，本文的大部分知识来源于网上的优秀文章（文末有给链接），笔者只是在理解它们的基础上重新排版并增加了一些补充的内容。
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据类型" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>ConstraintLayout布局使用指南</title>
    <link href="http://yoursite.com/2019/10/18/ConstraintLayout%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2019/10/18/ConstraintLayout布局使用指南/</id>
    <published>2019-10-17T22:18:40.000Z</published>
    <updated>2019-12-17T14:16:57.579Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是参看了掘金网的<a href="https://juejin.im/entry/5a0f93b4f265da432717ce87" target="_blank" rel="noopener">这篇文章</a>后，对 ConstraintLayout 布局的一个补充说明。<a id="more"></a></p><h2 id="Visibility-behavior"><a href="#Visibility-behavior" class="headerlink" title="Visibility behavior"></a>Visibility behavior</h2><p>ConstraintLayout 对可见行被标记为 GONE 的 View 有特殊的处理方式。下面来谈谈 android:layout_margin 和 app:layout_goneMargin 的区别：<br>1、android:layout_margin 一直有作用，即使目标 View 已经隐藏。<br><img src="/2019/10/18/ConstraintLayout布局使用指南/1.png"><br>2、app:layout_goneMargin 只是在目标 View 隐藏时起作用。<br>同时声明时，后者的优先级大于前者。一般情况下会同时使用这两种属性以达到目标 View 不同显示状态下当前 View 的不同 Margin 效果。</p><h2 id="Virtual-Helpers-objects"><a href="#Virtual-Helpers-objects" class="headerlink" title="Virtual Helpers objects"></a>Virtual Helpers objects</h2><h4 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h4><p>Barrier，直译为障碍、屏障。在约束布局中，可以使用属性 constraint_referenced_ids 来引用多个带约束的组件，从而将它们看作一个整体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">android:id=&quot;@+id/button1&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;100dp&quot;</span><br><span class="line">android:text=&quot;Button1&quot;</span><br><span class="line">app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:id=&quot;@+id/button2&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;200dp&quot;</span><br><span class="line">android:text=&quot;Button2&quot;</span><br><span class="line">app:layout_constraintLeft_toRightOf=&quot;@id/button1&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.constraint.Barrier</span><br><span class="line">android:id=&quot;@+id/barrier1&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">app:barrierDirection=&quot;bottom&quot;</span><br><span class="line">app:constraint_referenced_ids=&quot;button1,button2&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;TextView</span><br><span class="line">android:id=&quot;@+id/bottom_textview&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:text=&quot;stone&quot;</span><br><span class="line">app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toBottomOf=&quot;@id/barrier1&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>上面的 TextView 会在 button1 和 button2 这个整体的下面。如果将 app:constraint_referenced_ids=”button1, button2” 中的 button2 去掉，会发现，TextView 会仅在 button1 的下面。</p><h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><p>组的目的在于（且只能）同时控制多个控件的 Visibility 属性。<strong>但是有以下需要注意的地方。</strong><br>1、单独设置组内控件的 Visibility 无效。<br>2、当有多个组引用了同一个 View ，该 View 的 Visible 属性由最后定义的组决定。</p><h4 id="Layer-Added-in-2-0"><a href="#Layer-Added-in-2-0" class="headerlink" title="Layer(Added in 2.0)"></a>Layer(Added in 2.0)</h4><p>同时需要对一组 View 做统一操作或者需要在 View 集合后面加个背景都可以。同时，他可以实现 Group 的功能。<a href="https://github.com/feng0403/ConstraintLayoutSamples/blob/master/app/src/main/java/cn/feng/constraintlayoutsample/activity/LayerActivity.kt" target="_blank" rel="noopener">实例代码参考&gt;&gt;</a></p><h4 id="Flow-Added-in-2-0"><a href="#Flow-Added-in-2-0" class="headerlink" title="Flow(Added in 2.0)"></a>Flow(Added in 2.0)</h4><p>用引用的方式来避免布局嵌套，代替 LinearLayout 的功能。<a href="https://juejin.im/post/5d0c46246fb9a07ec9561573" target="_blank" rel="noopener">参考链接&gt;&gt;</a></p><h4 id="Placeholder"><a href="#Placeholder" class="headerlink" title="Placeholder"></a>Placeholder</h4><p><a href="https://www.jianshu.com/p/4b23e789befb" target="_blank" rel="noopener">参考地址</a><br>Placeholder （占位符）用于和一个视图关联起来，通过 setContentId() 方法将占位符转换为指定的视图，即视图将在占位符所在位置上显示。当原视图已在 Placeholder 中显示时，原视图将从原有位置消失。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">android:id=&quot;@+id/btn_setContentId&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:onClick=&quot;setContentId&quot;</span><br><span class="line">android:text=&quot;setContentId&quot;</span><br><span class="line">android:textAllCaps=&quot;false&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;ImageView</span><br><span class="line">android:id=&quot;@+id/iv_target&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:src=&quot;@drawable/ic_launcher_background&quot;</span><br><span class="line">app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toBottomOf=&quot;@id/btn_setContentId&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.constraint.Placeholder</span><br><span class="line">android:id=&quot;@+id/placeholder&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Placeholder placeholder = findViewById(R.id.placeholder);</span><br><span class="line">placeholder.setContentId(R.id.iv_target);</span><br></pre></td></tr></table></figure><img src="/2019/10/18/ConstraintLayout布局使用指南/4.webp"><p>此外也可以直接在布局文件中将占位符和视图 ID 绑定在一起<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.constraint.Placeholder</span><br><span class="line">android:id=&quot;@+id/placeholder&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">app:content=&quot;@id/iv_target&quot;</span><br><span class="line">app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br></pre></td></tr></table></figure></p><h2 id="ConstrainSet"><a href="#ConstrainSet" class="headerlink" title="ConstrainSet"></a>ConstrainSet</h2><p>动态修改布局，<a href="https://juejin.im/post/5b503fb2e51d45191d79ee30" target="_blank" rel="noopener">参考链接&gt;&gt;</a></p><blockquote><p>防止布局中有无 id 控件，可以设置 isForceId = false 。</p></blockquote><h2 id="循环定位"><a href="#循环定位" class="headerlink" title="循环定位"></a>循环定位</h2><p>一个小部件的中心可以以一定角度和距离限制相对于另一个小部件的中心。这允许你将一个小部件放在一个圆上。可以使用以下属性：<br>1、layout_constraintCircle ：引用另一个小部件ID<br>2、layout_constraintCircleRadius ：到其他小部件中心的距离<br>3、layout_constraintCircleAngle ：小部件应处于的角度（度数，从0到360）</p><img src="/2019/10/18/ConstraintLayout布局使用指南/2.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">android:id=&quot;@+id/bt_1&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">android:id=&quot;@+id/bt_2&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">app:layout_constraintCircle=&quot;@+id/bt_1&quot;</span><br><span class="line">app:layout_constraintCircleAngle=&quot;45&quot;</span><br><span class="line">app:layout_constraintCircleRadius=&quot;100dp&quot; /&gt;</span><br></pre></td></tr></table></figure><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p><a href="https://developer.android.google.cn/reference/android/support/constraint/Group" target="_blank" rel="noopener">参考官方文档&gt;&gt;</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是参看了掘金网的&lt;a href=&quot;https://juejin.im/entry/5a0f93b4f265da432717ce87&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;后，对 ConstraintLayout 布局的一个补充说明。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="ConstraintLayout" scheme="http://yoursite.com/tags/ConstraintLayout/"/>
    
  </entry>
  
  <entry>
    <title>Android 问题汇总（进行中...）</title>
    <link href="http://yoursite.com/2019/09/18/Android%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/09/18/Android问题汇总和解决方案/</id>
    <published>2019-09-18T11:29:11.000Z</published>
    <updated>2019-12-16T14:55:29.243Z</updated>
    
    <content type="html"><![CDATA[<p>本文将长期记录并解答笔者在 Android 开发过程中所遇到的问题，这些问题一般是几句话就能概括并且不需要单独成文讲解的。<a id="more"></a></p><h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><p><strong>1、Host 这个 Header的作用是？</strong><br>答：仅用于找到目标主机后确认子主机的域名和端口。<br>解释：Host表示服务器主机地址，这个地址是子主机的地址，或者说是子主机的域名（也可以是IP地址）。<br><a href="https://blog.csdn.net/netdxy/article/details/51195560" target="_blank" rel="noopener">参考地址&gt;&gt;</a><br><strong>2、Host 为什么不放在请求行和 Path 一起拼凑使用，而是单独作为 Header ？</strong><br>答：请求行中的 Path 是给子主机确定访问路径用的，而 Host 是给主主机确认访问的子主机用的。两个的用途不一样，前者给子主机用，后者给主主机用。<br><strong>3、Http 协议中主主机的 IP 地址是何时确定的？</strong><br>答：是在 Http 请求发送之前通过DNS域名解析后确定的。<br><strong>4、当一个 Java 集合（如：HashMap）的 key 是类类型时， 为什么重写了类的 equals() 方法，还要重写 hashCode() 方法？</strong><br>答：因为如果只重写了 equals 方法，两个对象 equals 返回了true，但是如果没有重写 hashCode 方法，集合还是会插入元素。这样集合中就出现了重复元素了。<br><a href="https://zhuanlan.zhihu.com/p/30321358" target="_blank" rel="noopener">参考地址&gt;&gt;</a><br><strong>5、什么是编码？</strong><br>答：把数据从一种格式转换成另一种格式（可能是同一种格式），它是可逆的，它的逆向过程叫做解码。<br><strong>6、什么是对象序列化？</strong><br>答：把数据对象（一般是内存种的，例如JVM中的对象）转换成字节序列的过程。对象在程序内存里的存放形式是散乱的（存放在不同的内存区域、并且由引用进行连接），通过序列化可以把内存中的对象转换成一个字节序列，从而可使用byte[]等形式进行本地存储或网络传输，在需要的时候重新组装（反序列化）来使用。<br><strong>7、序列化和编码的区别</strong><br>答：编码是把数据由一种数据格式转换成另一种数据格式；而序列化是把数据由内存中的对象（而不是某种具体的格式）转换成字节序列。<br><strong>8、非对称加密和数字签名在加密通信中如何配合使用？</strong><br>答：使用非对称加密通信，可以在不可信网络上将双方的公钥传给对方，然后在发消息前分别对消息使用对方的公钥来加密和使用自己的私钥来签名，做到不可信网络上的可靠密钥传播及加密通信。<br>知识拓展：签名是对原数据的 hash 值进行签名，而不是直接对原数据进行签名。这样做是为了减小数据的传输体积。<br><strong>9、TCP/IP协议族、HTTP协议、TCP协议、UDP协议、IP协议、Socket之间的关系？</strong><br><a href="https://www.jianshu.com/p/a5410f895d6b" target="_blank" rel="noopener">参考文章</a><br>Ⅰ、TCP/IP协议族是一个网络通信模型，为互联网的基础通信架构，它并不只是包含TCP协议和IP协议，只是因为这两个协议很重要，所以才用它们来命名。通常TCP/IP协议族被分为四层：应用层（HTTP协议）、传输层（TCP协议 | UDP协议）、网络层（IP协议）、数据链路层（以太网协议等）。<br>Ⅱ、HTTP连接是基于TCP协议的可靠传输协议，同时也是请求响应模式且无状态的协议。（Http 1.1 之后可以通过设置 Keep-Alive请求头将 Http 转变成长连接模式，所以此时的 Http 是有状态的。）<br>Ⅲ、Socket连接既可以基于TCP协议，也可以基于UDP协议。前者每次建立连接都要执行TCP的三次握手过程，每次断开连接都要执行四次挥手过程。后者没有三次握手和四次挥手的过程。<br>Ⅳ、TCP协议（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来，同时，结束对话也需要四次挥手过程。<br>V、UDP协议（User Data Protocol，用户数据报协议）在传输数据时不建立连接，因此也就不需要维护连接状态。UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。<br>Ⅵ、总结一下就是，TCP/IP协议族是一个总称，它包含了HTTP协议、TCP协议、UDP协议、IP协议。TCP协议、UDP协议是两种不同的传输层协议。Socket是一个为了便于使用  TCP/UDP 而提供的API接口规范，而Http是一个应用层协议，Http的下一层基于TCP协议，它和Socket没有联系。在 Http 连接中，只有客户端发起请求后服务端才会响应，服务端是无法主动向客户端发消息的，而Socket连接中，通信双方发送消息并没有先后的限制，通信双方中的任何一方可以随时向另一方发送消息。最后，笔者也认为既然 Socket 是一个对传输层协议的接口封装，而传输层的上个步骤是来自于应用层的（这里就是Http协议了），所以可以说 Sockect 的实现是依赖于上层http协议的。（应用层协议还有一个WebSocke协议支持双向主动发送消息给对方，它和 Http协议 的区别可以参考<a href="https://github.com/onlyliuxin/coding2017/issues/497" target="_blank" rel="noopener">这个链接</a>）<br><strong>10、HMAC 是什么 以及 Https 建立连接过程中产生的 mac secrete 有什么用？</strong><br>关于 HMAC 的定义可以看<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1183198304823296" target="_blank" rel="noopener">这篇文章</a>，所以我得到结论是 HMAC 不仅可以验证数据的完整性，同时还能保证数据来自于可信的对象（加大破解难度）。而 mac  secrete 实际上充当了 HMAC 计算过程中的 key 。</p><h1 id="自定义-View-相关"><a href="#自定义-View-相关" class="headerlink" title="自定义 View 相关"></a>自定义 View 相关</h1><p><strong>1、canvas 中 save（）和 saveLayer（）区别</strong><br><a href="https://blog.csdn.net/lijiuche/article/details/53467844" target="_blank" rel="noopener">参考链接&gt;&gt;</a><br><strong>2、自定义 View 时拿到 View 属性值的两种方式</strong><br>方式一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TypedArray typedArray =context.obtainStyledAttributes(attrs,控件在 R.styleable.styleable 文件中的命名【随意】);</span><br><span class="line">typedArray.getXXX(R.styleable.styleable文件中的控件名称_控件属性名, defaultValue);</span><br></pre></td></tr></table></figure></p><p>方式二<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TypedArray typedArray =context.obtainStyledAttributes(attrs,由控件属性组成的数组【如&#123;android.R.attr.layout_width,R.attr.***&#125;】);</span><br><span class="line">typedArray.getXXX(属性在数组中的引索, defaultValue);</span><br></pre></td></tr></table></figure></p><p>注意，对于方式二，obtainStyledAttributes 的第二个参数必须是由组成该控件的属性生成的数组，可以是系统自带的，如：android.R.attr.layout_width，也可以是在 styleable 文件自定义的属性，如：R.attr.<em>*</em>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将长期记录并解答笔者在 Android 开发过程中所遇到的问题，这些问题一般是几句话就能概括并且不需要单独成文讲解的。
    
    </summary>
    
      <category term="Android 其它" scheme="http://yoursite.com/categories/Android-%E5%85%B6%E5%AE%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Android动画（七）：过渡动画</title>
    <link href="http://yoursite.com/2019/07/29/%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/07/29/过渡动画/</id>
    <published>2019-07-29T14:11:15.000Z</published>
    <updated>2019-10-14T22:12:45.084Z</updated>
    
    <content type="html"><![CDATA[<p>笔者已将本节的代码上传至 <a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">Github</a>，大家可以结合着学习。<a id="more"></a><br>Android 4.4.2 (API level 19) 引入了 Transition 框架，支持场景过渡效果，到了A ndroid 5.0（API level 21） 开始支持 Activity 过渡动画。相对于视图动画或属性动画，Transition 动画更具特殊性，Transition 可以看作对属性动画的高度封装。为了对 Transition 有一个大体的了解，我们从 Scene Transition(场景过渡动画)、Activity 过渡动画之 Content Transition、Activity 过渡动画之 Shared Element Transition 这三个方面来做概述。</p><h3 id="场景过渡动画：Scene-Transition"><a href="#场景过渡动画：Scene-Transition" class="headerlink" title="场景过渡动画：Scene Transition"></a>场景过渡动画：Scene Transition</h3><p>场景过渡动画是指以动画的形式实现View两个场景的切换(从一个场景切换到另一个场景)。而且在切换过程中通过 Transition 来设置不同的过渡动画效果。<br>场景过渡动画中有三个特别关键概念：Scene（场景），Transition（过渡动画），TransitionManager（管理）。</p><p>1、Scene：Scene 代表一个场景。Scene 保存了一个视图层级结构，包括它所有的 views 以及 views 的状态，通常由 getSceneForLayout (ViewGroup sceneRoot,int layoutId,Context context)获取 Scene 实例。Transition 框架可以实现在 starting scene 和 ending scene 之间执行动画。而且大多数情况下，我们不需要创建 starting scene，因为 starting scene 通常由当前UI状态决定，我们只需要创建 ending scene。</p><p>2、Transition：Transiton 则是用来设置过渡动画效果用的。而且系统给提供了一些非常有用的 Transtion 动画效果，如下表所示:</p><table><thead><tr><th>系统Transition</th><th>解释</th></tr></thead><tbody><tr><td>ChangeBounds</td><td>检测 View 的位置边界创建移动和大小变化动画(关注布局边界的变化，不关注 scale 引起的布局边界变化)</td></tr><tr><td>ChangeTransform</td><td>检测 View 的 scale 和 rotation 创建缩放和旋转动画(关注 scale 和 ratation 的变化)</td></tr><tr><td>ChangeClipBounds</td><td>检测 View 的剪切区域的位置边界，和 ChangeBounds 类似。不过 ChangeBounds 针对的是 view 而 ChangeClipBounds 针对的是 view 的剪切区域 rect 的变化，（关注 setClipBounds(Rect rect) 中 rect 的变化）</td></tr><tr><td>ChangeImageTransform</td><td>检测 ImageView 的 ScaleType，并创建相应动画(关注的是 ImageView 的 scaleType)</td></tr><tr><td>Fade</td><td>根据 View 的 visibility状态的的不同创建淡入淡动画,调整的是透明度(关注的是 View 的 visibility 的状态)</td></tr><tr><td>Slide</td><td>根据 View 的 visibility 状态的的不同创建滑动动画(关注的是 View 的 visibility 的状态)</td></tr><tr><td>Explode</td><td>根据 View 的 visibility 状态的的不同创建分解动画(关注的是 View 的 visibility 的状态)</td></tr><tr><td>AutoTransition</td><td>默认动画，ChangeBounds、Fade 动画的集合</td></tr></tbody></table><blockquote><p><strong>PathMotion</strong><br>Transition 的辅助工具，以 path 的方式指定过渡效果，两个具体实现类 ArcMotion 和 PatternPathMotion，效果类似于之前讲过的路径动画。<a href="http://rkhcy.github.io/2017/09/21/TransitionNote/" target="_blank" rel="noopener">参考链接&gt;&gt;</a></p></blockquote><p>3、TransitionManager<br>TransitionManager 用于将 Scene 和 Transition 联系起来，它提供了一系列的方法，如：go(Scene scene, Transition transition)，到指定的场景所使用的过渡动画是什么，beginDelayedTransition(ViewGroup sceneRoot, Transition transition)，在当前场景到下一帧的过渡效果是什么。</p><p>我们在使用场景过渡动画时，有两种实现方式。<br>1、TransitionManager.go方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">//定义开始场景、结束场景。</span><br><span class="line">mSceneStart = Scene.getSceneForLayout(sceneRootView, R.layout.scene_start, context);</span><br><span class="line">mSceneEnd = Scene.getSceneForLayout(sceneRootView, R.layout.scene_end, context);</span><br><span class="line">//开始场景过渡动画。其中&quot;transition&quot;参数可以通过代码生成，如：new AutoTransition()。也可以是引用xml文件，如：TransitionInflater.from(this).inflateTransition(R.transition.xxx)。</span><br><span class="line">TransitionManager.go(mSceneEnd,transition);</span><br></pre></td></tr></table></figure></p><p>2、beginDelayedTransition方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TransitionManager.beginDelayedTransition(sceneRootView,transition);</span><br><span class="line">//下面改变 sceneRootView 中子 View 的属性，如：位置，缩放比例等。</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>beginDelayedTransition 的方式是不是会让你联想到之前讲过的 LayoutTransition 动画呢？它们之间的区别可以这么理解：LayoutTransition针对的是各个控件在限定场景到达时的动画表现。而beginDelayedTransition针对的是不同的场景之间的切换动画。前者关注的是控件（微观），后者关注的是场景（宏观）。<br>除了使用系统自带的 Transtion 使用动画以外，我们还可以自定义 Transition 动画，具体可参考<a href="https://developer.android.com/training/transitions/custom-transitions" target="_blank" rel="noopener">官方的这篇文章</a>。或者直接看官方给的<a href="https://github.com/googlesamples/android-CustomTransition" target="_blank" rel="noopener">DEMO</a>。</p><h5 id="使用场景过渡动画需要注意的点："><a href="#使用场景过渡动画需要注意的点：" class="headerlink" title="使用场景过渡动画需要注意的点："></a>使用场景过渡动画需要注意的点：</h5><p>1、Android 版本在 4.0(API Level 14) 到 4.4.2(API Level 19) 使用 Android Support Library，但是Activity过渡动画和共享元素过渡动画至少要Android 5.0版本才支持。<br>2、对于 SurfaceView 可能不起效果，因为 SurfaceView 的实例是在非 UI 线程更新的，因此会造成和其他视图动画不同步。<br>3、某些特定的转换类型在应用到 TextureView 时可能不会产生所需的动画效果。<br>4、继承自 AdapterView 的视图如：ListView，与该框架不兼容。RecycleView 兼容该框架，不过由于 RecycleView 复用机制的存在，这里就会存在两个动画：一个进入、一个退出，所以如果不满足需求，还是老实用 ItemAnimator 吧。（PS：后面再写篇文章详细介绍 RecycleView。）<br>5、不要对包含文本的视图的大小进行动画。(这里所指的大小改变主要包括直接改变视图的宽高或者通过 setTextSize 改变视图的大小，不包括 scale 引起的视图大小变化。)<br>6、默认情况下，sceneRoot 下所有的 View 都会执行 Transition 动画，我们可以通过 Transition.addTarget 和 removeTarget 方法选择性添加或移除执行动画的 View 。需要注意的是，Transition 的 removeTarget 方法必须在已经使用了 addTarget的前提下才有效果。在未使用 addTarget 的情况下，如果要排除某个 View 执行动画效果，可以使用 Transition 的 excludeTarget 替代 removeTarget 方法。<br><strong>本节参考资料:</strong><br><a href="https://developer.android.com/training/transitions" target="_blank" rel="noopener">1、Animate layout changes using a transition</a><br><a href="http://rkhcy.github.io/2017/09/21/TransitionNote/" target="_blank" rel="noopener">2、Android Transition（一）</a><br><a href="https://blog.csdn.net/wuyuxing24/article/details/78857912" target="_blank" rel="noopener">3、Android Transition（Android过渡动画）</a></p><h3 id="Activity过渡动画：Content-Transition、Shared-Element-Transition"><a href="#Activity过渡动画：Content-Transition、Shared-Element-Transition" class="headerlink" title="Activity过渡动画：Content Transition、Shared Element Transition"></a>Activity过渡动画：Content Transition、Shared Element Transition</h3><p>官方参考文档：<a href="https://developer.android.com/training/transitions/start-activity" target="_blank" rel="noopener">Start an activity using an animation</a><br>中文参考文档：<a href="https://juejin.im/post/59cc54825188257a73280214" target="_blank" rel="noopener">Activity 过渡动画</a></p><h5 id="对于共享元素的延迟加载"><a href="#对于共享元素的延迟加载" class="headerlink" title="对于共享元素的延迟加载"></a>对于共享元素的延迟加载</h5><p>如果共享元素在被调用的 Activity 需要通过 AsyncTask, Loader, 或其它类似的数据加载方式决定它们最终的表现，数据被分发返回到主线程之前框架是可以开始过渡的。<br>为了解决这个问题，Activity Transitions API 提供了一个方法暂时推迟过渡直到我们确切地知道共享元素已经被适当的渲染和放置。<br>为了从开始时暂时阻止共享元素过渡，调用 postponeEnterTransition()（API &gt;= 21）或 supportPostponeEnterTransition()（API &lt; 21）在你被调用的 Activity 中的 onCreate() 方法中。然后，当你知道所有共享元素已经被适当的摆放和大小时，调用 startPostponedEnterTransition()（API &gt;= 21）或supportStartPostponedEnterTransition()（API &lt; 21） 恢复过渡。<br>你会找到一个常见的处理模式是在 OnPreDrawListener 中开启延迟过渡，它将会在共享元素被渲染和放置后调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ... load remote image with Glide/Picasso here</span><br><span class="line">supportPostponeEnterTransition();</span><br><span class="line">ivBackdrop.getViewTreeObserver().addOnPreDrawListener(</span><br><span class="line">    new ViewTreeObserver.OnPreDrawListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean onPreDraw() &#123;</span><br><span class="line">            ivBackdrop.getViewTreeObserver().removeOnPreDrawListener(this);</span><br><span class="line">            supportStartPostponedEnterTransition();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>需要记住的是，一定要在共享元素被渲染和放置后调用<code>startPostponedEnterTransition</code>方法，否者被调用的 Activity 会一直被堵塞。<br><a href="https://yuweiguocn.github.io/shared-element-activity-transition/" target="_blank" rel="noopener">参考文章&gt;&gt;</a></p><h5 id="ViewOverlay-补充"><a href="#ViewOverlay-补充" class="headerlink" title="ViewOverlay 补充"></a>ViewOverlay 补充</h5><p><code>ViewOverlay</code>可以实现跨ViewGroup的动画，参考Demo中的<a href="https://github.com/tangxianming/AnimationPracticeApplication/blob/master/app/src/main/java/com/txm/topcodes/animationpracticeapplication/activity/OverlayActivity.java" target="_blank" rel="noopener">OverlayActivity类</a>，有如下要的：<br>1、动画完成后一定要记得在目标 ViewGroup Overlay 移除当前的View。<br>2、被添加到目标 ViewGroup Overlay 中的 View，无法响应点击事件。</p><h5 id="Activity-过渡动画需要注意的点："><a href="#Activity-过渡动画需要注意的点：" class="headerlink" title="Activity 过渡动画需要注意的点："></a>Activity 过渡动画需要注意的点：</h5><p>1、对于非共享元素过渡动画，一些国内机型在开启 windowAllowEnterTransitionOverlap 后，如果 ExitTransition 设置的转场时间过长，则会出现返回页面时无法恢复原来状态的问题。<br>使用经验：如果需要启动页也有动画效果的话，不能将动画时长设置过长，同时要结合多个机型测试一下。另外，不设置 ExitTransition 动画效果不会有问题。<br>2、一些国内机型跳转目标页时，即使使用了 excludeTarget(android.R.id.statusBarBackground, true) 方法排除状态栏参与动画，状态栏背景仍会出现颜色切换现象（颜色为目标页面背景色）。<a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">解决方案请参考Demo&gt;&gt;</a><br>3、使用 Fragment 的 Transition 实现界面过渡可完美避免出现上述问题。 <a href="https://github.com/lgvalle/Material-Animations" target="_blank" rel="noopener">参考项目&gt;&gt;</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者已将本节的代码上传至 &lt;a href=&quot;https://github.com/tangxianming/AnimationPracticeApplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，大家可以结合着学习。
    
    </summary>
    
      <category term="Android动画基础" scheme="http://yoursite.com/categories/Android%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Scene Transition" scheme="http://yoursite.com/tags/Scene-Transition/"/>
    
      <category term="Content Transition" scheme="http://yoursite.com/tags/Content-Transition/"/>
    
      <category term="Shared Element Transition" scheme="http://yoursite.com/tags/Shared-Element-Transition/"/>
    
  </entry>
  
  <entry>
    <title>Android动画（六）：布局动画</title>
    <link href="http://yoursite.com/2019/07/21/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8006%EF%BC%9A%E5%B8%83%E5%B1%80%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/07/21/动画基础06：布局动画/</id>
    <published>2019-07-21T04:00:05.000Z</published>
    <updated>2019-10-17T22:36:51.387Z</updated>
    
    <content type="html"><![CDATA[<p>笔者已将本节的代码上传至 <a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">Github</a>，大家可以结合着学习。<br>在 Android 的动画体系中，有补间动画，帧动画和属性动画，但是这些动画都是针对单个对象的，如果想对 ViewGroup 作动画，就要用到布局动画了。布局动画一共有两种：LayoutAnimation 和 LayoutTransition，本文将逐一介绍他们的用法和区别。<a id="more"></a></p><h3 id="LayoutAnimation"><a href="#LayoutAnimation" class="headerlink" title="LayoutAnimation"></a>LayoutAnimation</h3><p>LayoutAnimation 布局动画属于补间动画的一种，利用它可以快速实现对 ViewGroup 中子 view 的动画。不过，它的缺陷是只能够在 ViewGroup 初始化时对其子 view 产生动画效果，之后再增加子 view 时没有效果。<br>LayoutAnimation 动画可以直接在 xml 中定义：<br>1、首先定义单个 View 的补间动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;500&quot;&gt;</span><br><span class="line">  &lt;translate</span><br><span class="line">      android:fromXDelta=&quot;-50%p&quot;</span><br><span class="line">      android:toXDelta=&quot;0&quot;/&gt;</span><br><span class="line">  &lt;alpha</span><br><span class="line">      android:fromAlpha=&quot;0.0&quot;</span><br><span class="line">      android:toAlpha=&quot;1.0&quot;/&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p><p>2、定义 layoutAnimation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layoutAnimation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:animation=&quot;@anim/slide_in_from_left&quot;</span><br><span class="line">    android:animationOrder=&quot;random&quot;</span><br><span class="line">    android:delay=&quot;1&quot;/&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">1、delay : ViewGroup 中单个Item动画的开始延时，取值是android:animation 所指定动画时长的倍数，可以是float，也可以是百分数，默认0.5</span><br><span class="line">比如slide_in_from_left中定义的动画时长是500ms，这里delay=1，那么在上一个动画执行之后延时500ms执行下一个item的动画</span><br><span class="line">2、animationOrder : 动画开始顺序，normal(正序)、reverse(倒序)、random(随机)</span><br><span class="line">3、animation : 指定动画资源animation，注意不能使用animator</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></p><p>可以通过下面两种方式加载<br>1、直接在 ViewGroup 的 layout xml 文件中设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:layoutAnimation=&quot;@anim/list_item_slide_layout_animation&quot;</span><br></pre></td></tr></table></figure></p><p>2、使用代码设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Animation animation = AnimationUtils.loadAnimation(mActivity，R.anim.slide_in_from_left);</span><br><span class="line">LayoutAnimationController animationController = new LayoutAnimationController(animation，</span><br><span class="line">         1f);</span><br><span class="line">animationController.setOrder(LayoutAnimationController.ORDER_NORMAL);</span><br><span class="line">mList.setLayoutAnimation(animationController);</span><br><span class="line">mList.startLayoutAnimation();</span><br></pre></td></tr></table></figure></p><blockquote><p>同时，系统也提供了 <a href="https://wiki.jikexueyuan.com/project/android-animation/11.html" target="_blank" rel="noopener">gridLayoutAnimation</a> 用于给 Gridview 设置布局动画。<br>需要注意的是布局动画，在创建ViewGroup的时候生效，后续添加的子View是没有动画效果的。</p></blockquote><h3 id="LayoutTransition"><a href="#LayoutTransition" class="headerlink" title="LayoutTransition"></a>LayoutTransition</h3><p>LayoutTransition 是API Level 11 才出现的。LayoutTransition 的动画效果，只有当 ViewGroup 中有 View 添加、删除、隐藏、显示的时候才会体现出来，初始化时没有效果。<br>LayoutTransition 类中主要有五种容器转换动画类型，具体如下：</p><blockquote><p>LayoutTransition.APPEARING：子 View 添加到容器中时的过渡动画效果。<br>LayoutTransition.CHANGE_APPEARING：子 View 添加到容器中时，其他子 View 位置改变的过渡动画。<br>LayoutTransition.DISAPPEARING：子 View 从容器中移除时的过渡动画效果。<br>LayoutTransition.CHANGE_DISAPPEARING：子 View 从容器中移除时，其它子 View 位置改变的过渡动画。<br>LayoutTransition.CHANGING：子 View 在容器中位置改变时的过渡动画，不涉及删除或者添加操作。(没有试出效果，哪位大神知道用法的话，欢迎到<a href="https://github.com/tangxianming/AnimationPracticeApplication/issues" target="_blank" rel="noopener">github</a>留个言，谢谢。)</p></blockquote><p>LayoutTransition 也有两种方式添加。<br>1、在xml中直接添加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 只能使用系统默认的 LayoutTransition 动画</span><br><span class="line">android:animateLayoutChanges=&quot;true&quot;</span><br></pre></td></tr></table></figure></p><p>2、在代码中使用。<br>使用系统默认的 LayoutTransition 动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LayoutTransition mTransitioner = new LayoutTransition();</span><br><span class="line">mViewGroup.setLayoutTransition(mTransitioner);</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：使用系统动画时，会出现动画未达到预期的现象。此时应该从这些方面考虑：<br>a. 直接子 View 是一个容器，且容器中的子 View 是否过多？<br>b. 直接子 View 之间的依赖关系是否能达到动画预期？<br>c. 运用在 SurfaceView 上的动画效果会异常。</p></blockquote><p>使用自定义的 LayoutTransition 动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LayoutTransition layoutTransition = new LayoutTransition();</span><br><span class="line">viewGroup.setLayoutTransition(layoutTransition);</span><br><span class="line">...</span><br><span class="line">layoutTransition.setAnimator(transitionType， AnimatorInflater.loadAnimator(this， R.animator.xxx));</span><br><span class="line">&lt;!--transitionType代表五种容器转换动画类型； R.animator.xxx代表属性动画资源。--&gt;</span><br></pre></td></tr></table></figure></p><p>同时，可以给 LayoutTransition 设置监听器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mTransitioner.addTransitionListener(new LayoutTransition.TransitionListener()&#123;//...&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>布局动画类</th><th>类型</th><th>优缺点</th><th>发布版本</th></tr></thead><tbody><tr><td>LayoutAnimation</td><td>补间动画</td><td>优点：快速实现对 ViewGroup 中子 View 的动画。对于 RecyclerView 这些 list 类型的 ViewGroup 同样适用。<br>缺点：只能够在 ViewGroup 初始化时对其子 View 产生动画效果。</td><td>API Level 1</td></tr><tr><td>LayoutTransition</td><td>属性动画</td><td>优点：ViewGroup 中只要有子 View 添加、删除、隐藏、显示，都能对子 View 的产生动画。。<br>缺点：1、对于 RecyclerView 不适用，我在实验滑动的时候是直接报错了，所以我建议如果是 RecyclerView 的话，还是用它自带的 ItemAnimator。2、对于 ListView 适用，参考这个<a href="https://pupli.net/2017/03/24/android-animating-listview-with-layouttransition/" target="_blank" rel="noopener">链接</a>，不过效果有点乱，同时还使得问题复杂化了，我在<a href="https://stackoverflow.com/questions/17239151/using-changing-layouttransition-type-in-a-listview-has-no-effect" target="_blank" rel="noopener">stackoverflow</a>上看到了这个问题的回答。3、初始化 ViewGroup 时没有效果。</td><td>API Level 11</td></tr></tbody></table><hr><p><strong>参考资料</strong><br>1.<a href="http://www.voidcn.com/article/p-bytxriow-xp.html" target="_blank" rel="noopener">Android 动画(一) LayoutAnimation 与 LayoutTransition</a><br>2.<a href="https://medium.com/@evanchen76/android-animation-30天上手-day13-layouttransition-a4c6d2a1cd90" target="_blank" rel="noopener">Android animation 30天上手 — Day13 LayoutTransition</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者已将本节的代码上传至 &lt;a href=&quot;https://github.com/tangxianming/AnimationPracticeApplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，大家可以结合着学习。&lt;br&gt;在 Android 的动画体系中，有补间动画，帧动画和属性动画，但是这些动画都是针对单个对象的，如果想对 ViewGroup 作动画，就要用到布局动画了。布局动画一共有两种：LayoutAnimation 和 LayoutTransition，本文将逐一介绍他们的用法和区别。
    
    </summary>
    
      <category term="Android动画基础" scheme="http://yoursite.com/categories/Android%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="LayoutAnimation" scheme="http://yoursite.com/tags/LayoutAnimation/"/>
    
      <category term="LayoutTransition" scheme="http://yoursite.com/tags/LayoutTransition/"/>
    
  </entry>
  
  <entry>
    <title>Android动画（五）：插值器和估值器补充、Fling动画、物理动画</title>
    <link href="http://yoursite.com/2019/03/03/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8005%EF%BC%9APath%E7%B1%BB%E5%9E%8B%E6%8F%92%E5%80%BC%E5%99%A8%E3%80%81%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB%E3%80%81Fling%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/03/03/动画基础05：Path类型插值器、路径动画、Fling动画/</id>
    <published>2019-03-03T13:08:19.000Z</published>
    <updated>2019-10-14T22:12:45.082Z</updated>
    
    <content type="html"><![CDATA[<p>笔者已将本节的代码上传至 <a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">Github</a>，大家可以结合着学习。<a id="more"></a><br>本篇讲的是 Android 视图位置变化相关的知识，其中，第一部分是对之前文章<a href="https://kimball325.github.io/2019/01/25/动画基础02：视图动画、属性动画/" target="_blank" rel="noopener">视图动画、属性动画</a>中插值器、估值器的补充。本章的内容主要参考了官方的下面三篇文章：<br><a href="https://developer.android.com/training/animation/reposition-view" target="_blank" rel="noopener">1、Move a View with Animation</a><br><a href="https://developer.android.com/guide/topics/graphics/fling-animation" target="_blank" rel="noopener">2、Move views using a fling animation</a><br><a href="https://developer.android.com/guide/topics/graphics/spring-animation#add-support-library" target="_blank" rel="noopener">3、Animate movement using spring physics</a><br>参考的中文文章在文末有给出。</p><h4 id="Path类型的插值器"><a href="#Path类型的插值器" class="headerlink" title="Path类型的插值器"></a>Path类型的插值器</h4><p>Path 类型的插值器是一种新的插值器，Android 从5.0开始支持。可以用代码、XML 两种方式实现，这里我们只讨论代码实现的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">Path path = new Path();</span><br><span class="line">path.lineTo(1f, 1f);</span><br><span class="line">PathInterpolator pathInterpolator = new PathInterpolator(path);</span><br><span class="line">…………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从以上代码可以看出，Path 被限制在一个1*1的正方形中，x、y坐标的取值范围都为[0,1]，并且 Path 必须从(0,0)坐标开始，(1,1)坐标结束。x坐标代表时间进度：0-100%，y坐标代表当前时间点对应的动画完成度：0-100%。<br>一旦<code>pathInterpolator</code>创建完成，就可以通过<code>Animator.setInterpolator()</code>方法使用它了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animation = ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 100f);</span><br><span class="line">animation.setInterpolator(pathInterpolator);</span><br><span class="line">animation.start();</span><br></pre></td></tr></table></figure></p><img src="/2019/03/03/动画基础05：Path类型插值器、路径动画、Fling动画/path_interpolator.gif" title="Path类型的插值器"><h4 id="估值器实现路径动画"><a href="#估值器实现路径动画" class="headerlink" title="估值器实现路径动画"></a>估值器实现路径动画</h4><p>ObjectAnimator从 Android 5.0 开始提供了一类新的构造方法用于实现沿自定义路径移动的动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">Path path = new Path();</span><br><span class="line">path.moveTo(view.getX(), view.getY());</span><br><span class="line">path.cubicTo(view.getX(), view.getY(),</span><br><span class="line">view.getX() + 300, view.getY() + 200,</span><br><span class="line">view.getX() - 400, view.getY() + 500);</span><br><span class="line">//下面两种方法不允许</span><br><span class="line">//path.addCircle(view.getX(), view.getY(),100,Path.Direction.CCW);</span><br><span class="line">//path.arcTo(view.getX()+100, view.getY()+100, view.getX() + 500, view.getY() + 500, 270f, -180f, true);</span><br><span class="line">ObjectAnimator objectAnimator =</span><br><span class="line">ObjectAnimator.ofFloat(ivBalPathAnimator, View.X, View.Y, path);</span><br><span class="line">objectAnimator.setDuration(1200);</span><br><span class="line">objectAnimator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">objectAnimator.setRepeatMode(ValueAnimator.REVERSE);</span><br><span class="line">objectAnimator.setInterpolator(new LinearInterpolator());</span><br><span class="line">objectAnimator.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/03/03/动画基础05：Path类型插值器、路径动画、Fling动画/path_animator.gif" title="路径动画"><h4 id="Fling动画"><a href="#Fling动画" class="headerlink" title="Fling动画"></a>Fling动画</h4><p>Fling 动画使用物理学中摩擦力的概念，使得 view 的速度逐渐被降低，从而实现了现实中的阻力运动。Android 4.4版本开始支持该动画。<br><img src="/2019/03/03/动画基础05：Path类型插值器、路径动画、Fling动画/fling-animation.gif" title="Fling Animation"><br><strong> 1、添加支持库 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">implementation &apos;com.android.support:support-dynamic-animation:28.0.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 2、创建fling动画 </strong><br>FlingAnimation 类可以帮助你创建fling动画，只要在创建 FlingAnimation 实例时传入操作的 View 对象以及操作对象的属性即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlingAnimation fling = new FlingAnimation(view, DynamicAnimation.SCROLL_X);</span><br></pre></td></tr></table></figure></p><p><strong> 3、设置初始速度 </strong><br>为了让物体移动（并非只有移动），我们必须给物体一个初速度。默认的初速度是0，所以我们必须定义一个大于0的初速度以保证物体能够移动。<br>设置初速度的方法是<code>setStartVelocity()</code>。您可以使用固定值作为起始速度，也可以将其基于触摸手势的速度通过<a href="http://www.gcssloop.com/customview/gestruedector" target="_blank" rel="noopener">GestureDetetor.OnGestureListener </a>获取。如果您选择提供固定值，您应该以每秒dp的值定义值，然后将其转换为每秒像素数。以每秒dp定义值的方式允许速度独立于设备的密度和形状因子。有关将起始速度转换为每秒像素数的更多信息，将在下一篇文章 《Spring Animation》中的“ 每秒转换为每秒像素数”部分讲解 。</p><p><strong> 4、设置动画的取值范围 </strong><br>你可以通过<code>setMinValue()</code>和<code>setMaxValue()</code>设置属性值的变化范围，这个对于有明确变化范围的属性显得十分重要，例如透明度（0-1）。注意，当fling时的属性值到达设定的最大值或者最小值时，动画会立刻结束。</p><p><strong> 5、设置阻力因子 </strong><br>你可以通过<code>setFriction()</code>改变动画的阻力因子，他定义了速度下降的速度。阻力因子的默认值是1。<br>下面的例子定义了一个横向滑动的fling动画，滑动边界被设置为0和maxScroll，摩擦力设置为1.1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FlingAnimation fling = new FlingAnimation(view, DynamicAnimation.SCROLL_X);</span><br><span class="line">fling.setStartVelocity(-velocityX)</span><br><span class="line">.setMinValue(0)</span><br><span class="line">.setMaxValue(maxScroll)</span><br><span class="line">.setFriction(1.1f)</span><br><span class="line">.start();</span><br></pre></td></tr></table></figure></p><p>注意，上面的方法仅仅适用于单个属性的 fling 变化。如果有多个属性同时需要fling变化呢？有的文章倒是建议用<code>FloatPropertyCompat</code>实现。可是<code>FloatPropertyCompat</code>有它的局限性，正如<a href="https://code.tutsplus.com/zh-hans/tutorials/adding-physics-based-animations-to-android-apps--cms-29053" target="_blank" rel="noopener">这篇文章</a>的第五部分所说：要在确保所有属性的值不是完全相互独立的情况下，该方法才适用。否则，我们只能针对每个属性都建立一个 FlingAnimation。</p><p><strong> 6、设置最小可见变化 </strong><br>当您在为不以像素为单位定义的自定义属性设置动画时，应设置用户可见的动画值的最小更改，它作为定义动画结束的最小值。<br>当操作 DynamicAnimation.ViewProperty 动画时不需要调用此方法，因为此时的最小可见变化可以自动获取。例如：<br>1、默认最小可见的变化值是1个像素，如：TRANSLATION_X，TRANSLATION_Y， TRANSLATION_Z，SCROLL_X，和 SCROLL_Y。<br>2、对于使用旋转动画，如ROTATION， ROTATION_X，和ROTATION_Y，最小可见变化是 MIN_VISIBLE_CHANGE_ROTATION_DEGREES，或1/10像素。<br>3、对于使用不透明度的动画，最小可见变化为 MIN_VISIBLE_CHANGE_ALPHA 或者1/256。<br>要设置动画的最小可见变化，请调用<code>setMinimumVisibleChange()</code>方法，并传递最小可见常量或您需要为自定义属性计算的值。有关计算此值的更多信息，请参阅本部分末的“计算最小可见变化值”部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anim.setMinimumVisibleChange(DynamicAnimation.MIN_VISIBLE_CHANGE_SCALE);</span><br></pre></td></tr></table></figure></p><p>注意：只有在为不以像素定义的自定义属性制作动画时，才需要设置最小可见变化值。</p><blockquote><p><strong>计算最小可见变化值 ：</strong><br>最小可见变化值=自定义属性值的范围/以像素为单位的动画执行范围。<br>例如，要进行动画制作的自定义非像素为单位的属性变化范围是从0到100，同时如果此过程对应于200像素的动画更改。根据公式，最小可见变化值是100/200等于0.5像素。</p></blockquote><h4 id="Spring动画"><a href="#Spring动画" class="headerlink" title="Spring动画"></a>Spring动画</h4><p>这一部分的内容在官网讲得也是很明白了。需要注意的是，官网结尾最后的“Cancel animation”部分提到的‘cancel()’和‘skipToEnd()’使用注意事项：</p><blockquote><p>cancel()：立即停止动画<br>skipToEnd()：恢复到最终位置并停止动画。需要注意的是，在无阻尼的情况下，不能调用该方法（即：DampingRatio==0时）。为了安全，可以先调用 canSkipToEnd() 进行判断，有阻尼的情况下返回 true，否则返回 false。一般来说，skipToEnd() 会有跳跃的效果。</p></blockquote><p>以下是Demo中实现的效果：<br><img src="/2019/03/03/动画基础05：Path类型插值器、路径动画、Fling动画/spring_animation.gif" title="物理动画"></p><hr><p><strong>参考资料</strong><br><a href="https://cloud.tencent.com/info/eb3faa589479ceb0a501d4cbf3a25541.html" target="_blank" rel="noopener">1、中文翻译：使用 fling 动画移动视图</a><br><a href="https://juejin.im/entry/58ddd02644d904006d034b33" target="_blank" rel="noopener">2、SpringAnimation 详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者已将本节的代码上传至 &lt;a href=&quot;https://github.com/tangxianming/AnimationPracticeApplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，大家可以结合着学习。
    
    </summary>
    
      <category term="Android动画基础" scheme="http://yoursite.com/categories/Android%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PathInterpolator" scheme="http://yoursite.com/tags/PathInterpolator/"/>
    
      <category term="路径动画" scheme="http://yoursite.com/tags/%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/"/>
    
      <category term="FlingAnimation" scheme="http://yoursite.com/tags/FlingAnimation/"/>
    
      <category term="SpringAnimation" scheme="http://yoursite.com/tags/SpringAnimation/"/>
    
  </entry>
  
  <entry>
    <title>Android动画（四）：淡入淡出、翻牌、揭露动画</title>
    <link href="http://yoursite.com/2019/02/22/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8004%EF%BC%9A%E6%B7%A1%E5%85%A5%E3%80%81%E7%BF%BB%E7%89%8C%E3%80%81%E6%8F%AD%E9%9C%B2%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/02/22/动画基础04：淡入、翻牌、揭露动画/</id>
    <published>2019-02-22T07:20:25.000Z</published>
    <updated>2019-10-14T22:12:45.081Z</updated>
    
    <content type="html"><![CDATA[<p>笔者已将本节的代码上传至 <a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">Github</a>，大家可以结合着学习。以下内容是对<a href="https://developer.android.com/training/animation/reveal-or-hide-view#java" target="_blank" rel="noopener">官方文档</a>的翻译。<a id="more"></a><br>当你在使用APP时，如果立即从旧的内容切换到新内容，则很容易让用户感到不适，所以我们需要转场动画来平滑地过渡这种新旧内容的切换过程。<br>有三种常用的动画适合该场景，他们分别是淡入淡出动画、翻牌动画、揭露动画。</p><h2 id="淡入淡出动画"><a href="#淡入淡出动画" class="headerlink" title="淡入淡出动画"></a>淡入淡出动画</h2><p>淡入淡出动画顾名思义是在一个 View 或者 ViewGroup 消失时，另外一个View同步显示的动画。本节采用<code>ViewPropertyAnimator</code>实现淡入淡出动画，从Android 3.1 （API level 12）开始支持 ViewPropertyAnimator。<br>这是一个使用淡入淡出动画的例子。<br><img src="/2019/02/22/动画基础04：淡入、翻牌、揭露动画/anim_crossfade.gif" title="Crossfade animation"></p><h4 id="创建views"><a href="#创建views" class="headerlink" title="创建views"></a>创建views</h4><p>首先，你需要创建两个你需要使用淡入淡出动画的 View。下面创建了一个进度指示 View 和一个可滑动的文本 View：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        android:id=&quot;@+id/content&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            style=&quot;?android:textAppearanceMedium&quot;</span><br><span class="line">            android:lineSpacingMultiplier=&quot;1.2&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@string/lorem_ipsum&quot;</span><br><span class="line">            android:padding=&quot;16dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/ScrollView&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ProgressBar</span><br><span class="line">        android:id=&quot;@+id/loading_spinner&quot;</span><br><span class="line">        style=&quot;?android:progressBarStyleLarge&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_gravity=&quot;center&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure></p><h4 id="创建淡入淡出动画"><a href="#创建淡入淡出动画" class="headerlink" title="创建淡入淡出动画"></a>创建淡入淡出动画</h4><p>分为3个步骤：<br>1、创建成员变量以便接下来对其添加动画。<br>2、对于将要淡入的 View，提前将 visibility 属性设置为<code>GONE</code>。这不仅能够避免该 View 在动画开始之前占用 layout 空间，同时也避免了不必要的 layout 计算。<br>3、预先保存<code>config_shortAnimTime</code>属性值。这个属性值表示标准的短暂动画时长，这个时长是很理想的数值对于频繁使用的动画来说。除此之外，还有<code>config_longAnimTime</code>和<code>config_mediumAnimTime</code>可供选择。</p><p>下面的代码使用了之前创建的 layout 作为活动的 content view：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CrossfadeActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private View contentView;</span><br><span class="line">    private View loadingView;</span><br><span class="line">    private int shortAnimationDuration;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_crossfade);</span><br><span class="line"></span><br><span class="line">        contentView = findViewById(R.id.content);</span><br><span class="line">        loadingView = findViewById(R.id.loading_spinner);</span><br><span class="line"></span><br><span class="line">        // Initially hide the content view.</span><br><span class="line">        contentView.setVisibility(View.GONE);</span><br><span class="line"></span><br><span class="line">        // Retrieve and cache the system&apos;s default &quot;short&quot; animation time.</span><br><span class="line">        shortAnimationDuration = getResources().getInteger(</span><br><span class="line">                android.R.integer.config_shortAnimTime);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="添加淡入淡出动画"><a href="#添加淡入淡出动画" class="headerlink" title="添加淡入淡出动画"></a>添加淡入淡出动画</h4><p>最后，我们要实现淡入淡出动画还需要如下3个步骤：<br>1、对于将要淡入的 View，设置它的 alpha 属性为0并且设置 visiblity 为<code>VISIBLE</code>（该 View 之前的 visibility 为<code>GONE</code>）。这一步让该 View 处于可见但完全透明的状态。<br>2、对将要淡入的view，让它的透明度从0变化到1。对于将要淡出的view，让它的透明度从1到0。<br>3、在<code>Animator.AnimatorListener</code>的<code>onAnimationEnd()</code>方法中设置淡出view 的 visibility 属性为<code>GONE</code>。注意，虽然该 View 已经完全透明，但是设置属性 visibility 为<code>GONE</code>不仅可以阻止该 View 占用 layout 空间，同时还避免了不必要的 layout 计算。<br>下面是这几步的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CrossfadeActivity extends Activity &#123;</span><br><span class="line">    private View contentView;</span><br><span class="line">    private View loadingView;</span><br><span class="line">    private int shortAnimationDuration;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    private void crossfade() &#123;</span><br><span class="line">        contentView.setAlpha(0f);</span><br><span class="line">        contentView.setVisibility(View.VISIBLE);</span><br><span class="line">        contentView.animate()</span><br><span class="line">                .alpha(1f)</span><br><span class="line">                .setDuration(shortAnimationDuration)</span><br><span class="line">                .setListener(null);</span><br><span class="line">        loadingView.animate()</span><br><span class="line">                .alpha(0f)</span><br><span class="line">                .setDuration(shortAnimationDuration)</span><br><span class="line">                .setListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">                        loadingView.setVisibility(View.GONE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="翻牌动画"><a href="#翻牌动画" class="headerlink" title="翻牌动画"></a>翻牌动画</h2><p>该动画适用于在两个 View 之间实现类似翻牌的动效。本节的翻牌动画借助了<code>FragmentTransaction</code>类的<code>setCustomAnimations</code>方法，该类从 Android3.0（API等级11） 开始可以调用。当然，你也可以借助其他的方式实现咯。</p><h4 id="创建Animator-object"><a href="#创建Animator-object" class="headerlink" title="创建Animator object"></a>创建Animator object</h4><p>为了创建翻牌动画，你一共需要四个 animators。两个分别控制前面的内容（卡片正面）从左边翻出和从左边翻入。同时需要两个 animators 分别控制后面的内容（卡片反面）从右边翻入和右边翻出。<br>card_flip_left_in.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- Before rotating, immediately set the alpha to 0. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;1.0&quot;</span><br><span class="line">        android:valueTo=&quot;0.0&quot;</span><br><span class="line">        android:propertyName=&quot;alpha&quot;</span><br><span class="line">        android:duration=&quot;0&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Rotate. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;-180&quot;</span><br><span class="line">        android:valueTo=&quot;0&quot;</span><br><span class="line">        android:propertyName=&quot;rotationY&quot;</span><br><span class="line">        android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot;</span><br><span class="line">        android:duration=&quot;@integer/card_flip_time_full&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 1. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;0.0&quot;</span><br><span class="line">        android:valueTo=&quot;1.0&quot;</span><br><span class="line">        android:propertyName=&quot;alpha&quot;</span><br><span class="line">        android:startOffset=&quot;@integer/card_flip_time_half&quot;</span><br><span class="line">        android:duration=&quot;1&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p><p>card_flip_left_out.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- Rotate. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;0&quot;</span><br><span class="line">        android:valueTo=&quot;180&quot;</span><br><span class="line">        android:propertyName=&quot;rotationY&quot;</span><br><span class="line">        android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot;</span><br><span class="line">        android:duration=&quot;@integer/card_flip_time_full&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 0. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;1.0&quot;</span><br><span class="line">        android:valueTo=&quot;0.0&quot;</span><br><span class="line">        android:propertyName=&quot;alpha&quot;</span><br><span class="line">        android:startOffset=&quot;@integer/card_flip_time_half&quot;</span><br><span class="line">        android:duration=&quot;1&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p><p>card_flip_right_in.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- Before rotating, immediately set the alpha to 0. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;1.0&quot;</span><br><span class="line">        android:valueTo=&quot;0.0&quot;</span><br><span class="line">        android:propertyName=&quot;alpha&quot;</span><br><span class="line">        android:duration=&quot;0&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Rotate. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;180&quot;</span><br><span class="line">        android:valueTo=&quot;0&quot;</span><br><span class="line">        android:propertyName=&quot;rotationY&quot;</span><br><span class="line">        android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot;</span><br><span class="line">        android:duration=&quot;@integer/card_flip_time_full&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 1. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;0.0&quot;</span><br><span class="line">        android:valueTo=&quot;1.0&quot;</span><br><span class="line">        android:propertyName=&quot;alpha&quot;</span><br><span class="line">        android:startOffset=&quot;@integer/card_flip_time_half&quot;</span><br><span class="line">        android:duration=&quot;1&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p><p>card_flip_right_out.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!-- Rotate. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;0&quot;</span><br><span class="line">        android:valueTo=&quot;-180&quot;</span><br><span class="line">        android:propertyName=&quot;rotationY&quot;</span><br><span class="line">        android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot;</span><br><span class="line">        android:duration=&quot;@integer/card_flip_time_full&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 0. --&gt;</span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:valueFrom=&quot;1.0&quot;</span><br><span class="line">        android:valueTo=&quot;0.0&quot;</span><br><span class="line">        android:propertyName=&quot;alpha&quot;</span><br><span class="line">        android:startOffset=&quot;@integer/card_flip_time_half&quot;</span><br><span class="line">        android:duration=&quot;1&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p><h4 id="创建view"><a href="#创建view" class="headerlink" title="创建view"></a>创建view</h4><p>卡片的正反面是两个独立的 layout，方便之后将这两个独立的 layout 分别绑定到两个 Fragment 上。下面是这两个独立的 layout 之一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:padding=&quot;130dp&quot;&gt;</span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:background=&quot;#a6c&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">            android:text=&quot;FONT&quot;</span><br><span class="line">            android:textColor=&quot;#FFFFFF&quot;</span><br><span class="line">            android:textStyle=&quot;bold&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/RelativeLayout&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>下面是另一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:padding=&quot;130dp&quot;&gt;</span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:background=&quot;@color/colorPrimary&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">            android:text=&quot;BACK&quot;</span><br><span class="line">            android:textColor=&quot;#FFFFFF&quot;</span><br><span class="line">            android:textStyle=&quot;bold&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/RelativeLayout&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><h4 id="创建fragments"><a href="#创建fragments" class="headerlink" title="创建fragments"></a>创建fragments</h4><p>创建两个 Fragment 作为卡片的正反面，将之前的两个 layout 分别绑定到这两个 Fragment 上。然后将这两个 Fragment 作为 FragmentActivity 的展示内容，该 Activity 就是你要展示翻牌动画的页面。下面是两个 Fragment 的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CardFlipActivity extends FragmentActivity &#123;</span><br><span class="line">    ...</span><br><span class="line">    /**</span><br><span class="line">     * A fragment representing the front of the card.</span><br><span class="line">     */</span><br><span class="line">    public class CardFrontFragment extends Fragment &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public View onCreateView(LayoutInflater inflater, ViewGroup container,</span><br><span class="line">                Bundle savedInstanceState) &#123;</span><br><span class="line">            return inflater.inflate(R.layout.fragment_card_front, container, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * A fragment representing the back of the card.</span><br><span class="line">     */</span><br><span class="line">    public class CardBackFragment extends Fragment &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public View onCreateView(LayoutInflater inflater, ViewGroup container,</span><br><span class="line">                Bundle savedInstanceState) &#123;</span><br><span class="line">            return inflater.inflate(R.layout.fragment_card_back, container, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实现动画"><a href="#实现动画" class="headerlink" title="实现动画"></a>实现动画</h4><p>现在，你需要在 Activity 中展示这两个 Fragment 的内容。为了实现此需求，你应该为你的 Activity 创建一个 layout。下面的例子在此 layout 中创建了一个<code>FrameLayout</code>作为 Fragment 的容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:id=&quot;@+id/container&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>在 Activity 中，将以上的 layout 设置为 content view。然后在 Activity 的<code>oncreate</code>阶段显示卡片的正面内容。下面的例子展示了这一过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CardFlipActivity extends FragmentActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_activity_card_flip);</span><br><span class="line"></span><br><span class="line">        if (savedInstanceState == null) &#123;</span><br><span class="line">            getSupportFragmentManager()</span><br><span class="line">                    .beginTransaction()</span><br><span class="line">                    .add(R.id.container, new CardFrontFragment())</span><br><span class="line">                    .commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在你已经展示了卡片的正面，接下来要做的就是如何使用翻牌动画翻开卡片的背面，当卡片翻转到背面后，再次将其翻转到正面。下面的代码实现这一功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CardFlipActivity extends FragmentActivity &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    private void flipCard() &#123;</span><br><span class="line">        if (showingBack) &#123;</span><br><span class="line">            //Flip to the font.</span><br><span class="line">            showingBack = false;</span><br><span class="line">            getSupportFragmentManager()</span><br><span class="line">                    .beginTransaction()</span><br><span class="line">                    //注意setCustomAnimations()方法必须在add、remove、replace调用之前被设置，否则不起作用。</span><br><span class="line">                    .setCustomAnimations(</span><br><span class="line">                            R.animator.card_flip_left_in,</span><br><span class="line">                            R.animator.card_flip_left_out,</span><br><span class="line">                            0,</span><br><span class="line">                            0)</span><br><span class="line">                    .replace(R.id.flContainer, new CardFrontFragment())</span><br><span class="line">                    .commit();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // Flip to the back.</span><br><span class="line">        showingBack = true;</span><br><span class="line">        getSupportFragmentManager()</span><br><span class="line">                .beginTransaction()</span><br><span class="line">                .setCustomAnimations(</span><br><span class="line">                        R.animator.card_flip_right_in,</span><br><span class="line">                        R.animator.card_flip_right_out,</span><br><span class="line">                        0,</span><br><span class="line">                        0)</span><br><span class="line">                .replace(R.id.flContainer, new CardBackFragment())</span><br><span class="line">                .commit();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最终实现的效果：<br><img src="/2019/02/22/动画基础04：淡入、翻牌、揭露动画/anim_card_flip.gif" title="Card flip animation"></p><h2 id="揭露动画"><a href="#揭露动画" class="headerlink" title="揭露动画"></a>揭露动画</h2><p>当需要显示或者隐藏view时，揭露动画给用户提供了一种视觉上的延续。<code>ViewAnimationUtils.createCircularReveal()</code>方法可以帮助你实现此动画，此方式在 Android 5.0（API level 21） 以上提供。<br>下面的代码展示了如何使用揭露动画展示初始状态为 invisible 的 View：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// previously invisible view</span><br><span class="line">View myView = findViewById(R.id.my_view);</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    int cx = myView.getWidth() / 2;</span><br><span class="line">    int cy = myView.getHeight() / 2;</span><br><span class="line">    float finalRadius = (float) Math.hypot(cx, cy);</span><br><span class="line">    Animator anim = ViewAnimationUtils.createCircularReveal(myView, cx, cy, 0f, finalRadius);</span><br><span class="line">    myView.setVisibility(View.VISIBLE);</span><br><span class="line">    anim.start();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // set the view to visible without a circular reveal animation below Lollipop</span><br><span class="line">    myView.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ViewAnimationUtils.createCircularReveal()</code>动画一共有5个参数。第一个参数表示目标 View。接下来的两个参数代表了揭露动画开始的圆心坐标。一般地，这通常是目标 View的中心点坐标，但是你也可以将它定义为你的手指触摸点的坐标，从而使得揭露动画从你的手指触摸点开始揭露。第四个参数表示动画开始的圆形区域半径。<br>在上面的例子中，初始的圆形半径为0，从而目标 View 初始状态是隐藏的。最后一个参数代表揭露区域（圆形区域）的最大半径。值得注意的是，最后一个参数必须保证能够完全覆盖你的目标 View。<br>下面是使用揭露动画隐藏视图的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// previously visible view</span><br><span class="line">final View myView = findViewById(R.id.my_view);</span><br><span class="line">if (Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    int cx = myView.getWidth() / 2;</span><br><span class="line">    int cy = myView.getHeight() / 2;</span><br><span class="line">    float initialRadius = (float) Math.hypot(cx, cy);</span><br><span class="line">    Animator anim = ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, 0f);</span><br><span class="line">    anim.addListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">            super.onAnimationEnd(animation);</span><br><span class="line">            myView.setVisibility(View.INVISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    anim.start();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // set the view to invisible without a circular reveal animation below Lollipop</span><br><span class="line">    myView.setVisibility(View.INVISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实例中，揭露动画的初始半径足够覆盖整个目标视图，所以初始时的视图是完全可见的。最终的半径设置为0，则表示动画结束后会隐藏目标视图。注意，当动画结束后要将目标视图的 visiblility 属性设置为<code>INVISIBLE</code>以提高性能。<br>最终效果如下：<br><img src="/2019/02/22/动画基础04：淡入、翻牌、揭露动画/circular_reveal.gif" title="揭露动画"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者已将本节的代码上传至 &lt;a href=&quot;https://github.com/tangxianming/AnimationPracticeApplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，大家可以结合着学习。以下内容是对&lt;a href=&quot;https://developer.android.com/training/animation/reveal-or-hide-view#java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;的翻译。
    
    </summary>
    
      <category term="Android动画基础" scheme="http://yoursite.com/categories/Android%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="淡入淡出动画" scheme="http://yoursite.com/tags/%E6%B7%A1%E5%85%A5%E6%B7%A1%E5%87%BA%E5%8A%A8%E7%94%BB/"/>
    
      <category term="翻牌动画" scheme="http://yoursite.com/tags/%E7%BF%BB%E7%89%8C%E5%8A%A8%E7%94%BB/"/>
    
      <category term="揭露动画" scheme="http://yoursite.com/tags/%E6%8F%AD%E9%9C%B2%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Android动画（三）：矢量图动画</title>
    <link href="http://yoursite.com/2019/02/17/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8003%EF%BC%9A%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/02/17/动画基础03：矢量图动画/</id>
    <published>2019-02-17T02:04:42.000Z</published>
    <updated>2019-10-14T22:12:45.081Z</updated>
    
    <content type="html"><![CDATA[<p>笔者已将本节的代码上传至 <a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">Github</a>，大家可以结合着学习。本篇参考了CSDN作者：<code>Mr13_周</code> 的以下三篇文章。<a id="more"></a><br>1、<a href="https://blog.csdn.net/zwlove5280/article/details/73196543" target="_blank" rel="noopener">SVG 的 PathData 在 Android 中的使用</a><br>2、<a href="https://blog.csdn.net/zwlove5280/article/details/73442464" target="_blank" rel="noopener">Android：获取并制作矢量图动画</a><br>3、<a href="https://blog.csdn.net/zwlove5280/article/details/73650801" target="_blank" rel="noopener">Android 矢量图动画（完结篇）</a><br>在通读完这3篇文章后，笔者在代码实操后，补充以下知识点。</p><h4 id="知识一：strokeLineJoin-的-miter-模式-。"><a href="#知识一：strokeLineJoin-的-miter-模式-。" class="headerlink" title="知识一：strokeLineJoin 的 miter 模式 。"></a>知识一：strokeLineJoin 的 miter 模式 。</h4><p><code>strokeLineJoin</code>是 path 标签下的属性，负责线条的拐角形状，包括如下3个属性值：<br>1、miter : 默认值，也就是系统默认使用的。<br>2、round : 圆角式连接。<br>3、bevel：斜角式连接。<br>当线条拐角为 MITER 时，拐角处的外缘需要使用延长线来补偿：<br><img src="/2019/02/17/动画基础03：矢量图动画/1.jpg"><br>而这种补偿方案会有一个问题：如果拐角的角度太小，就有可能由于出现连接点过长的情况。比如这样：<br><img src="/2019/02/17/动画基础03：矢量图动画/2.jpg"><br>所以为了避免意料之外的过长的尖角出现， MITER 型连接点有一个额外的规则：当尖角过长时，自动改用  BEVEL 的方式来渲染连接点。例如上图的这个尖角，在默认情况下是不会出现的，而是会由于延长线过长而被转为 BEVEL 型连接点：<br><img src="/2019/02/17/动画基础03：矢量图动画/3.jpg"><br>至于多尖的角才属于过于尖，尖到需要转为使用 BEVEL 来绘制，则是由 path 标签的属性<code>strokeMiterLimit</code>来设置的。strokeMiterLimit 参数是对于转角长度的限制，具体来讲，是指尖角的外缘端点和内部拐角的距离与线条宽度的比。也就是下面这两个长度的比：<br><img src="/2019/02/17/动画基础03：矢量图动画/4.jpg"><br>这个 strokeMiterLimit 的默认值是 4，对应的是一个大约 29° 的锐角：<br><img src="/2019/02/17/动画基础03：矢量图动画/5.jpg"><br>默认情况下，大于这个角的尖角会被保留，而小于这个夹角的 strokeLineJoin 就会被自动转换为 bevel 模式。<br><a href="https://hencoder.com/ui-1-2/" target="_blank" rel="noopener">参考地址&gt;&gt;</a></p><h4 id="知识二：SVG、VectorDrawable、AnimatedVectorDrawable之间的联系。"><a href="#知识二：SVG、VectorDrawable、AnimatedVectorDrawable之间的联系。" class="headerlink" title="知识二：SVG、VectorDrawable、AnimatedVectorDrawable之间的联系。"></a>知识二：SVG、VectorDrawable、AnimatedVectorDrawable之间的联系。</h4><p>SVG是一种格式，代表矢量图形，类似的有JPG、PNG格式。SVG不能在 Android 中直接使用。<br>VectorDrawable 是 Android 5.0 系统中引入了来支持矢量图(SVG)的，同时还引入了 AnimatedVectorDrawable 来支持矢量图动画。<br>市场上有很多SVG转 VectorDrawable 的工具，笔者推荐<a href="https://inloop.github.io/svg2android/" target="_blank" rel="noopener">这个网站</a>，不过需要科学上网哦。</p><h4 id="知识三：VectorDrawable的各个标签的属性介绍。"><a href="#知识三：VectorDrawable的各个标签的属性介绍。" class="headerlink" title="知识三：VectorDrawable的各个标签的属性介绍。"></a>知识三：VectorDrawable的各个标签的属性介绍。</h4><p>如果你喜欢原滋原味的，请查看<a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable" target="_blank" rel="noopener">官方文档</a>。如果喜欢翻译好了的，请移步<a href="https://juejin.im/entry/5899404a128fe10065689b34" target="_blank" rel="noopener">这篇文章</a>的最后部分。</p><h4 id="知识四：对trimPathStart、trimPathEnd、trimPathOffset属性的理解。"><a href="#知识四：对trimPathStart、trimPathEnd、trimPathOffset属性的理解。" class="headerlink" title="知识四：对trimPathStart、trimPathEnd、trimPathOffset属性的理解。"></a>知识四：对trimPathStart、trimPathEnd、trimPathOffset属性的理解。</h4><p>具体介绍请移步到简书的<a href="https://www.jianshu.com/p/6bb3584dda41" target="_blank" rel="noopener">这篇文章</a>。这里还有一点需要补充，当他们的值n大于1时，实际的值是n-1，比如 trimPathStart 的值是1.1，那么系统会自动按0.1处理。注意，n不能小于0，否者会将当前path全部修剪。其它的情况，可以下载笔者的代码自己操作一下。</p><h4 id="知识五：怎么处理兼容性？"><a href="#知识五：怎么处理兼容性？" class="headerlink" title="知识五：怎么处理兼容性？"></a>知识五：怎么处理兼容性？</h4><p>Android从5.0版本（API 21）才开始支持矢量图，引入了 VectorDrawable（矢量图） 和 AnimatedVectorDrawable（矢量图动画）。对于低版本，官方虽然也给出了<a href="https://www.jianshu.com/p/dd218763282c" target="_blank" rel="noopener">兼容方法</a>，但是依然还有很多坑要踩，比如<a href="https://cloud.tencent.com/developer/article/1160396" target="_blank" rel="noopener">这篇文章</a>所说的。所以笔者建议如果没有强制要求的话，还是把你的app的最低版本支持提高到API 21吧。</p><h4 id="知识六：width、height、viewportWidth、viewportHeight属性说明。"><a href="#知识六：width、height、viewportWidth、viewportHeight属性说明。" class="headerlink" title="知识六：width、height、viewportWidth、viewportHeight属性说明。"></a>知识六：width、height、viewportWidth、viewportHeight属性说明。</h4><p>1、android:width \ android:height：定义矢量图的宽高。<br>2、android:viewportHeight \ android:viewportWidth：定义图像被划分的比例大小。比如width=200dp、viewportWidth=500，即把200dp大小的图像划分成500份，后面Path标签中的坐标，就全部使用的是这里划分后的坐标系统。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者已将本节的代码上传至 &lt;a href=&quot;https://github.com/tangxianming/AnimationPracticeApplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，大家可以结合着学习。本篇参考了CSDN作者：&lt;code&gt;Mr13_周&lt;/code&gt; 的以下三篇文章。
    
    </summary>
    
      <category term="Android动画基础" scheme="http://yoursite.com/categories/Android%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="AnimationDrawable" scheme="http://yoursite.com/tags/AnimationDrawable/"/>
    
      <category term="AnimatedVectorDrawable" scheme="http://yoursite.com/tags/AnimatedVectorDrawable/"/>
    
  </entry>
  
  <entry>
    <title>Android动画（二）：视图动画、属性动画</title>
    <link href="http://yoursite.com/2019/01/25/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8002%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E3%80%81%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/01/25/动画基础02：视图动画、属性动画/</id>
    <published>2019-01-25T08:57:30.000Z</published>
    <updated>2019-10-14T22:12:45.080Z</updated>
    
    <content type="html"><![CDATA[<p>笔者已将本节的代码上传至<a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">Github</a>，大家可以结合着学习。<br>本篇以文章<a href="https://juejin.im/post/5aea7063f265da0b9b072758" target="_blank" rel="noopener">《Android 动画：这是一份详细 &amp; 清晰的动画学习指南》</a>为基础，笔者在通读了这篇文章并进行了必要的代码实操后觉得有三个知识点需要补充，所以本篇将记录下这三个知识点。<a id="more"></a></p><h4 id="知识一：LayoutAnimation的局限性"><a href="#知识一：LayoutAnimation的局限性" class="headerlink" title="知识一：LayoutAnimation的局限性"></a>知识一：LayoutAnimation的局限性</h4><p>LayoutAnimation 只在创建 ViewGroup 的时候生效，后续添加的子 View 是没有动画效果的。这和 LayoutTransition 有很大的区别，在后续介绍<a href="https://kimball325.github.io/2019/01/25/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8002%EF%BC%9A%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%E3%80%81%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/" target="_blank" rel="noopener">布局动画</a>时再展开介绍。</p><h4 id="知识二：动画监听方法归类"><a href="#知识二：动画监听方法归类" class="headerlink" title="知识二：动画监听方法归类"></a>知识二：动画监听方法归类</h4><p>1、转场动画相关<br>Animation.setAnimationListener(Animation.AnimationListener listener);<br>2、属性动画相关<br>Animator.addListener(AnimatorListenerAdapter adapter);<br>Animator.addListener(Animator.AnimatorListener listener);<br>Animator.addPauseListener(Animator.AnimatorPauseListener listener);<br>Animator.addUpdateListener(ValueAnimator.AnimatorUpdateListener listener);<br>3、ViewPropertyAnimator动画相关<br>ViewPropertyAnimator.setListener(AnimatorListenerAdapter adapter);<br>ViewPropertyAnimator.setListener(Animator.AnimatorListener listener);<br>ViewPropertyAnimator.setUpdateListener(AnimatorUpdateListener listener);<br>ViewPropertyAnimator.withEndAction(Runnable runnable);<br>ViewPropertyAnimator.withStartAction(Runnable runnable);</p><blockquote><p><strong> 注意 </strong><br>withStartAction() / withEndAction() 是一次性的，在动画执行结束后就自动弃掉了，就算之后再重用  ViewPropertyAnimator 来做别的动画，用它们设置的回调也不会再被调用。而 set/addListener() 所设置的 AnimatorListener 是持续有效的，当动画重复执行时，回调总会被调用。</p></blockquote><p><a href="https://hencoder.com/ui-1-6/" target="_blank" rel="noopener">参考链接&gt;&gt;</a></p><h4 id="知识三：AnimationDrawable的使用时机"><a href="#知识三：AnimationDrawable的使用时机" class="headerlink" title="知识三：AnimationDrawable的使用时机"></a>知识三：AnimationDrawable的使用时机</h4><p>AnimationDrawable 的 start 方法不能在你的 Activity 的<code>onCreate()</code>中使用，否者会没有效果，因为这个时候 AnimationDrawable 还没有绑定到窗口。如果你想在进入页面后立即开始动画，可以在你的 Activity 的<code>onStart()</code>方法中调用。当然，你也可以在交互监听中调用 start 方法，比如在某个 View 的<code>onClick()</code>方法中调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者已将本节的代码上传至&lt;a href=&quot;https://github.com/tangxianming/AnimationPracticeApplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，大家可以结合着学习。&lt;br&gt;本篇以文章&lt;a href=&quot;https://juejin.im/post/5aea7063f265da0b9b072758&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Android 动画：这是一份详细 &amp;amp; 清晰的动画学习指南》&lt;/a&gt;为基础，笔者在通读了这篇文章并进行了必要的代码实操后觉得有三个知识点需要补充，所以本篇将记录下这三个知识点。
    
    </summary>
    
      <category term="Android动画基础" scheme="http://yoursite.com/categories/Android%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Animation" scheme="http://yoursite.com/tags/Animation/"/>
    
      <category term="LayoutAnimation" scheme="http://yoursite.com/tags/LayoutAnimation/"/>
    
      <category term="Animator" scheme="http://yoursite.com/tags/Animator/"/>
    
      <category term="ValueAnimator" scheme="http://yoursite.com/tags/ValueAnimator/"/>
    
      <category term="ObjectAnimator" scheme="http://yoursite.com/tags/ObjectAnimator/"/>
    
      <category term="ViewPropertyAnimator" scheme="http://yoursite.com/tags/ViewPropertyAnimator/"/>
    
  </entry>
  
  <entry>
    <title>Android动画（一）：坐标、区域、视图层级</title>
    <link href="http://yoursite.com/2019/01/15/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%8001%EF%BC%9A%E5%9D%90%E6%A0%87%E3%80%81%E5%8C%BA%E5%9F%9F%E3%80%81%E8%A7%86%E5%9B%BE%E5%B1%82%E7%BA%A7/"/>
    <id>http://yoursite.com/2019/01/15/动画基础01：坐标、区域、视图层级/</id>
    <published>2019-01-15T09:01:21.000Z</published>
    <updated>2019-10-14T22:12:45.080Z</updated>
    
    <content type="html"><![CDATA[<p>笔者已将本节的代码上传至 <a href="https://github.com/tangxianming/AnimationPracticeApplication" target="_blank" rel="noopener">Github</a>，大家可以结合着学习。<a id="more"></a></p><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>event.getX()：表示的是触摸的点距离自身左边界的距离。<br>event.getY()：表示的是触摸的点距离自身上边界的距离。<br>event.getRawX：表示的是触摸点距离屏幕左边界的距离。<br>event.getRawY：表示的是触摸点距离屏幕上边界的距离，包括状态栏。<br>View.getX：表示View左上角相对于父容器的x坐标。<br>View.getY：表示View左上角相对于父容器的y坐标。<br>View.getTranslationX()：计算的是该View在X轴的偏移量。初始值为0，向左偏移值为负，向右偏移值为正。<br>View.getTranslationY()：计算的是该View在Y轴的偏移量。初始值为0，向上偏移为负，向下偏移为正。<br>View.getLocationInWindow(pos)：计算的是view在其父窗口中的坐标位置。<br>View.getLocationOnScreen(pos)：计算的是view在其整个屏幕上的坐标位置。</p><blockquote><p><strong>知识补充</strong><br>1、Android中每个 View 都有一个自己的坐标系，彼此之间是不影响的。这个坐标系的原点是 View 左上角的那个点；水平方向是 x 轴，右正左负；竖直方向是 y 轴，下正上负。<a href="https://hencoder.com/ui-1-1/" target="_blank" rel="noopener">查看来源</a><br>2、如果重写 Activity 的<code>onTouchEvent(MotionEvent event)</code>方法，这个时候 event.getX() 与 event.getRawX() 获取的值是一样的，event.getY() 与 event.getRawY() 获取的值是一样，但是直接触摸状态栏、底部导航栏时的坐标位置不能获得。<a href="https://blog.csdn.net/xuxingxing002/article/details/50328529" target="_blank" rel="noopener">查看来源</a><br>3、view.translationX 表示 view 在原来基础上移动多少，view.X 表示最终要移动到X轴的哪个位置，view.getX() 的值为 view.getLeft() 与 view.getTranslationX() 之和。<a href="https://www.jianshu.com/p/8dec4dd68fd9" target="_blank" rel="noopener">查看来源</a><br>4、当view是在dialog 或 popupWindow 上显示时，getLocationInWindow获得的值是相对于 dialog 或者 popuwindow 左上角的坐标。<a href="http://www.itdaan.com/blog/2015/09/11/e032ab54ebed4076e988044fa973b6a7.html" target="_blank" rel="noopener">查看来源1</a>  | <a href="https://blog.csdn.net/ouyang_peng/article/details/46902957" target="_blank" rel="noopener">查看来源2</a></p></blockquote><h2 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h2><p>我为便于表述，统一把<strong>视图大小</strong>、<strong>视图范围</strong>、<strong>Android 5.0主题风格</strong>的知识都划归到这一部分，大家不必纠结，重点关注每个知识点的概念以及区别。<br>View.getWidth()：表示的是当前控件的宽度，即getRight()-getLeft()。<br>View.getHeight()：表示的是当前控件的高度，即getBottom()-getTop()。<br>View.getTop()：子View的顶部到父View顶部的距离。<br>View.getRight()：子View的右边界到父View的左边界的距离。<br>View.getBottom()：子View的底部到父View的顶部的距离。<br>View.getLeft()：子View的左边界到父View的左边界的距离。<br>View.getGlobalVisibleRect(rect)：得到整体相对于屏幕（包括状态栏）的区域范围rect，这个rect表示当前view的范围。<br>View.getLocalVisibleRect(rect)：得到自己显示的区域，这个区域的坐标是相对自身的，仅仅用来表示自身所占的范围。左上角坐标一直为（0，0），右下角通过计算可得。<br>View.getWindowVisibleDisplayFrame(rect)：获取到程序显示的区域，包括标题栏（ActionBar），不包括状态栏、导航栏、键盘区域(如弹起)。</p><blockquote><p><strong>知识补充</strong><br>1、<a href="https://blog.csdn.net/chenbing81/article/details/75902401" target="_blank" rel="noopener">Android手机获取屏幕分辨率高度因虚拟导航栏带来的问题。</a><br>2、<a href="https://blog.csdn.net/u012764110/article/details/49783465" target="_blank" rel="noopener">如何在onCreate方法中获取状态栏，底部导航栏高度？</a><br>（注意：即使状态栏、底部导航栏被隐藏，他们的高度依然可以按链接中的方法得到。）<br>3、<a href="https://www.jianshu.com/p/a179d9419c35" target="_blank" rel="noopener">获取View高度的三种方法。</a></p></blockquote><p>Android 5.0之后的主题风格：<br><img src="/2019/01/15/动画基础01：坐标、区域、视图层级/2.jpg"><br>1、如果 app 的标题栏仍是使用 actionbar，则直接在风格 (styles) 或是主题 (themes) 里进行设定 colorPrimary 参数即可；若是采用 toolbar 的话，则要在界面 (layout) 里面设定 toolbar 控件的 background 属性。<br>2、如果在 style 中设置了 statusBarColor，则会覆盖 colorPrimaryDark 的影响，即：状态栏的颜色将是 statusBarColor。</p><h2 id="视图层级"><a href="#视图层级" class="headerlink" title="视图层级"></a>视图层级</h2><img src="/2019/01/15/动画基础01：坐标、区域、视图层级/1.png"><p>getParent：获取上一级容器。<br>getRootView： 获取顶级视图 ecorView。<br>getWindow().getDecorView()：获取顶级视图 DecorView。<br>findViewById(android.R.id.content)：获取 Xml 根布局的父容器。可想而知，不包括状态栏、标题栏（ActionBar）、导航栏。<br>对于视图层级，如果要深入了解的话，请参考<a href="https://www.jianshu.com/p/8766babc40e0" target="_blank" rel="noopener">这篇文章&gt;&gt;</a>。</p><hr><p><strong>参考资料</strong><br>1.<a href="https://www.jianshu.com/p/df4baad0591e" target="_blank" rel="noopener">Android 屏幕坐标系</a><br>2.<a href="https://www.cnblogs.com/tianzhijiexian/p/4097225.html" target="_blank" rel="noopener">得到view坐标的各种方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者已将本节的代码上传至 &lt;a href=&quot;https://github.com/tangxianming/AnimationPracticeApplication&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，大家可以结合着学习。
    
    </summary>
    
      <category term="Android动画基础" scheme="http://yoursite.com/categories/Android%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="坐标" scheme="http://yoursite.com/tags/%E5%9D%90%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>DecimalFormat使用详解</title>
    <link href="http://yoursite.com/2018/08/11/DecimalFormat%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/08/11/DecimalFormat使用详解/</id>
    <published>2018-08-11T03:16:06.000Z</published>
    <updated>2019-02-17T02:03:35.645Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>产品狗的需求：</strong><br>要求客户端拿到服务器返回的数据后，以最多保留2位小数的形式展示该数据。例如：2.247==&gt;2.25、2.20==&gt;2.2。</p></blockquote><a id="more"></a><p>拿到这个需求后，当然最先考虑的是使用<code>String.format(&quot;%.2f&quot;, 2.20)</code>,可是结果却是：<br><img src="/2018/08/11/DecimalFormat使用详解/1.jpg"><br>很显然，String.format的形式只能适用于固定的小数保留需求。<br>之后笔者在网上搜索了一圈，发现主要有DecimalFormat、BigDecimal、NumberFormat<a href="https://www.cnblogs.com/chenrenshui/p/6128444.html" target="_blank" rel="noopener">这几种方案</a>。鉴于它们的功能一样，本文就对DecimalFormat做一番研究。</p><h2 id="DecimalFormat-中的-0-和"><a href="#DecimalFormat-中的-0-和" class="headerlink" title="DecimalFormat 中的 0 和 #"></a>DecimalFormat 中的 0 和 #</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line">public class DecimalFormatTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[]args)&#123;</span><br><span class="line">DecimalFormat df1,df2;</span><br><span class="line">System.out.println(&quot;整数部分0/#的区别&quot;);</span><br><span class="line"></span><br><span class="line">df1 = new DecimalFormat(&quot;#.00&quot;);</span><br><span class="line">df2 = new DecimalFormat(&quot;0.00&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(df1.format(0.1)); // .10</span><br><span class="line">System.out.println(df2.format(0.1)); // 0.10  </span><br><span class="line"></span><br><span class="line">System.out.println(&quot;小数部分0/#的区别&quot;);</span><br><span class="line"></span><br><span class="line">df1 = new DecimalFormat(&quot;0.00&quot;);</span><br><span class="line">df2 = new DecimalFormat(&quot;0.##&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(df1.format(0.1)); // 0.10</span><br><span class="line">System.out.println(df2.format(0.1)); // 0.1</span><br><span class="line"></span><br><span class="line">System.out.println(df1.format(0.006)); // 0.01</span><br><span class="line">System.out.println(df2.format(0.006)); // 0.01</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;3、整数部分有多位&quot;);</span><br><span class="line"></span><br><span class="line">df1 = new DecimalFormat(&quot;0.00&quot;);</span><br><span class="line">df2 = new DecimalFormat(&quot;#.00&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(df1.format(2)); // 2.00</span><br><span class="line">System.out.println(df2.format(2)); // 2.00</span><br><span class="line"></span><br><span class="line">System.out.println(df1.format(20)); // 20.00</span><br><span class="line">System.out.println(df2.format(20)); // 20.00</span><br><span class="line"></span><br><span class="line">System.out.println(df1.format(200)); // 200.00</span><br><span class="line">System.out.println(df2.format(200)); // 200.00</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong><br>1、小数部分 #代表最多有几位，0代表必须有且只能有几位。<br>.00 表示最终结果有两位小数,没有则补0，多了就四舍五入第三个小数。<br>.## 表示最终结果最多有两位小数，一位或者没有都可以，多了同样四舍五入第三位。<br>2、整数部分 0 和 #。<br>当整数部分为0时，比如 0.1，# 此时认为整数部分不存在，所以不写 。0 认为没有至少也得一位，写上0。（这跟上面第一部分的表现是一致的：# 有就写，没有就不写；0 必须有，没有就补0。）<br>3、整数部分有多位时： 2；20；200。<br>由上面的结果可以看出 0和#对整数部分多位时的处理是一致的，就是有几位写多少位。（这跟上面两部分的表现是不一致的 在有多位时，0和#都没有匹配位数，而是有多少写多少。）<br>通常，我们使用的处理方式有： 0.00 或者 0.## 。<br><strong>实践：</strong><br>对于问题中的2.247==&gt;2.25、2.20==&gt;2.2，采用DecimalFormat实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new DecimalFormat(&quot;0.##&quot;).format(dd);</span><br></pre></td></tr></table></figure></p><h2 id="问题延伸"><a href="#问题延伸" class="headerlink" title="问题延伸"></a>问题延伸</h2><p><a href="https://blog.csdn.net/alanzyy/article/details/8465098" target="_blank" rel="noopener">1、DecimalFormat对数值格式化的舍入问题——RoundingMode。</a><br><a href="https://www.cnblogs.com/yjmyzz/p/4427669.html" target="_blank" rel="noopener">2、恶心的0.5四舍五入问题。</a><br>对于此条问题，笔者使用的方式是文中所提及的<code>在具体数据后加上0.000001</code>。<br>3、String.format对于浮点型数据的展示问题。<br>注意在精度要求高的情况下，<strong>String.format中使用的浮点数必须是双精度的</strong>，这样才能确保四舍五入的规则正确。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(&quot;%.2f&quot;, 2.245f));</span><br></pre></td></tr></table></figure></p><p>打印的结果是 2.24，错误。如果是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(&quot;%.2f&quot;, 2.245));</span><br></pre></td></tr></table></figure></p><p>打印的结果就是 2.25，正确。<br>为什么会这样呢？这里涉及到精度损耗的问题。在<code>String.format(&quot;%.2f&quot;, 2.245f)</code>中接受的数值应该是double类型的，所以2.245f 实际上是被转换为了double类型。而 java 将2.245f 强制转化为double类型后，得到的实际double类型值为：2.244999885559082。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;产品狗的需求：&lt;/strong&gt;&lt;br&gt;要求客户端拿到服务器返回的数据后，以最多保留2位小数的形式展示该数据。例如：2.247==&amp;gt;2.25、2.20==&amp;gt;2.2。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="DecimalFormat" scheme="http://yoursite.com/tags/DecimalFormat/"/>
    
  </entry>
  
  <entry>
    <title>由View.post()方法引发的想象</title>
    <link href="http://yoursite.com/2018/07/21/%E7%94%B1View-post-%E6%96%B9%E6%B3%95%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%B3%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/07/21/由View-post-方法引发的想象/</id>
    <published>2018-07-21T09:57:19.000Z</published>
    <updated>2019-12-16T14:45:53.361Z</updated>
    
    <content type="html"><![CDATA[<p>如题，笔者在想这个标题的时候思考了很久，不知道应该取一个什么样的标题才能涵盖全本篇要涉及的内容。绞尽脑子，最终确定起这个不痛不痒的标题。原因是，写这篇文章之前的一系列相关疑惑就是从View.post()开始的。<a id="more"></a><br>本篇要探究这么几个问题：<br>1、都知道非静态内部类和匿名类会引发内存泄露，并且我们也知道如何取避免这个问题的发生，但是怎样做得更加完美呢？<br>2、View.Post()中的run方法和Handler.post()方法中的run方法运行线程有什么不同呢？<br>3、View.Post()中的run方法在整个Activity的生命周期的里处在哪个位置呢？<br>好，以上三个问题就是我要总结的重点了。注意，下面对post方法将做的总结，对于postDelay同样适用。</p><h2 id="问题一的情况"><a href="#问题一的情况" class="headerlink" title="问题一的情况"></a>问题一的情况</h2><p>这个问题前面说过我们知道如何去避免它的发生，避免的方法可参考<a href="https://github.com/francistao/LearningNotes/blob/master/Part1/Android/Android内存泄漏总结.md" target="_blank" rel="noopener">这篇文章</a>。但是，对于真正的生产环境，这些还是不够的。所引文章中所提虽然避免了 Activity 泄漏，不过 Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列MessageQueue 中的消息。下面几个方法都可以移除 Message：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void removeCallbacks(Runnable r);</span><br><span class="line"></span><br><span class="line">public final void removeCallbacks(Runnable r, Object token);</span><br><span class="line"></span><br><span class="line">public final void removeCallbacksAndMessages(Object token);</span><br><span class="line"></span><br><span class="line">public final void removeMessages(int what);</span><br><span class="line"></span><br><span class="line">public final void removeMessages(int what, Object object);</span><br></pre></td></tr></table></figure></p><p>以上讨论的内容虽未提及View.post()系列，但是对于View.post()系列同样存在内存泄露的问题，我们可以用同样的方式避免，但是之后我们依然要记住removeCallbacks()噢。</p><h2 id="问题二的情况"><a href="#问题二的情况" class="headerlink" title="问题二的情况"></a>问题二的情况</h2><p>请允许我直接从<a href="https://stackoverflow.com/questions/41728973/what-is-the-difference-between-view-postdelayed-and-handler-postdelayed-on-t" target="_blank" rel="noopener">Stack Overflow</a>粘过来吧(别打我😜)<br>According to the documentation of Handler.postDelayed(Runnable r, long delayMillis):</p><blockquote><p>Causes the Runnable r to be added to the message queue, to be run after the specified amount of time elapses. The runnable will be run on the thread to which this handler is attached.</p></blockquote><p>On the other hand View.postDelayed(Runnable action, long delayMillis):</p><blockquote><p>Causes the Runnable to be added to the message queue, to be run after the specified amount of time elapses. The runnable will be run on the user interface thread.</p></blockquote><h2 id="问题三的情况"><a href="#问题三的情况" class="headerlink" title="问题三的情况"></a>问题三的情况</h2><p>探究这个问题主要是为了以后在post(new Runnable(){……})的run方法中写逻辑时，可以清晰的知道它在Activity的生命周期中所处的位置（这是很必要的，比如AnimationDrawable的start()方法只能在onStart()中或者之后执行才有效）。为了验证，我们直接上代码吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">tvContent=findViewById(R.id.tvContent);</span><br><span class="line">tvContent.post(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">Log.d(TAG, &quot;run&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void onStart() &#123;</span><br><span class="line">super.onStart();</span><br><span class="line">Log.d(TAG, &quot;onStart&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void onStop() &#123;</span><br><span class="line">super.onStop();</span><br><span class="line">Log.d(TAG, &quot;onStop&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void onPause() &#123;</span><br><span class="line">super.onPause();</span><br><span class="line">Log.d(TAG, &quot;onPause&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void onResume() &#123;</span><br><span class="line">super.onResume();</span><br><span class="line">Log.d(TAG, &quot;onResume&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void onAttachedToWindow() &#123;</span><br><span class="line">super.onAttachedToWindow();</span><br><span class="line">Log.d(TAG, &quot;onAttachedToWindow&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">super.onDestroy();</span><br><span class="line">Log.d(TAG, &quot;onDestroy&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码很简单，这里不多解释了，直接看运行结果吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onStart</span><br><span class="line">onResume</span><br><span class="line">onAttachedToWindow</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p><p>结论很明显了，此时的run方法处在onAttachedToWindow方法之后。题外话，对于onAttachedToWindow方法Google的解释是下面这样的：</p><blockquote><p>This is called when the view is attached to a window. At this point it has a Surface and will start drawing. Note that this function is guaranteed to be called before onDraw(android.graphics.Canvas), however it may be called any time before the first onDraw – including before or after onMeasure(int, int).<br>If you override this method you must call through to the superclass implementation.</p></blockquote><p>大概意思是onAttachedToWindow可以保证在首个ondraw方法调用前被调用。因此，我们可以很放心地将一些绘制之前的初始化操作放在onAttachedToWindow里面。</p><h2 id="问题延伸"><a href="#问题延伸" class="headerlink" title="问题延伸"></a>问题延伸</h2><p>我知道问题已经很杂了，既然标题是[**引发的想象]，那么请允许我发挥想象吧😄。这个问题是：对于Application，Service，Activity三者的Context的应用场景是怎样的呢？直接盗用一张图吧：<br><img src="/2018/07/21/由View-post-方法引发的想象/image02.png"><br>其中： NO1表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如题，笔者在想这个标题的时候思考了很久，不知道应该取一个什么样的标题才能涵盖全本篇要涉及的内容。绞尽脑子，最终确定起这个不痛不痒的标题。原因是，写这篇文章之前的一系列相关疑惑就是从View.post()开始的。
    
    </summary>
    
      <category term="Android 其它" scheme="http://yoursite.com/categories/Android-%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="内存泄露" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>Android演化历史</title>
    <link href="http://yoursite.com/2018/06/21/Android%E5%90%84%E7%89%88%E6%9C%AC%E4%BB%A3%E5%8F%B7%E3%80%81%E7%89%88%E6%9C%AC%E5%8F%B7%E3%80%81API%E7%BA%A7%E5%88%AB%E3%80%81%E5%8F%91%E5%B8%83%E6%97%B6%E9%97%B4%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/06/21/Android各版本代号、版本号、API级别、发布时间对照表/</id>
    <published>2018-06-21T15:06:09.000Z</published>
    <updated>2019-02-17T02:03:35.643Z</updated>
    
    <content type="html"><![CDATA[<p>Android开发过程中，经常会遇到类似于这个版本号对应的API级别是多少？这个API级别对应的版本号是多少？这样的问题。本文就以此为出发点，详细的介绍一下Android的版本演化进程。一是为了下次再遇到前面说的问题时能够快速查找本文得到答案，二是让自己对Android发展历程有一个清晰的思路。<a id="more"></a></p><h2 id="对照表"><a href="#对照表" class="headerlink" title="对照表"></a>对照表</h2><table><thead><tr><th>版本号</th><th>API级别</th><th style="text-align:center">代号</th><th style="text-align:right">发布时间</th></tr></thead><tbody><tr><td>Android 9.0</td><td>28</td><td style="text-align:center">P</td><td style="text-align:right">2018-3</td></tr><tr><td>Android 8.1</td><td>27</td><td style="text-align:center">Oreo</td><td style="text-align:right"></td></tr><tr><td>Android 8.0</td><td>26</td><td style="text-align:center">Oreo</td><td style="text-align:right">2017-3</td></tr><tr><td>Android 7.1.1</td><td>25</td><td style="text-align:center">Nougat</td><td style="text-align:right">2016-10</td></tr><tr><td>Android 7.0</td><td>24</td><td style="text-align:center">Nougat</td><td style="text-align:right">2016-08</td></tr><tr><td>Android 6.0</td><td>23</td><td style="text-align:center">Marshmallow</td><td style="text-align:right">2015-10</td></tr><tr><td>Android 5.1</td><td>22</td><td style="text-align:center">Lollipop</td><td style="text-align:right">2015-03</td></tr><tr><td>Android 5.0</td><td>21</td><td style="text-align:center">Lollipop</td><td style="text-align:right">2014-11</td></tr><tr><td>Android 4.4W</td><td>20</td><td style="text-align:center">KitKat</td><td style="text-align:right">2014-06</td></tr><tr><td>Android 4.4</td><td>19</td><td style="text-align:center">KitKat</td><td style="text-align:right">2013-10</td></tr><tr><td>Android 4.3</td><td>18</td><td style="text-align:center">Jelly Bean</td><td style="text-align:right">2013-07</td></tr><tr><td>Android 4.2</td><td>17</td><td style="text-align:center">Jelly Bean</td><td style="text-align:right">2012-11</td></tr><tr><td>Android 4.1</td><td>16</td><td style="text-align:center">Jelly Bean</td><td style="text-align:right">2012-07</td></tr><tr><td>Android 4.0.3</td><td>15</td><td style="text-align:center">Ice Cream Sandwich</td><td style="text-align:right">2011-12</td></tr><tr><td>Android 4.0</td><td>14</td><td style="text-align:center">Ice Cream Sandwich</td><td style="text-align:right">2011-10</td></tr><tr><td>Android 3.2</td><td>13</td><td style="text-align:center">Honeycomb</td><td style="text-align:right">2011-07</td></tr><tr><td>Android 3.1</td><td>12</td><td style="text-align:center">Honeycomb</td><td style="text-align:right">2011-05</td></tr><tr><td>Android 3.0</td><td>11</td><td style="text-align:center">Honeycomb</td><td style="text-align:right">2011-02</td></tr><tr><td>Android 2.3.3</td><td>10</td><td style="text-align:center">Gingerbread</td><td style="text-align:right">2011-02</td></tr><tr><td>Android 2.3</td><td>9</td><td style="text-align:center">Gingerbread</td><td style="text-align:right">2010-12</td></tr><tr><td>Android 2.2</td><td>8</td><td style="text-align:center">Froyo</td><td style="text-align:right">2010-05</td></tr><tr><td>Android 2.1</td><td>7</td><td style="text-align:center">Eclair</td><td style="text-align:right">2010-01</td></tr><tr><td>Android 2.0.1</td><td>6</td><td style="text-align:center">Eclair</td><td style="text-align:right">2009-12</td></tr><tr><td>Android 2.0</td><td>5</td><td style="text-align:center">Eclair</td><td style="text-align:right">2009-10</td></tr><tr><td>Android 1.6</td><td>4</td><td style="text-align:center">Donut</td><td style="text-align:right">2009-09</td></tr><tr><td>Android 1.5</td><td>3</td><td style="text-align:center">Cupcake</td><td style="text-align:right">2009-04</td></tr><tr><td>Android 1.1</td><td>2</td><td style="text-align:center"></td><td style="text-align:right">2009-02</td></tr><tr><td>Android 1.0</td><td>1</td><td style="text-align:center"></td><td style="text-align:right">2008-09</td></tr></tbody></table><h2 id="Android重要历史版本功能"><a href="#Android重要历史版本功能" class="headerlink" title="Android重要历史版本功能"></a>Android重要历史版本功能</h2><h4 id="Android-7-0"><a href="#Android-7-0" class="headerlink" title="Android 7.0"></a>Android 7.0</h4><ul><li>多语言区域支持，更多语言</li><li>多窗口支持</li><li>新增的表情符号<br><a href="https://developer.android.com/about/versions/nougat/android-7.0" target="_blank" rel="noopener">see more>></a></li></ul><h4 id="Android-6-0"><a href="#Android-6-0" class="headerlink" title="Android 6.0"></a>Android 6.0</h4><ul><li>运行时权限及其管理</li><li>低电耗模式和应用待机模式</li><li>文本选择</li><li>WLAN 和网络连接变更</li><li>指纹身份验证</li><li>主题化 ColorStateList<br><a href="https://developer.android.com/about/versions/marshmallow/" target="_blank" rel="noopener">see more>></a></li></ul><h4 id="Android-5-0"><a href="#Android-5-0" class="headerlink" title="Android 5.0"></a>Android 5.0</h4><ul><li>Material Design</li><li>全新的通知中心设计</li><li>支持64位ART虚拟机<br><a href="https://developer.android.com/about/versions/lollipop" target="_blank" rel="noopener">see more>></a></li></ul><h4 id="Android-4-4"><a href="#Android-4-4" class="headerlink" title="Android 4.4"></a>Android 4.4</h4><ul><li>全屏沉浸模式</li><li>透明系统 UI 样式</li><li>用于动画场景的转场框架</li><li>屏幕录制</li><li>步测器和计步器<br><a href="https://developer.android.com/about/versions/kitkat" target="_blank" rel="noopener">see more>></a></li></ul><hr><p><strong>参考资料</strong><br><a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element#ApiLevels" target="_blank" rel="noopener">Android平台版本对比</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android开发过程中，经常会遇到类似于这个版本号对应的API级别是多少？这个API级别对应的版本号是多少？这样的问题。本文就以此为出发点，详细的介绍一下Android的版本演化进程。一是为了下次再遇到前面说的问题时能够快速查找本文得到答案，二是让自己对Android发展历程有一个清晰的思路。
    
    </summary>
    
      <category term="Android 其它" scheme="http://yoursite.com/categories/Android-%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="Android演化历史" scheme="http://yoursite.com/tags/Android%E6%BC%94%E5%8C%96%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>RecycleView探究（一）：添加头尾布局</title>
    <link href="http://yoursite.com/2018/05/20/RecycleView%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%A4%B4%E5%B0%BE%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/05/20/RecycleView探究（一）：添加头尾布局/</id>
    <published>2018-05-20T13:27:13.000Z</published>
    <updated>2019-02-17T02:03:35.633Z</updated>
    
    <content type="html"><![CDATA[<p>笔者使用RecycleView也有一段时间了，每次遇到需要为RecycleView添加头尾布局的时候，都会是一阵头疼。之前我的做法是直接给依赖的实体集合添加头尾类型的Item Data。打脸的说，这是在赶需求的一种无赖做法。得益于最近项目不是很紧张，所以抽个周末的时间好好研究一下这一块的知识。<a id="more"></a><br>言归正传，本篇文章我要实现的效果是<span style="border-bottom:1px dashed black;">简洁高效地为RecycleView无限增加头尾布局。<span></span></span></p><h3 id="具体思路如下"><a href="#具体思路如下" class="headerlink" title="具体思路如下"></a>具体思路如下</h3><p>1、新建一个<code>HeaderFooterWrapAdapter</code>装饰类，它继承于RecycleView.Adapter，负责拓展普通RecycleView.Adapter对象（被装饰对象）的功能。<br>2、在<code>onCreateViewHolder</code>、<code>onBindViewHolder</code>、<code>getItemViewType</code>、<code>getItemCount</code>这几个方法区分有无头尾布局。如果没有头尾布局，一律按照被装饰对象的逻辑处理。<br>3、在<code>onAttachedToRecyclerView</code>方法内，做好GridView的适配。</p><h3 id="下面我们就把以上的思路转化成可爱的代码吧。"><a href="#下面我们就把以上的思路转化成可爱的代码吧。" class="headerlink" title="下面我们就把以上的思路转化成可爱的代码吧。"></a>下面我们就把以上的思路转化成可爱的代码吧。</h3><p><strong>一、我们应该让HeaderFooterWrapAdapter继承自RecycleView.Adapter,并且定义好需要的成员对象。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HeaderFooterWrapAdapter extends RecyclerView.Adapter &#123;</span><br><span class="line">RecyclerView.Adapter adapter;//被装饰对象</span><br><span class="line">private List&lt;View&gt; headerViews = new ArrayList&lt;&gt;();</span><br><span class="line">private List&lt;View&gt; footerViews = new ArrayList&lt;&gt;();</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 二、重写RecyclerView.Adapter中几个重要的方法。 </strong><br>1、判断item个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int getItemCount() &#123;</span><br><span class="line">if (headerViews.size() != 0 &amp;&amp; footerViews.size() != 0)//同时加了头部和尾部</span><br><span class="line">&#123;</span><br><span class="line">return adapter.getItemCount() + headerViews.size() + footerViews.size();</span><br><span class="line">&#125; else if (headerViews.size() != 0) &#123; //只有头部</span><br><span class="line">return adapter.getItemCount() + headerViews.size();</span><br><span class="line">&#125; else if (footerViews.size() != 0) //只有尾部</span><br><span class="line">&#123;</span><br><span class="line">return adapter.getItemCount() + footerViews.size();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return adapter.getItemCount();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、区分Item类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int getItemViewType(int position) &#123;</span><br><span class="line">if (headerViews.size() != 0) &#123;</span><br><span class="line">if (position &gt;= 0 &amp;&amp; position &lt; headerViews.size()) &#123;</span><br><span class="line">return headerViews.get(position).hashCode();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (footerViews.size() != 0) &#123;</span><br><span class="line">int i = position - headerViews.size() - adapter.getItemCount();</span><br><span class="line">if (i &gt;= 0)</span><br><span class="line">return footerViews.get(i).hashCode();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、创建Item。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;</span><br><span class="line">for (View headerView : headerViews) &#123;</span><br><span class="line">if (headerView.hashCode() == viewType) &#123;</span><br><span class="line">return new HeaderViewHolder(headerView);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (View footerview : footerViews) &#123;</span><br><span class="line">if (footerview.hashCode() == viewType) &#123;</span><br><span class="line">return new FooterViewHolder(footerview);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return adapter.onCreateViewHolder(parent, viewType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、绑定数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) &#123;</span><br><span class="line">if (headerViews.size() != 0 &amp;&amp; footerViews.size() != 0)//同时加了头部和尾部</span><br><span class="line">&#123;</span><br><span class="line">if (position &gt;= headerViews.size() &amp;&amp; position &lt; headerViews.size() + adapter.getItemCount()) &#123;</span><br><span class="line">adapter.onBindViewHolder(holder, position - headerViews.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (headerViews.size() != 0) &#123; //只有头部</span><br><span class="line">if (position &gt;= headerViews.size()) &#123;</span><br><span class="line">adapter.onBindViewHolder(holder, position - headerViews.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (footerViews.size() != 0) //只有尾部</span><br><span class="line">&#123;</span><br><span class="line">if (position &gt;= 0 &amp;&amp; position &lt; adapter.getItemCount()) &#123;</span><br><span class="line">adapter.onBindViewHolder(holder, position);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">adapter.onBindViewHolder(holder, position);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 三、接下来适配GridView，这里主要是通过GridLayoutManager的<code>setSpanSizeLookup</code>方法动态处理头尾布局。 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onAttachedToRecyclerView(@NonNull RecyclerView recyclerView) &#123;</span><br><span class="line">super.onAttachedToRecyclerView(recyclerView);</span><br><span class="line">final RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();</span><br><span class="line">if (layoutManager instanceof GridLayoutManager) &#123;</span><br><span class="line">((GridLayoutManager) layoutManager).setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123;</span><br><span class="line">@Override</span><br><span class="line">public int getSpanSize(int position) &#123;</span><br><span class="line">if (headerViews.size() != 0 &amp;&amp; footerViews.size() != 0) &#123;</span><br><span class="line">if (position &gt;= 0 &amp;&amp; position &lt; headerViews.size()) &#123;</span><br><span class="line">return ((GridLayoutManager) layoutManager).getSpanCount();</span><br><span class="line">&#125; else if (position &gt;= getItemCount() - footerViews.size() &amp;&amp; position &lt; getItemCount()) &#123;</span><br><span class="line">return ((GridLayoutManager) layoutManager).getSpanCount();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (headerViews.size() != 0) &#123;</span><br><span class="line">if (position &gt;= 0 &amp;&amp; position &lt; headerViews.size()) &#123;</span><br><span class="line">return ((GridLayoutManager) layoutManager).getSpanCount();</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125; else if (footerViews.size() != 0) &#123;</span><br><span class="line">if (position &gt;= getItemCount() - footerViews.size() &amp;&amp; position &lt; getItemCount()) &#123;</span><br><span class="line">return ((GridLayoutManager) layoutManager).getSpanCount();</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 四、定义添加头部和尾部布局的公开方法。 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//添加头布局</span><br><span class="line">public void addHeaderView(View headerView) &#123;</span><br><span class="line">this.headerViews.add(headerView);</span><br><span class="line">notifyItemInserted(headerViews.size() - 1);</span><br><span class="line">&#125;</span><br><span class="line">//添加尾布局</span><br><span class="line">public void addFooterView(View footerView) &#123;</span><br><span class="line">this.footerViews.add(footerView);</span><br><span class="line">notifyItemInserted(headerViews.size() + adapter.getItemCount() + footerViews.size() - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了，以上就是为RecycleView添加头尾布局的核心代码。调用方式也很简单，伪代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyAdapter myAdapter=....;</span><br><span class="line">....</span><br><span class="line">HeaderFooterWrapAdapter headerFooterWrapAdapter=new HeaderFooterWrapAdapter(myAdapter);</span><br><span class="line">headerFooterWrapAdapter.addFooterView(footerView01);</span><br><span class="line">headerFooterWrapAdapter.addFooterView(footerView02);</span><br><span class="line">headerFooterWrapAdapter.addFooterView(footerView03);</span><br><span class="line">headerFooterWrapAdapter.addHeaderView(headerView01);</span><br><span class="line">headerFooterWrapAdapter.addHeaderView(headerView02);</span><br><span class="line">headerFooterWrapAdapter.addHeaderView(headerView03);</span><br><span class="line">.......</span><br></pre></td></tr></table></figure></p><p>这里有一点需要注意就是Inflate创建headerView或者footerView时，parent需要传入recyclerView对象才能时布局的顶层属性起效果,例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View footerView = LayoutInflater.from(this).inflate(R.layout.footerview, rcv, false);</span><br></pre></td></tr></table></figure></p><p>关于inflate的使用技巧，可以参考一下<a href="https://www.zhihu.com/question/42782662" target="_blank" rel="noopener">这篇文章</a>。最后，再贴一张实现的效果图片吧～<br><img src="/2018/05/20/RecycleView探究（一）：添加头尾布局/ezgif-4-059e8e8823.gif"></p><hr><p><strong>参考资料</strong><br><a href="https://juejin.im/entry/5975a4ac5188256e2c58e1f4" target="_blank" rel="noopener">学会自己给RecyclerView添加Header、Footer和加载更多回调</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者使用RecycleView也有一段时间了，每次遇到需要为RecycleView添加头尾布局的时候，都会是一阵头疼。之前我的做法是直接给依赖的实体集合添加头尾类型的Item Data。打脸的说，这是在赶需求的一种无赖做法。得益于最近项目不是很紧张，所以抽个周末的时间好好研究一下这一块的知识。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="RecycleView" scheme="http://yoursite.com/tags/RecycleView/"/>
    
  </entry>
  
  <entry>
    <title>PopupWindow使用教程</title>
    <link href="http://yoursite.com/2018/04/29/PopupWindow%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/04/29/PopupWindow使用教程/</id>
    <published>2018-04-29T01:43:34.000Z</published>
    <updated>2019-12-16T14:45:53.361Z</updated>
    
    <content type="html"><![CDATA[<p>PopupWindow是<code>android.widget</code>中一个弹框控件，与普通dialog相比，它的优势在于可以任意改变其在界面中的位置。本篇我们就来好好研究一下它的用法吧。<br><a id="more"></a></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>PopupWindow有两种创建方式：<br>1、通过视图创建，这是最常用的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PopupWindow ()// 创建一个空的PopupWindow</span><br><span class="line"></span><br><span class="line">PopupWindow (View contentView)</span><br><span class="line"></span><br><span class="line">PopupWindow (int width, int height)</span><br><span class="line"></span><br><span class="line">PopupWindow (View contentView, // PopupWindow的内容View, 相当于setContentView</span><br><span class="line">int width, // 宽, 相当于setwidth()</span><br><span class="line">int height,// 高, 相当于setHeight</span><br><span class="line">boolean focusable)//是否可获取焦点, 相当于setFocusable()</span><br></pre></td></tr></table></figure></p><p>2、通过上下文创建，一般不使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PopupWindow (Context context)</span><br><span class="line"></span><br><span class="line">PopupWindow (Context context, </span><br><span class="line">AttributeSet attrs)</span><br><span class="line"></span><br><span class="line">PopupWindow (Context context, </span><br><span class="line">AttributeSet attrs, </span><br><span class="line">int defStyleAttr)</span><br><span class="line"></span><br><span class="line">PopupWindow (Context context, </span><br><span class="line">AttributeSet attrs, </span><br><span class="line">int defStyleAttr, </span><br><span class="line">int defStyleRes)</span><br></pre></td></tr></table></figure></p><p>创建PopuWindow必要的三个条件:<br>void setHeight (int height) // 因为PopupWindow没有默认布局所以必须指定宽高<br>void setWidth (int width)<br>void setContentView (View contentView) // 需要显示的内容</p><blockquote><p><strong>注意</strong><br>PopupWindow指定宽高时用LayoutParams.WRAP_CONTENT包裹布局， 这时并不总是布局多大就显示多大，估计是BUG吧。所以遇到这种情况，具体的PopupWindow大小我们还是需要手动计算。</p></blockquote><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><p>显示PopupWindow可以分为两种方式:</p><h4 id="1、附着某个控件showAsDropDown。"><a href="#1、附着某个控件showAsDropDown。" class="headerlink" title="1、附着某个控件showAsDropDown。"></a>1、附着某个控件showAsDropDown。</h4><p>默认是PopupWindow的左上角对其控件的左下角,或者设置<code>Gravity.RIGHT</code>, PopupWindow的右上角对齐控件的右下角。不存在Gravity.TOP或Gravity.BOTTOM效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void showAsDropDown (View anchor) //弹窗显示在anchor控件左下方</span><br><span class="line"></span><br><span class="line">void showAsDropDown (View anchor, int xoff, int yoff)//以控件左下角为原点的偏移坐标</span><br><span class="line"></span><br><span class="line">void showAsDropDown (View anchor,int xoff,int yoff,int gravity) //弹窗显示在控件的左下方还是右下方, 参数Gravity.RIGHT/Gravity.LEFT. 默认是左下方</span><br></pre></td></tr></table></figure></p><h4 id="2、设置屏幕坐标showAtLocation。"><a href="#2、设置屏幕坐标showAtLocation。" class="headerlink" title="2、设置屏幕坐标showAtLocation。"></a>2、设置屏幕坐标showAtLocation。</h4><p>当前窗口的任意位置(setClippingEnabled设置为ture时，不包括状态栏。)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void showAtLocation (</span><br><span class="line">View parent, //只要是屏幕上任意控件对象即可</span><br><span class="line">int gravity, //屏幕位置</span><br><span class="line">int x,       //偏移坐标</span><br><span class="line">int y)</span><br></pre></td></tr></table></figure></p><p>parent:该属性只要是当前任意控件对象即可(View和ViewGroup都行), 官方文档介绍该对象参数主要是为了得到该对象的<code>getWindowToken()</code>方法。<br>需要注意的是多次调用show方法只会执行第一句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mPopupWindow.showAtLocation(popupwindow, Gravity.TOP, 100, 0); // 只有该行生效</span><br><span class="line">mPopupWindow.showAtLocation(popupwindow, Gravity.LEFT, 100, 0);</span><br><span class="line">mPopupWindow.showAtLocation(popupwindow, Gravity.RIGHT, 100, 0);</span><br><span class="line">mPopupWindow.showAtLocation(popupwindow, Gravity.BOTTOM, 100, 0);</span><br></pre></td></tr></table></figure></p><h4 id="隐藏PopupWindow"><a href="#隐藏PopupWindow" class="headerlink" title="隐藏PopupWindow"></a>隐藏PopupWindow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void dismiss ()</span><br></pre></td></tr></table></figure><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><h4 id="外部被点击取消"><a href="#外部被点击取消" class="headerlink" title="外部被点击取消"></a>外部被点击取消</h4><p>如果为true点击PopupWindow外部区域可以取消PopupWindow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setOutsideTouchable (boolean touchable) // 设置外部是否可被点击</span><br></pre></td></tr></table></figure></p><p>但是在android6.0以下还是无法点击外部取消Popupwindow. 可以通过设置背景来解决这个Bug。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPopupWindow.setBackgroundDrawable(new BitmapDrawable());</span><br></pre></td></tr></table></figure></p><h4 id="解决NavigationBar重叠"><a href="#解决NavigationBar重叠" class="headerlink" title="解决NavigationBar重叠"></a>解决NavigationBar重叠</h4><p>这是Android5.0(API22)后添加的方法, 默认为true，为true时将不会与导航栏重叠。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setAttachedInDecor (boolean enabled)</span><br></pre></td></tr></table></figure></p><h4 id="可获取焦点"><a href="#可获取焦点" class="headerlink" title="可获取焦点"></a>可获取焦点</h4><p>一般控件都不需要焦点，但是输入框EditText需要先获取焦点才能输入。 最重要的是当PopupWindow可获取焦点时按下手机返回键将不会销毁当前Activity而是关闭当前PopupWindow。所以我们一般还是设置为true， 更加符合用户操作逻辑。该方法为true时同时拥有setOutsideTouchable(true)的作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setFocusable (boolean focusable)</span><br></pre></td></tr></table></figure></p><h4 id="遮盖附着View"><a href="#遮盖附着View" class="headerlink" title="遮盖附着View"></a>遮盖附着View</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setOverlapAnchor (boolean overlapAnchor)</span><br></pre></td></tr></table></figure><p>PopupWindow对齐方式从View anchor的左下角变成了左上角了。</p><h4 id="窗口裁剪"><a href="#窗口裁剪" class="headerlink" title="窗口裁剪"></a>窗口裁剪</h4><p>PopupWindow默认是不会超出屏幕边界的. 但是如果该方法为false时会采用精准位置, 能超出屏幕范围.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setClippingEnabled (boolean enabled)</span><br></pre></td></tr></table></figure></p><h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><h4 id="设置动画"><a href="#设置动画" class="headerlink" title="设置动画"></a>设置动画</h4><p>可以设置popupWindow的显示和隐藏动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setAnimationStyle (int animationStyle)</span><br></pre></td></tr></table></figure></p><p>可以看到方法是传入一个Style的样式id，示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;popupwindow_anim_style&quot;&gt;</span><br><span class="line">&lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/dialog_bottom_enter&lt;/item&gt;</span><br><span class="line">&lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/dialog_bottom_exit&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>分别由两个属性组成. 两个属性各代表一个anim动画文件.</p><h4 id="进入和退出动画"><a href="#进入和退出动画" class="headerlink" title="进入和退出动画"></a>进入和退出动画</h4><p>这是在Android6.0(API 23)后加入的方法. 配合Material Design的转场动画使用.<br>进入动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setEnterTransition (Transition enterTransition)</span><br></pre></td></tr></table></figure></p><p>退出动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setExitTransition (Transition exitTransition)</span><br></pre></td></tr></table></figure></p><h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>针对PopupWindow中包含EditText控件.</p><h4 id="输入模式-1"><a href="#输入模式-1" class="headerlink" title="输入模式"></a>输入模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setInputMethodMode (int mode)</span><br></pre></td></tr></table></figure><p>支持三种模式：<br>1、INPUT_METHOD_FROM_FOCUSABLE 根据可否获取焦点判断是否可输入<br>2、INPUT_METHOD_NEEDED 允许输入<br>3、INPUT_METHOD_NOT_NEEDED 不允许输入</p><h4 id="软键盘模式"><a href="#软键盘模式" class="headerlink" title="软键盘模式"></a>软键盘模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setSoftInputMode (int mode) // mode为WindowManager.LayoutParams的softInputMode常量</span><br></pre></td></tr></table></figure><p>softInputMode包含九种取值, 可组合使用,分为两类:<br>显示状态模式</p><ol><li>SOFT_INPUT_STATE_UNSPECIFIED 默认模式</li><li>SOFT_INPUT_STATE_HIDDEN</li><li>SOFT_INPUT_STATE_ALWAYS_HIDDEN 总是隐藏</li><li>SOFT_INPUT_STATE_UNCHANGED</li><li>SOFT_INPUT_STATE_VISIBLE</li><li>SOFT_INPUT_STATE_ALWAYS_VISIBLE 自动弹出软键盘</li></ol><p>调整模式</p><ol><li>SOFT_INPUT_ADJUST_UNSPECIFIED 默认模式</li><li>SOFT_INPUT_ADJUST_RESIZE 软键盘弹出后PopupWindow会自动调整坐标,不被遮挡</li><li>SOFT_INPUT_ADJUST_PAN</li></ol><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><h4 id="隐藏事件监听"><a href="#隐藏事件监听" class="headerlink" title="隐藏事件监听"></a>隐藏事件监听</h4><p>即PopupWindow执行<code>dismiss()</code>后回调的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setOnDismissListener (PopupWindow.OnDismissListener onDismissListener)</span><br></pre></td></tr></table></figure></p><h4 id="触摸事件拦截"><a href="#触摸事件拦截" class="headerlink" title="触摸事件拦截"></a>触摸事件拦截</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setTouchInterceptor (View.OnTouchListener l)</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>以下的更新PopupWindow都必须在PopupWindow处于以及被显示的状态下才行，且PopupWindow的宽高设置都必须大于等于0， 如果想忽略PopupWindow的宽高设置就设为-1。</p><h4 id="更新状态"><a href="#更新状态" class="headerlink" title="更新状态"></a>更新状态</h4><p>该方法不能更新PopupWindow的宽高, 只能更新PopupWindow的状态. 例如更新Focusable和OutsideTouchable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void update ()</span><br></pre></td></tr></table></figure></p><h4 id="更新尺寸"><a href="#更新尺寸" class="headerlink" title="更新尺寸"></a>更新尺寸</h4><p>上面说过update()不能更新PopupWindow的宽高, 但是提供更新宽高的update方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void update (int width, // 更新PopupWindow的宽高</span><br><span class="line">int height)</span><br></pre></td></tr></table></figure></p><h4 id="更新显示位置"><a href="#更新显示位置" class="headerlink" title="更新显示位置"></a>更新显示位置</h4><p>该方法是相当于重新showAsDropDown, 所以这是<strong>相对于控件</strong>的位置更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void update (View anchor, // 更新显示控件的位置</span><br><span class="line">int width, </span><br><span class="line">int height)</span><br><span class="line"></span><br><span class="line">void update (View anchor, </span><br><span class="line">int xoff, // 相对于控件的偏移值</span><br><span class="line">int yoff, </span><br><span class="line">int width, </span><br><span class="line">int height)</span><br></pre></td></tr></table></figure></p><h4 id="相对位置更新"><a href="#相对位置更新" class="headerlink" title="相对位置更新"></a>相对位置更新</h4><p>相对于当前的位置进行偏移， 不同的显示位置对于的相对原点也不同。<br>showAsDropDown的相对原点是整个屏幕左上角, 包括状态栏。所以由于包括状态栏所以坐标偏移的时候一定要y轴偏移大于60超出状态栏的高度。 否则因为遮挡状态栏导致PopupWindow无法显示.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPopupWindow.update(50, 60, -1,-1); // x轴偏移50</span><br></pre></td></tr></table></figure></p><p>showAtLocation的相对原点是<strong>自身位置</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void update (int x, // 坐标偏移</span><br><span class="line">int y, </span><br><span class="line">int width, // PopupWindow宽高</span><br><span class="line">int height)</span><br><span class="line"></span><br><span class="line">void update (int x, </span><br><span class="line">int y, </span><br><span class="line">int width, </span><br><span class="line">int height, </span><br><span class="line">boolean force) // 可获取焦点</span><br></pre></td></tr></table></figure></p><h2 id="背景变灰"><a href="#背景变灰" class="headerlink" title="背景变灰"></a>背景变灰</h2><p>当我们弹出PopupWindow时，有时希望背景能够变成灰色，那我们可以通过以下方式实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 设置添加屏幕的背景透明度</span><br><span class="line">* </span><br><span class="line">* @param bgAlpha 屏幕透明度0.0-1.0 1表示完全不透明</span><br><span class="line">*            </span><br><span class="line">*/</span><br><span class="line">public void setBackgroundAlpha(float bgAlpha) &#123;</span><br><span class="line">WindowManager.LayoutParams lp = ((Activity) mContext).getWindow().getAttributes();</span><br><span class="line">lp.alpha = bgAlpha;</span><br><span class="line">((Activity) mContext).getWindow().setAttributes(lp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="开发过程中遇到的坑"><a href="#开发过程中遇到的坑" class="headerlink" title="开发过程中遇到的坑"></a>开发过程中遇到的坑</h2><p>笔者之前使用PopupWindow做了一个全局的转菊花功能，期间将 PopupWindow 成员变量定义成静态变量，每次 show 之前判断该变量是否为 null ，为 null 时赋值，最后导致了有时菊花无法弹出的问题。所以，如果需要做菊花功能，建议每个界面都创建一次 PopuWindow 实例。当然使用 PopuWindow 做菊花并不常见，一般的做法是使用 DialogFragment 完成。</p><hr><p><strong>参考资料</strong><br><a href="https://juejin.im/post/58ed82c3a22b9d0063469e98" target="_blank" rel="noopener">PopupWindow最全使用说明</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PopupWindow是&lt;code&gt;android.widget&lt;/code&gt;中一个弹框控件，与普通dialog相比，它的优势在于可以任意改变其在界面中的位置。本篇我们就来好好研究一下它的用法吧。&lt;br&gt;
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="PopupWindow" scheme="http://yoursite.com/tags/PopupWindow/"/>
    
  </entry>
  
  <entry>
    <title>Java枚举用法总结</title>
    <link href="http://yoursite.com/2018/03/24/Java%E6%9E%9A%E4%B8%BE%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/24/Java枚举用法总结/</id>
    <published>2018-03-24T12:35:09.000Z</published>
    <updated>2019-02-17T02:03:35.633Z</updated>
    
    <content type="html"><![CDATA[<p>枚举是JDK1.5引入的新类型，可以说是一个小功能，但是它却给我们的程序开发带来了极大的便捷，本文就对它的用法做一个小结。<a id="more"></a></p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>在JDK 1.5之前，我们定义常量都是public final static ……，这种定义方式有一个很大的弊端就是代码紊乱，需要大量的注释。有了枚举类型，事情就好办了。比如我们要定义一组颜色常量，可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Color&#123;</span><br><span class="line">WHITE,BLACK,RED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是很清晰了呢，除了会使代码结构清晰之外，枚举还提供了许多便捷的操作……</p><h4 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enum Signal &#123;  </span><br><span class="line">GREEN, YELLOW, RED  </span><br><span class="line">&#125;  </span><br><span class="line">public class TrafficLight &#123;  </span><br><span class="line">Signal color = Signal.RED;  </span><br><span class="line">public void change() &#123;  </span><br><span class="line">switch (color) &#123;  </span><br><span class="line">case RED:  </span><br><span class="line">color = Signal.GREEN;  </span><br><span class="line">break;  </span><br><span class="line">case YELLOW:  </span><br><span class="line">color = Signal.RED;  </span><br><span class="line">break;  </span><br><span class="line">case GREEN:  </span><br><span class="line">color = Signal.YELLOW;  </span><br><span class="line">break;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向枚举中添加新方法"><a href="#向枚举中添加新方法" class="headerlink" title="向枚举中添加新方法"></a>向枚举中添加新方法</h4><p>枚举中可以自定义方法，但是必须保证先定义枚举的实例，并且在最后一个实例后面用分号结尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public enum Color &#123;  </span><br><span class="line">RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  </span><br><span class="line">// 成员变量  </span><br><span class="line">private String name;  </span><br><span class="line">private int index;  </span><br><span class="line">// 构造方法  </span><br><span class="line">private Color(String name, int index) &#123;  </span><br><span class="line">this.name = name;  </span><br><span class="line">this.index = index;  </span><br><span class="line">&#125;  </span><br><span class="line">// 普通方法  </span><br><span class="line">public static String getName(int index) &#123;  </span><br><span class="line">for (Color c : Color.values()) &#123;  </span><br><span class="line">if (c.getIndex() == index) &#123;  </span><br><span class="line">return c.name;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">return null;  </span><br><span class="line">&#125;  </span><br><span class="line">// get set 方法  </span><br><span class="line">public String getName() &#123;  </span><br><span class="line">return name;  </span><br><span class="line">&#125;  </span><br><span class="line">public void setName(String name) &#123;  </span><br><span class="line">this.name = name;  </span><br><span class="line">&#125;  </span><br><span class="line">public int getIndex() &#123;  </span><br><span class="line">return index;  </span><br><span class="line">&#125;  </span><br><span class="line">public void setIndex(int index) &#123;  </span><br><span class="line">this.index = index;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>补充</strong><br>枚举有两个默认的方法，<code>name()</code>、<code>ordinal()</code>方法。前者可以理解为是枚举实例的名称。后者理解为枚举的编号，从0递增。</p></blockquote><h4 id="覆盖枚举的方法"><a href="#覆盖枚举的方法" class="headerlink" title="覆盖枚举的方法"></a>覆盖枚举的方法</h4><p>下面给出覆盖<code>toString()</code>方法的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public enum Color &#123;  </span><br><span class="line">RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  </span><br><span class="line">// 成员变量  </span><br><span class="line">private String name;  </span><br><span class="line">private int index;  </span><br><span class="line">// 构造方法  </span><br><span class="line">private Color(String name, int index) &#123;  </span><br><span class="line">this.name = name;  </span><br><span class="line">this.index = index;  </span><br><span class="line">&#125;  </span><br><span class="line">//覆盖方法  </span><br><span class="line">@Override </span><br><span class="line">public String toString() &#123;  </span><br><span class="line">return this.index+&quot;_&quot;+this.name;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p>所有枚举都自动继承自java.lang.Enum类。由于Java不支持多继承，所以我们不能将枚举类继承其它的类，但是枚举类可以实现多个接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface Behaviour &#123;  </span><br><span class="line">void print();  </span><br><span class="line">String getInfo();  </span><br><span class="line">&#125;  </span><br><span class="line">public enum Color implements Behaviour&#123;  </span><br><span class="line">RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);  </span><br><span class="line">// 成员变量  </span><br><span class="line">private String name;  </span><br><span class="line">private int index;  </span><br><span class="line">// 构造方法  </span><br><span class="line">private Color(String name, int index) &#123;  </span><br><span class="line">this.name = name;  </span><br><span class="line">this.index = index;  </span><br><span class="line">&#125;  </span><br><span class="line">//接口方法  </span><br><span class="line">@Override  </span><br><span class="line">public String getInfo() &#123;  </span><br><span class="line">return this.name;  </span><br><span class="line">&#125;  </span><br><span class="line">//接口方法  </span><br><span class="line">@Override  </span><br><span class="line">public void print() &#123;  </span><br><span class="line">System.out.println(this.index+&quot;:&quot;+this.name);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用接口组织枚举"><a href="#使用接口组织枚举" class="headerlink" title="使用接口组织枚举"></a>使用接口组织枚举</h4><p>有时候我们需要在一个文件中统一管理常量话，可以使用接口组织枚举。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Food &#123;  </span><br><span class="line">enum Coffee implements Food&#123;  </span><br><span class="line">BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO  </span><br><span class="line">&#125;  </span><br><span class="line">enum Dessert implements Food&#123;  </span><br><span class="line">FRUIT, CAKE, GELATO  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考资料</strong><br><a href="https://blog.csdn.net/qq_27093465/article/details/52180865" target="_blank" rel="noopener">Java 枚举(enum) 详解7种常见的用法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;枚举是JDK1.5引入的新类型，可以说是一个小功能，但是它却给我们的程序开发带来了极大的便捷，本文就对它的用法做一个小结。
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="枚举" scheme="http://yoursite.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池</title>
    <link href="http://yoursite.com/2018/03/13/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/03/13/Java线程池/</id>
    <published>2018-03-13T14:44:03.000Z</published>
    <updated>2019-02-17T02:03:35.631Z</updated>
    
    <content type="html"><![CDATA[<p>在面向对象编程中，创建和销毁对象是很耗时间和资源的，因此，在多线程编程过程中如果能减少线程的创建和销毁操作，那么对于程序的性能将得到很大的提高。Java线程池的出现，解决了这个问题。不仅如此，线程池还可以控制线程的创建数量，避免内存消耗过多。<a id="more"></a><br>学习线程池，需要用到以下几个关键类。<br>1、Executor<br>2、Executors<br>3、ExecutorSevice<br>4、ThreadPoolExecutor<br>在分别介绍它们之前，让我们先捋清一下它们之间的关系。<br><img src="/2018/03/13/Java线程池/Jietu20180512-192205@2x.jpg"><br>图中的AbstractExecutorService类可以不用理会，我们不讲它。另外，Excutors类不好在<a href="http://www.cnblogs.com/xrq730/p/5527115.html" target="_blank" rel="noopener">UML类图</a>中将其涵盖进去，等会我们再介绍。</p><h1 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h1><p>查看Executor的API，有这么一段话：</p><blockquote><p>The Executor implementations provided in this package implement ExecutorService, which is a more extensive interface. The ThreadPoolExecutor class provides an extensible thread pool implementation. The Executors class provides convenient factory methods for these Executors.</p></blockquote><p>大概意思是，ExecutorService接口在Executor接口的基础上又拓展了一些功能；而ThreadPoolExecutor类提供了一个可拓展的线程池实现；Executors类是一个工厂类，它为Executor类的实现提供了便捷的通道。<br>这里我们注意到了之前提到的<code>Executors</code>类，它是一个工厂方法，用来产生Executor对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Executor excutor = Executors.newFixedThreadPool(10);  </span><br><span class="line">excutor.execute(new Runnable() &#123;  </span><br><span class="line">public void run() &#123;  </span><br><span class="line">System.out.println(&quot;Asynchronous task&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>注意以上是一个异步任务。同时，除了可以使用<code>newFixedThreadPool</code>创建Executor对象之外还可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Executors.newSingleThreadExecutor();  </span><br><span class="line">Executors.newScheduledThreadPool(size);</span><br></pre></td></tr></table></figure></p><p>生产Executor对象，具体用法之后会介绍。</p><h1 id="ExecutorSevice"><a href="#ExecutorSevice" class="headerlink" title="ExecutorSevice"></a>ExecutorSevice</h1><p>如上所提，ExecutorSevice实际上只是比Executor多了一些方法而已，它同样可以通过<code>Executors</code>提供的工厂方法创造出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorSevice executorService = Executors.newFixedThreadPool(10);</span><br></pre></td></tr></table></figure></p><p>除了<code>execute()</code>，ExecutorSevice提供了允许返回任务执行结果的<code>submit()</code>，返回结果的方式有两种：<br>1、传入Runnable对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future=executor.submit(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;Asynchronous task&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>2、传入Callable对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future = executor.submit(new Callable&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public String call() throws Exception &#123;</span><br><span class="line">System.out.println(&quot;Asynchronous task&quot;);</span><br><span class="line">return &quot;result&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个两种方式都可以通过<code>future.get（）</code>获得返回的结果，并且<code>future.get（）</code>是一个阻塞方法。不同的是，Runnable方式的返回值始终为null，Callable方式的返回值将取决于用户的设定。<br>特别地，ExecutorSevice还提供了可以处理Callable集合的方法invokeAny和invokeAll,具体用法可以参考<a href="https://blog.csdn.net/suifeng3051/article/details/49443835" target="_blank" rel="noopener">这一篇文章</a>。<br>将<code>invokeAll</code>运用在需要并行运行的场景，可以减少比较多的方法执行时间。比如：方法A和方法B分别都执行了一些耗时操作，而我们最后的值依赖于这两个方法的执行结果。那么第一种方法是让A、B串行执行，第二种方法是将A、B逻辑分别设置为callable对象，之后通过invokeAll并行执行它俩，实验结果是第二种方法优于第一种方法的实现。</p><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>ThreadPoolExecutor支持通过调整构造参数来配置不同的处理策略，下面主要介绍一下常用的策略配置方法以及应用场景。</p><h4 id="ThreadPoolExecutor-的处理逻辑"><a href="#ThreadPoolExecutor-的处理逻辑" class="headerlink" title="ThreadPoolExecutor 的处理逻辑"></a>ThreadPoolExecutor 的处理逻辑</h4><p>首先看一下 ThreadPoolExecutor 构造函数的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,  //线程池核心线程数量</span><br><span class="line">int maximumPoolSize,                  //线程池最大线程数量</span><br><span class="line">long keepAliveTime,                   //线程KeepAlive时间，当线程池数量超过核心线程数量以后，idle时间超过这个值的线程会被终止</span><br><span class="line">TimeUnit unit,                        //线程KeepAlive时间单位</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,    //任务队列</span><br><span class="line">ThreadFactory threadFactory,          //创建线程的工厂对象</span><br><span class="line">RejectedExecutionHandler handler)     //任务被拒绝后调用的handler</span><br></pre></td></tr></table></figure></p><p>ThreadPoolExecutor 对线程池和队列的使用方式如下：<br>1、从线程池中获取可用线程执行任务，如果没有可用线程则使用ThreadFactory创建新的线程，直到线程数达到corePoolSize限制；<br>2、线程池线程数达到corePoolSize以后，新的任务将被放入队列，直到队列不能再容纳更多的任务；<br>3、当队列不能再容纳更多的任务以后，会创建新的线程，直到线程数达到maxinumPoolSize限制；<br>4、线程数达到maxinumPoolSize限制以后新任务会被拒绝执行，调用 RejectedExecutionHandler 进行处理。</p><h4 id="三种常用的-ThreadPoolExecutor"><a href="#三种常用的-ThreadPoolExecutor" class="headerlink" title="三种常用的 ThreadPoolExecutor"></a>三种常用的 ThreadPoolExecutor</h4><p>Executors 是提供了一组工厂方法用于创建常用的 ExecutorService ，分别是 FixedThreadPool，CachedThreadPool 以及 SingleThreadExecutor。这三种ThreadPoolExecutor都是调用 ThreadPoolExecutor 构造函数进行创建，区别在于参数不同。<br><strong>1、FixedThreadPool - 线程池大小固定，任务队列无界。</strong><br>下面是 Executors 类 newFixedThreadPool 方法的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">0L, TimeUnit.MILLISECONDS,</span><br><span class="line">new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到 corePoolSize 和 maximumPoolSize 设置成了相同的值，此时不存在线程数量大于核心线程数量的情况，所以KeepAlive时间设置不会生效。任务队列使用的是不限制大小的 LinkedBlockingQueue ，由于是无界队列所以容纳的任务数量没有上限。<br>因此，FixedThreadPool的行为如下：<br>1、从线程池中获取可用线程执行任务，如果没有可用线程则使用ThreadFactory创建新的线程，直到线程数达到nThreads；<br>2、线程池线程数达到nThreads以后，新的任务将被放入队列。<br>FixedThreadPool的优点是能够保证所有的任务都被执行，永远不会拒绝新的任务；同时缺点是队列数量没有限制，在任务执行时间无限延长的这种极端情况下会造成内存问题。<br><strong>2、SingleThreadExecutor - 线程池大小固定为1，任务队列无界</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">return new FinalizableDelegatedExecutorService</span><br><span class="line">(new ThreadPoolExecutor(1, 1,</span><br><span class="line">0L, TimeUnit.MILLISECONDS,</span><br><span class="line">new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个工厂方法中使用无界LinkedBlockingQueue，并的将线程数设置成1。虽然是单线程处理，一旦线程因为处理异常等原因终止的时候，ThreadPoolExecutor会自动创建一个新的线程继续进行工作。<br>SingleThreadExecutor 适用于在逻辑上需要单线程处理任务的场景，同时无界的LinkedBlockingQueue保证新任务都能够放入队列，不会被拒绝；缺点和FixedThreadPool相同，当处理任务无限等待的时候会造成内存问题。<br><strong>3、CachedThreadPool - 线程池无限大（MAX INT），等待队列长度为1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">60L, TimeUnit.SECONDS,</span><br><span class="line">new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SynchronousQueue是一个只有1个元素的队列，入队的任务需要一直等待直到队列中的元素被移出。核心线程数是0，意味着所有任务会先入队列；最大线程数是Integer.MAX_VALUE，可以认为线程数量是没有限制的。KeepAlive时间被设置成60秒，意味着在没有任务的时候超过核心线程数的线程等待60秒以后退出。CachedThreadPool对任务的处理策略是提交的任务会立即分配一个线程进行执行，线程池中线程数量会随着任务数的变化自动扩张和缩减，在任务执行时间无限延长的极端情况下会创建过多的线程。</p><blockquote><p><strong>说明：</strong><br>实验证明，当超过核心线程数后，线程池的机制是尽量重用还在KeepAlive时间内的线程。</p></blockquote><hr><p><strong>参考资料</strong><br><a href="https://segmentfault.com/a/1190000008394155" target="_blank" rel="noopener">ThreadPoolExecutor策略配置以及应用场景</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面向对象编程中，创建和销毁对象是很耗时间和资源的，因此，在多线程编程过程中如果能减少线程的创建和销毁操作，那么对于程序的性能将得到很大的提高。Java线程池的出现，解决了这个问题。不仅如此，线程池还可以控制线程的创建数量，避免内存消耗过多。
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="并发编程" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android图片压缩方略</title>
    <link href="http://yoursite.com/2018/02/22/Android%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E6%96%B9%E7%95%A5/"/>
    <id>http://yoursite.com/2018/02/22/Android图片压缩方略/</id>
    <published>2018-02-22T02:50:42.000Z</published>
    <updated>2019-12-17T12:46:01.863Z</updated>
    
    <content type="html"><![CDATA[<p>我们通常采用多种方式结合的方法实现图片压缩需求，这些方式包括质量压缩、尺寸压缩。本章将分别介绍这两种方式，并且最后将结合这两种方式实现图片压缩的最优解决方案。<a id="more"></a></p><h1 id="质量压缩"><a href="#质量压缩" class="headerlink" title="质量压缩"></a>质量压缩</h1><p>设置bitmap options属性，降低图片的质量，但像素不会减少，options 属性的值为0-100，来实现压缩。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void compressImageToFile(Bitmap bmp,File file) &#123;</span><br><span class="line">// 0-100 100为不压缩</span><br><span class="line">int options = 100; </span><br><span class="line">ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">// 把压缩后的数据存放到baos中</span><br><span class="line">bmp.compress(Bitmap.CompressFormat.JPEG, options, baos);</span><br><span class="line">try &#123;  </span><br><span class="line">FileOutputStream fos = new FileOutputStream(file);  </span><br><span class="line">fos.write(baos.toByteArray());  </span><br><span class="line">fos.flush();  </span><br><span class="line">fos.close();  </span><br><span class="line">&#125; catch (Exception e) &#123;  </span><br><span class="line">e.printStackTrace();  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="尺寸压缩"><a href="#尺寸压缩" class="headerlink" title="尺寸压缩"></a>尺寸压缩</h1><p>通过缩放图片像素来减少图片所占内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void compressBitmapToFile(Bitmap bmp, File file)&#123;</span><br><span class="line">// 尺寸压缩倍数,值越大，图片尺寸越小</span><br><span class="line">int ratio = 2;</span><br><span class="line">// 压缩Bitmap到对应尺寸</span><br><span class="line">Bitmap result = Bitmap.createBitmap(bmp.getWidth() / ratio, bmp.getHeight() / ratio, Config.ARGB_8888);</span><br><span class="line">Canvas canvas = new Canvas(result);</span><br><span class="line">Rect rect = new Rect(0, 0, bmp.getWidth() / ratio, bmp.getHeight() / ratio);</span><br><span class="line">canvas.drawBitmap(bmp, null, rect, null);</span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">// 把压缩后的数据存放到baos中</span><br><span class="line">result.compress(Bitmap.CompressFormat.JPEG, 100 ,baos);</span><br><span class="line">try &#123;  </span><br><span class="line">FileOutputStream fos = new FileOutputStream(file);  </span><br><span class="line">fos.write(baos.toByteArray());  </span><br><span class="line">fos.flush();  </span><br><span class="line">fos.close();  </span><br><span class="line">&#125; catch (Exception e) &#123;  </span><br><span class="line">e.printStackTrace();  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设置图片采样率，减少图片像素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void compressBitmap(String filePath, File file)&#123;</span><br><span class="line">// 数值越高，图片像素越低</span><br><span class="line">int inSampleSize = 2;</span><br><span class="line">BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">//采样率</span><br><span class="line">options.inSampleSize = inSampleSize;</span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeFile(filePath, options);  </span><br><span class="line">ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">// 把压缩后的数据存放到baos中</span><br><span class="line">bitmap.compress(Bitmap.CompressFormat.JPEG, 100 ,baos);</span><br><span class="line">try &#123;  </span><br><span class="line">FileOutputStream fos = new FileOutputStream(file);  </span><br><span class="line">fos.write(baos.toByteArray());  </span><br><span class="line">fos.flush();  </span><br><span class="line">fos.close();  </span><br><span class="line">&#125; catch (Exception e) &#123;  </span><br><span class="line">e.printStackTrace();  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过Bitmap 的 Matrix 属性设置。（不失真）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 缩放的矩阵</span><br><span class="line">Matrix scaleMatrix = new Matrix();</span><br><span class="line">int width = originalBitmap.getWidth();</span><br><span class="line">int height = originalBitmap.getHeight();</span><br><span class="line">scaleMatrix.setScale(ratio, ratio, width / 2, heigith / 2);</span><br><span class="line">//实时变换的图片资源bitmap</span><br><span class="line">targetBitmap = Bitmap.createBitmap(originalBitmap, 0, 0,</span><br><span class="line">width, height, scaleMatrix, true);</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>小知识</strong><br>1、文件大小换算公式：<br>1Byte=8bit<br>1KB=1024Byte(字节)=8*1024bit<br>1MB=1024KB<br>1GB=1024MB<br>1TB=1024GB<br>2、图像占用内存空间的大小：分辨率 * 位深 ／ 8<br>分辨率：宽 * 高<br>位深度：指定图像中的每个像素可以使用的颜色信息数量。<br>每个像素使用的信息位数越多，可用的颜色就越多，颜色表现就更逼真。<br>例如：<br>一幅图像分辨率：1024*768,24位，则其大小计算如下：<br>大小 = 1024 * 768 * 24 / 8 = 2359296 byte = 2304 KB</p></blockquote><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>实际使用过程中，首先是将图片的尺寸压缩到一定大小，然后降低图片的质量到特定的内存要求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Bitmap obtainBitmap() &#123;</span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.imag);</span><br><span class="line">Bitmap bg = Bitmap.createBitmap(bitmap.getWidth() / 2, bitmap.getHeight() / 2, Bitmap.Config.ARGB_8888);</span><br><span class="line">Canvas canvas = new Canvas(bg);</span><br><span class="line">Rect rect = new Rect(0, 0, bitmap.getWidth() / 2, bitmap.getHeight() / 2);</span><br><span class="line">canvas.drawBitmap(bitmap, null, rect, null);</span><br><span class="line">ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</span><br><span class="line">int quality = 100;</span><br><span class="line">//直到图片的大小小于100kb</span><br><span class="line">do &#123;</span><br><span class="line">outputStream.reset();</span><br><span class="line">bg.compress(Bitmap.CompressFormat.JPEG, quality, outputStream);</span><br><span class="line">quality = quality - 3;</span><br><span class="line">&#125; while (outputStream.toByteArray().length / 1024 &gt;= 100 &amp;&amp; quality &gt; 0);</span><br><span class="line">Bitmap result = BitmapFactory.decodeByteArray(outputStream.toByteArray(), 0, outputStream.size());</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>参考资料</strong><br><a href="https://www.jianshu.com/p/e9e1db845c21" target="_blank" rel="noopener">Android 图片压缩之多种压缩方式结合使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们通常采用多种方式结合的方法实现图片压缩需求，这些方式包括质量压缩、尺寸压缩。本章将分别介绍这两种方式，并且最后将结合这两种方式实现图片压缩的最优解决方案。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="Bitmap" scheme="http://yoursite.com/tags/Bitmap/"/>
    
  </entry>
  
  <entry>
    <title>Coordinatorlayout使用全攻略</title>
    <link href="http://yoursite.com/2018/01/20/Coordinatorlayout%E4%BD%BF%E7%94%A8%E5%85%A8%E6%94%BB%E7%95%A5/"/>
    <id>http://yoursite.com/2018/01/20/Coordinatorlayout使用全攻略/</id>
    <published>2018-01-20T15:21:56.000Z</published>
    <updated>2019-02-17T02:03:35.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-自定义Behavior"><a href="#1-自定义Behavior" class="headerlink" title="1.自定义Behavior"></a>1.自定义Behavior</h2><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>其实Behavior就是一个应用于View的观察者模式，一个View跟随者另一个View的变化而变化，或者说一个View监听另一个View。<br>在Behavior中，被观察View也就是事件源被称为denpendcy，而观察View，则被称为child。<a id="more"></a><br><strong>Button与TextView的爱恨情仇</strong><br>首先在布局文件中跟布局设置为CoordinatorLayout，里面放一个Button和一个TextView。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;</span><br><span class="line">xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">&gt;</span><br><span class="line">&lt;TextView     </span><br><span class="line">app:layout_behavior=&quot;.EasyBehavior&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:text=&quot;观察者View child&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;Button     </span><br><span class="line">android:id=&quot;@+id/btn&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:layout_gravity=&quot;center&quot;</span><br><span class="line">android:text=&quot;被观察View dependency&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;/android.support.design.widget.CoordinatorLayout&gt;</span><br></pre></td></tr></table></figure></p><p>这里我们在Activity中做一些手脚，让Button动起来(不要在意坐标这些细节)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_easy_behavior);</span><br><span class="line">findViewById(R.id.btn).setOnTouchListener(new View.OnTouchListener() &#123;</span><br><span class="line">@Override public boolean onTouch(View v, MotionEvent event) &#123;        switch (event.getAction())&#123;          case MotionEvent.ACTION_MOVE:</span><br><span class="line">v.setX(event.getRawX()-v.getWidth()/2);</span><br><span class="line">v.setY(event.getRawY()-v.getHeight()/2);            break;</span><br><span class="line">&#125;        return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时，Button已经可以跟随手指移动了。<br>现在去自定义一个Behavior让TextView跟随Button一起动！<br>创建一个EasyBehavior类，继承于Behavior<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class EasyBehavior extends CoordinatorLayout.Behavior&lt;TextView&gt; &#123;//这里的泛型是child的类型，也就是观察者View</span><br><span class="line">public EasyBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class="line">super(context, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override  public boolean layoutDependsOn(CoordinatorLayout parent, TextView child, View dependency) &#123;    //告知监听的dependency是Button</span><br><span class="line">return dependency instanceof Button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override  //当 dependency(Button)变化的时候，可以对child(TextView)进行操作</span><br><span class="line">public boolean onDependentViewChanged(CoordinatorLayout parent, TextView child, View dependency) &#123;</span><br><span class="line">child.setX(dependency.getX()+200);</span><br><span class="line">child.setY(dependency.getY()+200);</span><br><span class="line">child.setText(dependency.getX()+&quot;,&quot;+dependency.getY());    return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意两个方法<br>layoutDependsOn() 代表寻找被观察View<br>onDependentViewChanged() 被观察View变化的时候回调用的方法<br>在onDependentViewChanged中，我们让TextView跟随Button的移动而移动。代码比较简单，一看就懂。<br><strong>Tip</strong><br>必须重写带双参的构造器，因为从xml反射需要调用。<br>接下来，在xml中，给TextView设置我们的Behavior。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView      </span><br><span class="line">app:layout_behavior=&quot;.EasyBehavior&quot;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:text=&quot;观察者View child&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><p>运行效果如下：<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/1.gif"></p><h2 id="2-CoordinatorLayout使用"><a href="#2-CoordinatorLayout使用" class="headerlink" title="2.CoordinatorLayout使用"></a>2.CoordinatorLayout使用</h2><p>CoordinatorLayout是谷歌提供的Material Design许多功能的基础，使用它你可以轻松地实现许多动画效果。这些效果包括：<br>1.滑动Floating Action Button为SnackBar的弹起提供空间。<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/2.gif"><br>2.展开或者收起Toolbar为屏幕的主内容提供空间。<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/3.gif"><br>3.控制某个应该被收起或展开的View以一定地视差效果完成动作，包括parallax scrolling effects 动画。<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/4.gif"></p><h4 id="Floating-Action-Buttons-和-Snackbars"><a href="#Floating-Action-Buttons-和-Snackbars" class="headerlink" title="Floating Action Buttons 和 Snackbars"></a>Floating Action Buttons 和 Snackbars</h4><p><code>FloatingActionButton</code>可以通过layout_anchor和layout_anchorGravity来控制显示的位置。当我们将其显示到屏幕的底端时，它会自动响应SnackBar的弹起或收起：SnackBar弹起后FloatingActionButton也弹起SnackBar的高度，收起后FloatingActionButton也收起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.CoordinatorLayout</span><br><span class="line">android:id=&quot;@+id/main_content&quot;</span><br><span class="line">xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.v7.widget.RecyclerView</span><br><span class="line">android:id=&quot;@+id/rvToDoList&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.design.widget.FloatingActionButton</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:layout_gravity=&quot;bottom|right&quot;</span><br><span class="line">android:layout_margin=&quot;16dp&quot;</span><br><span class="line">android:src=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">app:layout_anchor=&quot;@id/rvToDoList&quot;</span><br><span class="line">app:layout_anchorGravity=&quot;bottom|right|end&quot;/&gt;</span><br><span class="line">&lt;/android.support.design.widget.CoordinatorLayout&gt;</span><br></pre></td></tr></table></figure></p><h4 id="Expanding-和-Collapsing-Toolbars"><a href="#Expanding-和-Collapsing-Toolbars" class="headerlink" title="Expanding 和 Collapsing Toolbars"></a>Expanding 和 Collapsing Toolbars</h4><p>1.确保CoordinatorLayout是主容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">android:id=&quot;@+id/main_content&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;</span><br><span class="line">android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.v7.widget.Toolbar</span><br><span class="line">android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.CoordinatorLayout&gt;</span><br></pre></td></tr></table></figure></p><p>2.为了响应滑动事件，我们必须使用AppBarLayout:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.AppBarLayout</span><br><span class="line">android:id=&quot;@+id/appbar&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;@dimen/detail_backdrop_height&quot;</span><br><span class="line">android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span><br><span class="line">android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.v7.widget.Toolbar</span><br><span class="line">android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure></p><p>为了让滑动的View始终在AppBarLayout的下面，需要为滑动的View定义<code>layout_behavior</code>为@string/appbar_scrolling_view_behavior。我们还可以通过<code>app:layout_scrollFlags</code>控制AppBarLayout中的子View响应RecycleView的滑动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.AppBarLayout</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:fitsSystemWindows=&quot;true&quot;</span><br><span class="line">android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.v7.widget.Toolbar</span><br><span class="line">android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">app:layout_scrollFlags=&quot;scroll|enterAlways&quot;/&gt;</span><br><span class="line">&lt;android.support.v7.widget.RecyclerView</span><br><span class="line">android:id=&quot;@+id/rvToDoList&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;</span><br><span class="line">app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;/&gt;</span><br><span class="line">&lt;/android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure></p><p>关于layout_scrollFlags的值这里解释一下：</p><ol><li>scroll - 想滚动就必须设置这个。</li><li>enterAlways - 实现quick return效果, 当向下移动时，立即显示View（比如Toolbar)。</li><li>exitUntilCollapsed - 向上滚动时收缩View，但可以固定Toolbar一直在上面(可通过minHeight设置)。</li><li>enterAlwaysCollapsed - 当你的View已经设置minHeight属性又使用此标志时，你的View只能以最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。</li><li>snap - 如果头部滑动操作超过50%的距离，则自动关闭。如果头部滑动操作不超过50%的距离，则不关闭。</li></ol><h4 id="创建折叠效果"><a href="#创建折叠效果" class="headerlink" title="创建折叠效果"></a>创建折叠效果</h4><p>CollapsingToolbarLayout作用是提供了一个可以折叠的Toolbar，它继承至FrameLayout，给它设置layout_scrollFlags，它可以控制包含在CollapsingToolbarLayout中的控件(如：ImageView、Toolbar)在响应layout_behavior事件时作出相应的scrollFlags滚动事件(移除屏幕或固定在屏幕顶端)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.AppBarLayout  </span><br><span class="line">android:layout_width=&quot;match_parent&quot;  </span><br><span class="line">android:layout_height=&quot;256dp&quot;  </span><br><span class="line">android:fitsSystemWindows=&quot;true&quot;&gt;  </span><br><span class="line">&lt;android.support.design.widget.CollapsingToolbarLayout  </span><br><span class="line">android:id=&quot;@+id/collapsing_toolbar_layout&quot;  </span><br><span class="line">android:layout_width=&quot;match_parent&quot;  </span><br><span class="line">android:layout_height=&quot;match_parent&quot;  </span><br><span class="line">app:contentScrim=&quot;#30469b&quot;  </span><br><span class="line">app:expandedTitleMarginStart=&quot;48dp&quot;  </span><br><span class="line">app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;  </span><br><span class="line"></span><br><span class="line">&lt;ImageView  </span><br><span class="line">android:layout_width=&quot;match_parent&quot;  </span><br><span class="line">android:layout_height=&quot;match_parent&quot;  </span><br><span class="line">android:scaleType=&quot;centerCrop&quot;  </span><br><span class="line">android:src=&quot;@mipmap/bg&quot;  </span><br><span class="line">app:layout_collapseMode=&quot;parallax&quot;  </span><br><span class="line">app:layout_collapseParallaxMultiplier=&quot;0.7&quot;  /&gt;  </span><br><span class="line"></span><br><span class="line">&lt;android.support.v7.widget.Toolbar  </span><br><span class="line">android:id=&quot;@+id/toolbar&quot;  </span><br><span class="line">android:layout_width=&quot;match_parent&quot;  </span><br><span class="line">android:layout_height=&quot;?attr/actionBarSize&quot;  </span><br><span class="line">app:layout_collapseMode=&quot;pin&quot; /&gt;  </span><br><span class="line">&lt;/android.support.design.widget.CollapsingToolbarLayout&gt;  </span><br><span class="line">&lt;android.support.v7.widget.RecyclerView  </span><br><span class="line">android:id=&quot;@+id/recyclerView&quot;  </span><br><span class="line">android:layout_width=&quot;match_parent&quot;  </span><br><span class="line">android:layout_height=&quot;match_parent&quot;</span><br><span class="line">app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</span><br><span class="line">android:scrollbars=&quot;none&quot; /&gt;  </span><br><span class="line">&lt;/android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure></p><p>1、在CollapsingToolbarLayout中设置了一个ImageView和一个Toolbar。并把这个CollapsingToolbarLayout放到AppBarLayout中作为一个整体。<br>在CollapsingToolbarLayout中，我们除了设置layout_scrollFlags，还可以设置一些其它的属性，简要说明一下：</p><ul><li>contentScrim - 设置当完全CollapsingToolbarLayout折叠(收缩)后的背景颜色。</li><li>expandedTitleMarginStart - 设置扩张时候(还没有收缩时)title向左填充的距离。</li></ul><p>没扩张时候如图：<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/5.png"><br>2、在ImageView控件中：<br>我们设置了layout_collapseMode (折叠模式) - 有两个值:</p><ul><li>pin -  设置为这个模式时，当CollapsingToolbarLayout完全收缩后，Toolbar还可以保留在屏幕上。</li><li>parallax - 设置为这个模式时，在内容滚动时，CollapsingToolbarLayout中的View（比如ImageView)也可以同时滚动，实现视差滚动效果，通常和layout_collapseParallaxMultiplier(设置视差因子)搭配使用。</li><li>layout_collapseParallaxMultiplier(视差因子) - 设置视差滚动因子，值为：0~1。</li></ul><p>3、在Toolbar控件中，我们设置了layout_collapseMode(折叠模式)为pin。<br>效果如图:<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/6.gif"><br>综上分析：当设置了layout_behavior的控件响应起了CollapsingToolbarLayout中的layout_scrollFlags事件时，ImageView会有视差效果的向上滚动移除屏幕，当开始折叠时CollapsingToolbarLayout的背景色(也就是Toolbar的背景色)就会变为我们设置好的背景色，Toolbar也一直会固定在最顶端。</p><blockquote><p><strong>注意：</strong><br>使用CollapsingToolbarLayout时必须把title设置到CollapsingToolbarLayout上，设置到Toolbar上不会显示。即：mCollapsingToolbarLayout.setTitle(“ “);</p></blockquote><h4 id="Bottom-Sheet"><a href="#Bottom-Sheet" class="headerlink" title="Bottom Sheet"></a>Bottom Sheet</h4><p>有两种类型的<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0327/7729.html" target="_blank" rel="noopener">Bottom Sheet</a>：<br>1.<strong>Persistent bottom sheet :</strong>通常用于显示主界面之外的额外信息，它是主界面的一部分，只不过默认被隐藏了，其深度（elevation）跟主界面处于同一级别；还有一个重要特点是在Persistent bottom sheet打开的时候，主界面仍然是可以操作的。ps：Persistent bottom sheet该如何翻译呢？我觉得翻译为普通bottom sheet就好了，还看到有人翻译为“常驻bottom sheet”，可能更接近于英语的字面意思，可是反而不易理解。<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/7.png"><br>2.<strong>模态bottom sheet :</strong>顾名思义，模态的bottom sheet在打开的时候会阻止和主界面的交互，并且在视觉上会在bottom sheet背后加一层半透明的阴影，使得看上去深度（elevation）更深。<br>总结起来这两种Bottom Sheet的区别主要在于视觉和交互上，当然使用方法也是不一样的。<br><img src="/2018/01/20/Coordinatorlayout使用全攻略/8.png"></p><hr><p><strong>参考资料</strong><br><a href="https://guides.codepath.com/android/Handling-Scrolls-with-CoordinatorLayout#troubleshooting-coordinated-layouts" target="_blank" rel="noopener">CoordinatorLayout介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-自定义Behavior&quot;&gt;&lt;a href=&quot;#1-自定义Behavior&quot; class=&quot;headerlink&quot; title=&quot;1.自定义Behavior&quot;&gt;&lt;/a&gt;1.自定义Behavior&lt;/h2&gt;&lt;h4 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h4&gt;&lt;p&gt;其实Behavior就是一个应用于View的观察者模式，一个View跟随者另一个View的变化而变化，或者说一个View监听另一个View。&lt;br&gt;在Behavior中，被观察View也就是事件源被称为denpendcy，而观察View，则被称为child。
    
    </summary>
    
      <category term="Android View" scheme="http://yoursite.com/categories/Android-View/"/>
    
    
      <category term="Coordinatorlayout" scheme="http://yoursite.com/tags/Coordinatorlayout/"/>
    
  </entry>
  
</feed>
