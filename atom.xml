<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TXM</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-29T11:35:38.162Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>TXM</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GlobalDialog框架使用教程</title>
    <link href="http://yoursite.com/2017/06/10/GlobalDialog%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/06/10/GlobalDialog框架使用教程/</id>
    <published>2017-06-10T00:37:54.000Z</published>
    <updated>2017-12-29T11:35:38.162Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2109293-cdafa26ebd9bd991.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请勿模仿。"><br>GlobalDialog是由<a href="http://italkyou.bmob.site" target="_blank" rel="noopener">ITalk应用</a>开源的一款全局对话框库。相比于Android原生对话框的繁琐配置，GlobalDialog的优势在于能够快速实现<strong>全局对话框</strong>的功能（通知账号下线、通知账号异常等）。进一步了解，请访问笔者的<a href="https://github.com/tangxianming/global-dialog" target="_blank" rel="noopener">Github</a>。<br><a id="more"></a> </p><p>#集成方法<br>在Module的build.gradle文件中添加如下依赖即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.txm.topcodes.globaldialog:globaldialog:0.1.6&apos;</span><br></pre></td></tr></table></figure></p><p>#调用方式<br>常规方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new GlobalDialog.Builder()</span><br><span class="line">.setContext(context) </span><br><span class="line">.setDescription(&quot;hello world&quot;) //弹出框的提示信息。</span><br><span class="line">.setStyle(GlobalDialog.Style.SingleAlert) //弹窗的样式。有DoubleAlert、SingleAlert两种，默认为后者。</span><br><span class="line">.setForce(ture) //设置弹框销毁的策略。默认为true。</span><br><span class="line">.setDialogClickListener(new OnDialogClickListener() &#123; //设置回调，也可以不设置。</span><br><span class="line">@Override</span><br><span class="line">public void onSure() &#123;</span><br><span class="line">super.onSure();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).build().show();</span><br></pre></td></tr></table></figure></p><p>精简方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new GlobalDialog.Builder()</span><br><span class="line">.setContext(context) </span><br><span class="line">.setDescription(&quot;hello world&quot;) </span><br><span class="line">.build().show();</span><br></pre></td></tr></table></figure></p><p>#FAQ</p><hr><p><strong>我发现GlobalDialog还存在BUG？</strong><br>GlobalDialog是一个完全开源的框架，如果您在使用过程中发现问题，欢迎在笔者的GitHub创建一个<a href="https://github.com/tangxianming/global-dialog/issues" target="_blank" rel="noopener">Issue</a>。</p><p><strong>我是Eclipse用户，可以使用GlobalDialog么？</strong><br>不可以。</p><p><strong>我在Android studio中链接GlobalDialog库失败了？</strong><br>确保您的工程使用的远程仓库为jcenter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">jcenter()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2109293-cdafa26ebd9bd991.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;请勿模仿。&quot;&gt;&lt;br&gt;GlobalDialog是由&lt;a href=&quot;http://italkyou.bmob.site&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ITalk应用&lt;/a&gt;开源的一款全局对话框库。相比于Android原生对话框的繁琐配置，GlobalDialog的优势在于能够快速实现&lt;strong&gt;全局对话框&lt;/strong&gt;的功能（通知账号下线、通知账号异常等）。进一步了解，请访问笔者的&lt;a href=&quot;https://github.com/tangxianming/global-dialog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="我的Android框架" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84Android%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="View" scheme="http://yoursite.com/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>AutoCache高性能缓存框架使用教程</title>
    <link href="http://yoursite.com/2016/10/23/AutoCache%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/10/23/AutoCache高性能缓存框架使用教程/</id>
    <published>2016-10-22T23:00:20.000Z</published>
    <updated>2017-12-29T11:36:43.187Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2109293-d934024b5cb541e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一只正在设计AutoCache的攻城狮"></p><blockquote><p><strong>读者可能会问在下：</strong></p><ol><li>为什么要使用AutoCache？<br>简洁、高性能。</li><li>现在市面上有那么多缓存的框架，像piccso等都很优秀，那笔者是不是在重复造车？<br>AutoCache是为那些追求轻量级缓存的APP而生的。目的是让开发者既能快速完成APP缓存功能的开发，又能保证上线后性能的稳定。</li></ol></blockquote><a id="more"></a> <p><a href="https://github.com/tangxianming/auto-cache" target="_blank" rel="noopener">AutoCache</a> 能够让你高效地编写app缓存代码 ，保证你的数据流被安全、准确地存储到SDcard私有目录。参考下列核心调用代码来开始你的 AutoCache 之旅：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.MediaCache.getInstance(context).asyncCache(&quot;url&quot;, new CallBack() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onStart() &#123;</span><br><span class="line">//Run in UI thread.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void save2DataBase(String cachePath) &#123;</span><br><span class="line">//Run in io thread,</span><br><span class="line">//You can sava the  cachPath to database or sharepreference.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onSuccess(byte[] bytes) &#123;</span><br><span class="line">//Run in UI thread.</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onErro(Throwable e) &#123;</span><br><span class="line">//Run in UI thread.</span><br><span class="line">&#125;</span><br><span class="line">&#125;, FILE_TYPE, &quot;filename&quot;);</span><br></pre></td></tr></table></figure></p><p>#集成方法<br>在Module的build.gradle文件中添加如下依赖即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.txm.topcodes.autocache:autocache:0.1.2&apos;</span><br></pre></td></tr></table></figure></p><p>#调用方式<br>为方便开发者，AutoCache提供统一调用入口，调用方式十分简洁。下面先给大家看一张思维导图，该图罗列了框架的主体功能及其构成。</p><p><img src="http://upload-images.jianshu.io/upload_images/2109293-8b44b4cfd957789e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AutoCache功能结构图"></p><p>从结构图不难看出，<strong>AutoCache类</strong>就是调用框架的入口类。当我们需要从本地获取流文件时，调用方式是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.Media.get…();</span><br></pre></td></tr></table></figure></p><p>缓存网络文件时，调用方式是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.MediaCache.getInstance(context).asyncCache();</span><br></pre></td></tr></table></figure></p><p>缓存内存文件时，调用方式是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.MediaCache.getInstance(context).cache();</span><br></pre></td></tr></table></figure></p><p>当需要指定文件文件类型时，使用方式是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.DIRECTORY_PICTURES</span><br></pre></td></tr></table></figure></p><p>「如需获取详细信息，请在 <a href="https://github.com/tangxianming/auto-cache" target="_blank" rel="noopener">GitHub 的 auto-cache页面</a>查看源代码.」</p><p>#文件类型<br>AutoCache支持缓存以下泛媒体类型：Podcasts,Pictures,Movies,Music,Documents,Download。<em>其中Download比较特殊，用它可以指定未知的文件类型。</em></p><p>#使用场景<br>当我们的APP从网络获取文件流时，往往会有这样的需求「也可能是其中之一」：</p><ol><li>网络请求时，要可以自动将文件保存到APP本地。</li><li>网络请求时，将网络图片的本地路径存储到SQLite或其它数据持久化中，以方便逻辑处理。</li><li>网络请求时，直接使用从网络获取到文件流。</li><li>网络请求时，方便添加进度条功能。</li><li>网络请求时，全局捕获异常。</li><li>本次请求之后，根据文件名、文件类型从本地获取文件流。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/2109293-7880687895d6e259.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>对于需求1。</strong>AutoCache完全是在后台<em>IO线程</em>中完成的，不需要调用者主动去操作。</p><blockquote><p>IO线程：I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io线程比Thread线程更有效率。</p></blockquote><p><strong>对于需求2。</strong>save2DataBase(String cachePath)回调方法自动就被指定在IO线程中运行。「所以，save2DataBase既是一个非阻塞的方法，又具备IO线程的高效性。」</p><p><strong>对于需求3。</strong>onSuccess(byte[] bytes)回调方法被指定自动运行在UI线程中。</p><p><strong>对于需求4。</strong>AutoCache提供了onstart()回调方法作为调用开始的标志，onSuccess(byte[] bytes)或onErro(Throwable e)作为调用结束点。</p><p><strong>对于需求5。</strong>全局捕获异常指的是：onErro(Throwable e)不仅可以捕获网络异常、本地缓存媒体时发生的异常，而且还可以捕获发生在onStart、save2DataBase、onSuccess中的异常。</p><p><strong>对于需求6。</strong>AutoCache.Media类提供了4种同步方式来获取本地的媒体流。</p><p>#最佳实践</p><hr><p>####防止OOM<br>AutoCache.Media类中提供了getSoftBmp(~)，getWeakBmp(~)，getBmp(~)，getFile(~)四种方式来获取流。如果是图片文件，笔者建议使用前两种方式，具体可参考<a href="http://www.cnblogs.com/dolphin0520/p/3784171.html" target="_blank" rel="noopener">善于利用软引用和弱引用。</a></p><p>####定制回调方法<br>AutoCache框架提供了CallBackAdapter接口用于替换CallBack接口。可以通过它实现自由定制自己需要的回调方法。「这样是为了代码看上去简洁。」<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AutoCache.MediaCache.getInstance(context).asyncCache(&quot;url&quot;, new CallBackAdapter() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void save2DataBase(String cachePath) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void onSuccess(byte[] bytes) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//you can add other callback function here.</span><br><span class="line">&#125;,FILE_TYPE,&quot;filename&quot;);</span><br></pre></td></tr></table></figure></p><p>#FAQ</p><hr><p><strong>我发现AutoCache还存在BUG？</strong><br>AutoCache是一个完全开源的框架，如果您在使用过程中发现问题，请在<a href="https://github.com/tangxianming/auto-cache/issues" target="_blank" rel="noopener">GitHub</a>创建一个问题。</p><p><strong>我是Eclipse用户，可以使用AutoCache么？</strong><br>不可以。</p><p><strong>AutoCache用到了哪些第三方框架？</strong><br>是的。AutoCache是在RXjava+Okhttp基础之上封装的一个轻量级缓存框架。</p><p><strong>AutoCache提供缓存文件路径到SQLite数据库的方法了吗？</strong><br>没有。AutoCache缓存的重心是将流文件缓存到本地目录。如果需要将文件路径缓存到SQLite或其他持久化数据层中，开发者需要自行在save2DataBase(cachePath)回调方法中实现逻辑。</p><p><strong>我在android studio中链接AutoCache库失败了？</strong><br>确保您的工程使用的远程仓库为jcenter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">jcenter()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>————–我是一条萌萌哒的分割线，表示教程结束—————-</p><p><img src="http://upload-images.jianshu.io/upload_images/2109293-f58c2a709b60c8f3.gif?imageMogr2/auto-orient/strip" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2109293-d934024b5cb541e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;一只正在设计AutoCache的攻城狮&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;读者可能会问在下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么要使用AutoCache？&lt;br&gt;简洁、高性能。&lt;/li&gt;
&lt;li&gt;现在市面上有那么多缓存的框架，像piccso等都很优秀，那笔者是不是在重复造车？&lt;br&gt;AutoCache是为那些追求轻量级缓存的APP而生的。目的是让开发者既能快速完成APP缓存功能的开发，又能保证上线后性能的稳定。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的Android框架" scheme="http://yoursite.com/categories/%E6%88%91%E7%9A%84Android%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Cache" scheme="http://yoursite.com/tags/Cache/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio NDK开发全攻略</title>
    <link href="http://yoursite.com/2016/08/14/NDK%E5%BC%80%E5%8F%91%E5%85%A8%E6%94%BB%E7%95%A5/"/>
    <id>http://yoursite.com/2016/08/14/NDK开发全攻略/</id>
    <published>2016-08-14T07:56:00.000Z</published>
    <updated>2017-12-09T09:55:29.485Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2109293-2f486474306a0eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p><strong>读完本章，你可以：</strong></p><ul><li><em>在Android Studio上轻松搭建NDK开发环境。</em></li><li><em>掌握最快捷的JNI开发方式。</em></li><li><em>掌握使用.so文件开发Android程序的技巧。</em></li></ul></blockquote><a id="more"></a> <h3 id="一、-NDK环境搭建"><a href="#一、-NDK环境搭建" class="headerlink" title="一、 NDK环境搭建"></a>一、 NDK环境搭建</h3><ol><li>开发工具准备<br>要进行Android NDK开发，首先要下载Android NDK开发工具。可以在AndroidStudio上面下载，也可以自己下载好了，然后将NDK的路径设置为自己下载的Android NDK开发工具的路径。<br><img src="http://upload-images.jianshu.io/upload_images/2109293-935b1d5e7af0abb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android Studio中设置NDK路径"></li><li>Gradle的相关配置<br>1) 我们来配置Project的build.gradle。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*gradle插件不支持NDK，我们需要使用gradle-experimental插件。 */</span><br><span class="line">dependencies &#123;</span><br><span class="line">classpath &apos;com.android.tools.build:gradle-experimental:0.7.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2) 我们来配置Module的build.gradle。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.model.application&apos;</span><br><span class="line">model &#123;</span><br><span class="line">android &#123;</span><br><span class="line">compileSdkVersion = 23</span><br><span class="line">buildToolsVersion = &quot;23.0.2&quot;</span><br><span class="line">defaultConfig &#123;</span><br><span class="line">applicationId &quot;com.lavor.ndklearning&quot;</span><br><span class="line">minSdkVersion.apiLevel 15</span><br><span class="line">targetSdkVersion.apiLevel 23</span><br><span class="line">versionCode 4</span><br><span class="line">versionName &quot;1.0.1&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">android.ndk &#123;</span><br><span class="line">moduleName &quot;lavor&quot;</span><br><span class="line">ldLibs.addAll([&apos;log&apos;])</span><br><span class="line">cppFlags.add(&quot;-std=c++11&quot;)</span><br><span class="line">cppFlags.add(&quot;-fexceptions&quot;)</span><br><span class="line">platformVersion 15</span><br><span class="line">stl &apos;gnustl_shared&apos;</span><br><span class="line">&#125;</span><br><span class="line">android.buildTypes &#123;</span><br><span class="line">release &#123;</span><br><span class="line">minifyEnabled = false</span><br><span class="line">proguardFiles.add(file(&quot;proguard-rules.txt&quot;))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">compile &apos;com.android.support:appcompat-v7:23.1.1&apos;</span><br><span class="line">compile &apos;com.android.support:recyclerview-v7:23.1.1&apos;</span><br><span class="line">compile &apos;com.android.support:design:23.1.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>小提示</strong> </p><ul><li>首先，在apply的时候我们引入的插件名称由’com.android.application’变成了’com.android.model.application’。</li><li>其次，在原来android的外层加入了一个model层次。</li><li>再次，原来在android的里面的块，除了defaultConfig外，全部移除android块放入model块中与android并列，并且前面的名字加上android.。</li><li>然后，compileSdkVersion 23与 buildToolsVersion “23.0.2”改成 compileSdkVersion = 23和 buildToolsVersion = “23.0.2”，中间加上了=。</li><li>其次，添加上android.ndk块，块中的moduleName表示C/C++代码打包成so文件的名字。</li><li>再次，android.buildTypes块中的proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’改成proguardFiles.add(file(“proguard-rules.txt”))。</li><li>最后，注意dependencies块依然在最外层，它不在model块中。</li></ul></blockquote><h3 id="二、-使用NDK开发第一个JNI程序"><a href="#二、-使用NDK开发第一个JNI程序" class="headerlink" title="二、 使用NDK开发第一个JNI程序"></a>二、 使用NDK开发第一个JNI程序</h3><ol><li>在Android程序中新建一个包含native（本地）方法的NDKTest类。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.lavor.ndklearning;</span><br><span class="line">public class NDKTest &#123;</span><br><span class="line">static &#123;</span><br><span class="line">//加载.so库文件</span><br><span class="line">System.loadLibrary(&quot;lavor&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public native String getString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>小知识</strong> </p><ul><li>程序中static{}称为静态代码块，它在类初始化的时候执行。<a href="http://www.2cto.com/kf/201204/127350.html" target="_blank" rel="noopener">不懂请猛击&gt;&gt;</a></li></ul><ol><li>将鼠标移动到方法名getString上，然后按下Alt+Enter快捷键，弹出一些解决的方法建议，点击第一个Create Function…<br><img src="http://upload-images.jianshu.io/upload_images/2109293-b72c498ba03487b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自动生成.c文件"></li><li>此时会自动建立一个与java目录同级的jni目录，在jni目录自动建立一个c文件，在c文件中实现了刚才的native方法。<br><img src="http://upload-images.jianshu.io/upload_images/2109293-45dae37602388281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=".c文件"></li><li>然后，稍稍修改一下.c文件中实现的native方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_lavor_ndklearning_NDKTest_getString(JNIEnv *env, jobject instance) &#123;</span><br><span class="line">// TODO</span><br><span class="line">return (*env)-&gt;NewStringUTF(env, &quot;AndroidStudio NDK开发最佳入门实践&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>补充说明</strong> </p><ul><li>仔细观察可以看到c文件的方法名是遵循“Java_包名类名本地方法名”来组织的（了解到这些后，我们就可以脱离编译器的帮助，直接去写.c文件啦）。</li></ul><ol><li>最后在Android程序中调用JNI接口。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">private android.widget.TextView text;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">this.text = (TextView) findViewById(R.id.text);</span><br><span class="line">NDKTest NDK=new NDKTest();</span><br><span class="line">text.setText(NDK.getString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>运行程序后界面如下：<br><img src="http://upload-images.jianshu.io/upload_images/2109293-adee2cd57d50fdf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p><blockquote><p><strong>深度总结</strong> </p><ul><li>讲道理，我们在正式开发时，不会像这样子去开发。因为这样的话就会把我们的c代码也暴露了出来。这明显与JNI的安全保密机制相违背，所以，正式开发的时候，我们会使用.so文件进行全保密式的开发。</li></ul></blockquote><h3 id="三、-使用-so文件开发Android程序"><a href="#三、-使用-so文件开发Android程序" class="headerlink" title="三、 使用.so文件开发Android程序"></a>三、 使用.so文件开发Android程序</h3><p>不知道大家有没有记得<a href="http://www.jianshu.com/p/cd8893549238" target="_blank" rel="noopener">上一章</a>说过，使用JNI有个好处就是安全性高，JNI部分的代码很难被反编译。这其实是要归功于.so文件。下图为.so文件的生成位置。<br><img src="http://upload-images.jianshu.io/upload_images/2109293-bb1e5e5126c27518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android Studio中生成的.so文件位置"><br>具体的使用步骤是怎样的呢？</p><ol><li>新建一个Android工程，命名为：AndroidApplication。（工程名、包名、组织名任意）<br><img src="http://upload-images.jianshu.io/upload_images/2109293-216c5583d760f537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个随意的Android工程"></li><li>导入.so文件至app/libs中。<br><img src="http://upload-images.jianshu.io/upload_images/2109293-c5b1fcba143015f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入.so文件至Android工程"></li><li><p>为了能够调用libs文件夹下的.so资源，需在app的build.gradle的android节点下设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sourceSets&#123;</span><br><span class="line">main&#123;</span><br><span class="line">jniLibs.srcDirs = [&apos;libs&apos;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建相关类结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.lavor.ndklearning;</span><br><span class="line">public class NDKTest &#123;</span><br><span class="line">static &#123;</span><br><span class="line">//加载.so库文件</span><br><span class="line">System.loadLibrary(&quot;lavor&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public native String getString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>补充说明</strong> </p><ul><li>Android端声明native code的代码需要严格按照JNI接口来组织。（也就是说，包名、类名都要和.so文件中JNI名称一致）<a href="http://billhoo.blog.51cto.com/2337751/1125559" target="_blank" rel="noopener">不懂就点击这里吧&gt;&gt;</a></li></ul><ol><li>函数调用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DemoActivity extends AppCompatActivity &#123;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_demo);</span><br><span class="line">Log.d(&quot;NDK&quot;,new NDKTest().getString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>运行结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/2109293-9974de0ded907081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p><blockquote><p> 注意啦！<em>此文并非原创，算是对一波优秀文章的总结吧。笔者希望通过这种方式激励自己学习，也期待可以帮到正在学习NDK的你。欢迎指出本文的BUG，共勉！！！！！</em></p></blockquote><hr><p><strong>参考资料</strong></p><ol><li><a href="https://github.com/lavor-zl/NDKLearning" target="_blank" rel="noopener">AndroidStudio NDK开发最佳入门实践</a></li><li><a href="http://billhoo.blog.51cto.com/2337751/1125559" target="_blank" rel="noopener">如何在Android中使用编译好的.so库</a></li><li><a href="http://blog.csdn.net/walid1992/article/details/51501357" target="_blank" rel="noopener"> Android Studio NDK及so文件开发</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2109293-2f486474306a0eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;读完本章，你可以：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;在Android Studio上轻松搭建NDK开发环境。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;掌握最快捷的JNI开发方式。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;掌握使用.so文件开发Android程序的技巧。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NDK" scheme="http://yoursite.com/categories/NDK/"/>
    
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
      <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>七夕前，我认识了NDK</title>
    <link href="http://yoursite.com/2016/08/06/%E4%B8%83%E5%A4%95%E5%89%8D%EF%BC%8C%E6%88%91%E8%AE%A4%E8%AF%86%E4%BA%86NDK/"/>
    <id>http://yoursite.com/2016/08/06/七夕前，我认识了NDK/</id>
    <published>2016-08-06T10:57:00.000Z</published>
    <updated>2017-12-09T09:55:40.540Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2109293-3952aad8fb71012c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NDK妹子生活照"></p><blockquote><p><strong>看前必读</strong></p><ul><li><em>读完本章，你可以掌握NDK、JNI的概念及其开发流程。</em></li><li><em>阅读时，不必纠结于读不懂的代码结构，后面的教程 都会讲到的。</em></li></ul></blockquote><a id="more"></a> <h3 id="一、为何要学习NDK？"><a href="#一、为何要学习NDK？" class="headerlink" title="一、为何要学习NDK？"></a>一、为何要学习NDK？</h3><ol><li>代码的保护。Android APK的Java层代码很容易被反编译，但C/C++库反编译难度较大。</li><li>可以方便地使用现存的开源库。大部分现存的开源库都是用C/C++代码编写的。</li><li>提高程序的执行效率。将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。</li><li>便于移植。用C/C++写的库可以方便在其他的嵌入式平台上再次使用。</li></ol><h3 id="二、先知道什么是JNI"><a href="#二、先知道什么是JNI" class="headerlink" title="二、先知道什么是JNI"></a>二、先知道什么是JNI</h3><p>JNI（Java Native Interface）是Java语言提供的Java和C/C++互相沟通的机制，可以实现：</p><ol><li>java调用本地的C/C++代码</li><li>本地的C/C++代码也可以调用java代码</li></ol><h3 id="三、开发JNI程序的简化流程"><a href="#三、开发JNI程序的简化流程" class="headerlink" title="三、开发JNI程序的简化流程"></a>三、开发JNI程序的简化流程</h3><ol><li><p>编写Java Code，如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 加载lavor本地共享库到内存中</span><br><span class="line">*/</span><br><span class="line">static &#123;</span><br><span class="line">System.loadLibrary(&quot;lavor&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 定义本地方法对应的Java方法</span><br><span class="line">*</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public native String getString();</span><br></pre></td></tr></table></figure></li><li><p>编写C/C++，如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_lavor_ndklearning_MainActivity_getString(JNIEnv *env, jobject instance) &#123;</span><br><span class="line"></span><br><span class="line">return (*env)-&gt;NewStringUTF(env, &quot;这是我的c程序代码&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译 C/C++ Code，成功并得到本地共享库。</p><blockquote><p><strong>小知识</strong> </p><ul><li>本地共享库是Linux下的叫法，文件扩展名是.so，windows下叫动态链接库，文件扩展名是.dll。</li><li><a name="001" id="001">C /C++的跨平台性是以牺牲编译时间以及编译难度为代价的。（<em>这里的编译难度是指为适应不同平台而做的编译过程的调整）</em></a></li><li>Java的一次编译到处运行，是以牺牲运行效率为代价的。</li></ul></blockquote></li><li><p>编译并打包Java。<br>把本地共享库<em>（.so文件）</em>放置到Java项目的指定目录，一般是libs文件夹。然后编译Java代码即可打包运行。</p><blockquote><p><strong>小知识</strong></p><ul><li>Android项目中，.so文件存放地址为libs/armeabi。<em>(armeabi是对应的平台，下一章将会详细介绍)</em></li></ul></blockquote></li></ol><h3 id="四、NDK概述"><a href="#四、NDK概述" class="headerlink" title="四、NDK概述"></a>四、NDK概述</h3><p>NDK<em>(Native  Development Kit)</em>是Google为Android进行本地开发而放出的一个本地开发工具， 包括Android的Native API、公共库以及编译工具。其实说白就是Google为方便Android程序猿开发JNI程序，而提供的便捷工具。</p><blockquote><p><strong>补充两点</strong></p><ul><li>NDK处在JNI开发流程中的编译环节<em>（第三、四步）</em>。针对不同的平台，NDK可以全自动编译出对应可运行的本地共享库，并可将对应的.so文件和应用程序一起打包成apk发布。<em>（这时，跨平台编译C/C++的难度指数降为0。<a href="#001">不明白请猛击</a>）</em></li><li>NDK需要Android 1.5版本以上的支持。</li></ul></blockquote><h3 id="五、开发NDK程序的流程"><a href="#五、开发NDK程序的流程" class="headerlink" title="五、开发NDK程序的流程"></a>五、开发NDK程序的流程</h3><p>这个开发流程大致与JNI的开发流程差不多：</p><ol><li>SDK开发。编写Java代码，调用各种Android的API实现功能，编写含有native关键字的代码开始JNI。</li><li>JNI开发。按照 JNI编码规范，编写与Java交互的本地代码<em>（一般就是数据类型的转换，把 C/C++的数据类转换成Java能识别的，或反过来）</em>。</li><li>C/C++开发。编码实现业务逻辑，或调用NDK提供的本地API或库，完成Android平台上特定功能的开发、封装。</li><li>NDK编译，编写.mk文件，编译调试，最后修改.mk文件，针对特定的平台（ARM/x86）做编译结果的优化。</li><li>最后就是SDK编译、打包，上真机调试了…</li></ol><blockquote><p> 注意啦！<em>此文并非原创，算是对一波优秀文章的总结吧。笔者希望通过这种方式激励自己学习，也期待可以帮到正在学习NDK的你。欢迎指出本文的BUG，共勉！！！！！</em></p></blockquote><hr><p><strong>参考资料</strong></p><ol><li><a href="http://www.android100.org/html/201308/16/3970.html" target="_blank" rel="noopener">NDK和SDK以及JNI有什么关系？</a></li><li><a href="http://www.cnblogs.com/devinzhang/archive/2012/02/29/2373729.html" target="_blank" rel="noopener">Android之NDK开发</a></li><li><a href="http://wear.techbrood.com/tools/sdk/ndk/" target="_blank" rel="noopener">Android NDK官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2109293-3952aad8fb71012c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;NDK妹子生活照&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;看前必读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;读完本章，你可以掌握NDK、JNI的概念及其开发流程。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;阅读时，不必纠结于读不懂的代码结构，后面的教程 都会讲到的。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NDK" scheme="http://yoursite.com/categories/NDK/"/>
    
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
      <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
</feed>
